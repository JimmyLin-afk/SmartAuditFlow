nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
Lock.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IBondNFT.sol"";
import ""./interfaces/IGovNFT.sol"";

contract Lock is Ownable{

    uint public constant minPeriod = 7;
    uint public constant maxPeriod = 365;

    IBondNFT public immutable bondNFT;
    IGovNFT public immutable govNFT;

    mapping(address => bool) public allowedAssets;
    mapping(address => uint) public totalLocked;

    constructor(
        address _bondNFTAddress,
        address _govNFT
    ) {
        bondNFT = IBondNFT(_bondNFTAddress);
        govNFT = IGovNFT(_govNFT);
    }

    /**
     * @notice Claim pending rewards from a bond
     * @param _id Bond NFT id
     * @return address claimed tigAsset address
     */
    function claim(
        uint256 _id
    ) public returns (address) {
        claimGovFees();
        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);
        IERC20(_tigAsset).transfer(msg.sender, _amount);
        return _tigAsset;
    }

    /**
     * @notice Claim pending rewards left over from a bond transfer
     * @param _tigAsset token address being claimed
     */
    function claimDebt(
        address _tigAsset
    ) external {
        claimGovFees();
        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);
        IERC20(_tigAsset).transfer(msg.sender, amount);
    }

    /**
     * @notice Lock up tokens to create a bond
     * @param _asset tigAsset being locked
     * @param _amount tigAsset amount
     * @param _period number of days to be locked for
     */
    function lock(
        address _asset,
        uint _amount,
        uint _period
    ) public {
        require(_period <= maxPeriod, ""MAX PERIOD"");
        require(_period >= minPeriod, ""MIN PERIOD"");
        require(allowedAssets[_asset], ""!asset"");

        claimGovFees();

        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        totalLocked[_asset] += _amount;
        
        bondNFT.createLock( _asset, _amount, _period, msg.sender);
    }

    /**
     * @notice Reset the lock time and extend the period and/or token amount
     * @param _id Bond id being extended
     * @param _amount tigAsset amount being added
     * @param _period number of days being added
     */
    function extendLock(
        uint _id,
        uint _amount,
        uint _period
    ) public {
        address _asset = claim(_id);
        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);
    }

    /**
     * @notice Release the bond once it's expired
     * @param _id Bond id being released
     */
    function release(
        uint _id
    ) public {
        claimGovFees();
        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);
        totalLocked[asset] -= lockAmount;
        IERC20(asset).transfer(_owner, amount);
    }

    /**
     * @notice Claim rewards from gov nfts and distribute them to bonds
     */
    function claimGovFees() public {
        address[] memory assets = bondNFT.getAssets();

        for (uint i=0; i < assets.length; i++) {
            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));
            IGovNFT(govNFT).claim(assets[i]);
            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));
            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);
            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);
        }
    }

    /**
     * @notice Whitelist an asset
     * @param _tigAsset tigAsset token address
     * @param _isAllowed set tigAsset as allowed
     */
    function editAsset(
        address _tigAsset,
        bool _isAllowed
    ) external onlyOwner() {
        allowedAssets[_tigAsset] = _isAllowed;
    }

    /**
     * @notice Owner can retreive Gov NFTs
     * @param _ids array of gov nft ids
     */
    function sendNFTs(
        uint[] memory _ids
    ) external onlyOwner() {
        govNFT.safeTransferMany(msg.sender, _ids);
    }
}",1088,145,"[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost
There are two functions that allow to lock some amount of assets. The first function is Lock.lock which creates a new bond. The second function is the function `extendLock`. This function extends the lock for some `_period` and / or increases the locked amount by some `_amount`.
The issue is that the `extendLock` function does not increase the value in `totalLocked[_asset]`. This however is necessary because `totalLocked[_asset]` is reduced when `release` is called.
Therefore only the amount of assets deposited via `lock` can be released again. The amount of assets deposited using `extendLock` can never be released again because reducing `totalLocked[_asset]` will cause a revert due to underflow.
  [M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract
When calling the function `claimGovFees()`, assets that are set to be not allowed or assets that don't have any shares yet in the BondNFT contract will cause a silent failure in the function `bondNFT.distribute`.
  [M-02] Must approve 0 first
Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved in function `claimGovFees()`.  Recommend: Add an approve(0) before approving",3,,"pragma solidity ^0.8.0;

import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IBondNFT.sol"";
import ""./interfaces/IGovNFT.sol"";

contract Lock is Ownable{

    uint public constant minPeriod = 7;
    uint public constant maxPeriod = 365;

    IBondNFT public immutable bondNFT;
    IGovNFT public immutable govNFT;

    mapping(address => bool) public allowedAssets;
    mapping(address => uint) public totalLocked;

    constructor(
        address _bondNFTAddress,
        address _govNFT
    ) {
        bondNFT = IBondNFT(_bondNFTAddress);
        govNFT = IGovNFT(_govNFT);
    }

    
    function claim(
        uint256 _id
    ) public returns (address) {
        claimGovFees();
        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);
        IERC20(_tigAsset).transfer(msg.sender, _amount);
        return _tigAsset;
    }

    
    function claimDebt(
        address _tigAsset
    ) external {
        claimGovFees();
        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);
        IERC20(_tigAsset).transfer(msg.sender, amount);
    }

    
    function lock(
        address _asset,
        uint _amount,
        uint _period
    ) public {
        require(_period <= maxPeriod, ""MAX PERIOD"");
        require(_period >= minPeriod, ""MIN PERIOD"");
        require(allowedAssets[_asset], ""!asset"");

        claimGovFees();

        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        totalLocked[_asset] += _amount;
        
        bondNFT.createLock( _asset, _amount, _period, msg.sender);
    }

    
    function extendLock(
        uint _id,
        uint _amount,
        uint _period
    ) public {
        address _asset = claim(_id);
        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);
    }

    
    function release(
        uint _id
    ) public {
        claimGovFees();
        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);
        totalLocked[asset] -= lockAmount;
        IERC20(asset).transfer(_owner, amount);
    }

    
    function claimGovFees() public {
        address[] memory assets = bondNFT.getAssets();

        for (uint i=0; i < assets.length; i++) {
            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));
            IGovNFT(govNFT).claim(assets[i]);
            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));
            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);
            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);
        }
    }

    
    function editAsset(
        address _tigAsset,
        bool _isAllowed
    ) external onlyOwner() {
        allowedAssets[_tigAsset] = _isAllowed;
    }

    
    function sendNFTs(
        uint[] memory _ids
    ) external onlyOwner() {
        govNFT.safeTransferMany(msg.sender, _ids);
    }
}",790,1,2,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Analyze the `claimGovFees` function for potential reentrancy vulnerabilities, especially due to the external calls to `IGovNFT.claim` and `bondNFT.distribute`. Consider adding reentrancy guards."",
        ""Investigate the impact of integer overflows/underflows, especially when handling `_amount` and `_period` in `lock`, `extendLock`, and `release` functions. Although Solidity 0.8.0+ has built-in overflow protection, explicitly consider potential vulnerabilities in calculations involving these variables."",
        ""Examine the potential for front-running in the `lock` function, where an attacker could observe a transaction and manipulate the allowed assets before it is executed."",
        ""Assess the risk associated with granting infinite approval to `bondNFT` in `claimGovFees`. Explore alternative approval mechanisms with limited spending allowances and expiration times."",
        ""Verify that the `Ownable` contract is implemented correctly and that only the intended owner can call the `editAsset` and `sendNFTs` functions.""
      ]
    },
    {
      ""Area"": ""Compliance and Standards"",
      ""Tasks"": [
        ""Confirm that the ERC-20 token implementations being used (`IERC20`) are compliant with the ERC-20 standard, particularly regarding `transfer` and `transferFrom` functions."",
        ""Ensure that the `IBondNFT` and `IGovNFT` interfaces adhere to relevant NFT standards (e.g., ERC-721 or ERC-1155) if applicable. Though not explicitly ERC interfaces, review the functions used (such as safeTransferMany) for security concerns similar to ERC standards."",
        ""Verify that the `safeTransferMany` method in `IGovNFT` properly handles the array of `_ids` and prevents potential issues like out-of-bounds access or duplicated IDs.""
      ]
    },
    {
      ""Area"": ""Logic and Algorithms"",
      ""Tasks"": [
        ""Analyze the interaction between `claim`, `extendLock`, and `bondNFT.extendLock` to ensure the intended behavior when extending locks. Clarify the amount that `bondNFT.extendLock` expects (additional or total)."",
        ""Review the logic within the `release` function to ensure that the `amount` and `lockAmount` returned by `bondNFT.release` are correctly used to update `totalLocked` and transfer tokens to the owner."",
        ""Trace the flow of tokens in `claimGovFees` from `GovNFT` to the `Lock` contract to `BondNFT`, ensuring that the correct amounts are transferred and distributed."",
        ""Verify that the `totalLocked` mapping is updated correctly in all relevant functions (`lock`, `extendLock`, `release`) to reflect the actual amount of tokens locked in the contract.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Thoroughly audit the `IBondNFT` and `IGovNFT` contracts, paying close attention to the functions called by the `Lock` contract (`claim`, `claimDebt`, `createLock`, `extendLock`, `release`, `getAssets`, `distribute`, `safeTransferMany`)."",
        ""Assess the potential risks associated with relying on external contracts (BondNFT and GovNFT) and consider implementing fallback mechanisms in case of contract failure or malicious behavior."",
        ""Review the `IERC20` interactions (transfer, transferFrom, balanceOf, approve) to prevent issues like token incompatibility or unexpected behavior of non-standard ERC-20 tokens.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Confirm that the `onlyOwner` modifier is correctly applied to the `editAsset` and `sendNFTs` functions."",
        ""Ensure that there are no unintended access control vulnerabilities that could allow unauthorized users to modify the allowed assets or withdraw GovNFTs."",
        ""Verify that no sensitive functions lack proper access control, potentially enabling unauthorized actions."",
        ""Consider implementing more granular roles/permissions beyond just the owner for managing assets or performing administrative tasks.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the gas cost of the `claimGovFees` function, as it is called frequently. Consider optimizing the loop or caching frequently accessed data."",
        ""Review the data storage patterns in the `allowedAssets` and `totalLocked` mappings to minimize gas costs associated with storage operations."",
        ""Evaluate the use of immutable variables for `bondNFT` and `govNFT` for potential gas savings."",
        ""Consider using calldata instead of memory for input parameters where appropriate to reduce gas consumption.""
      ]
    },
    {
      ""Area"": ""Unintended Tokenomics"",
      ""Tasks"": [
          ""Carefully review the documentation of the BondNFT and GovNFT contracts to determine how they generate fees and rewards, especially in the context of claimGovFees and how the rewards are distributed.  Ensure that this Lock contract implements the tokenomics as intended by the protocol it integrates with."",
          ""Assess potential issues arising from manipulating lock periods close to minimum or maximum values, especially for tokenomics around vesting rewards.""
      ]
    },
        {
      ""Area"": ""Code Style and Best Practices"",
      ""Tasks"": [
        ""Remove `hardhat/console.sol` import before deployment to production."",
        ""Add NatSpec documentation to all functions and state variables to improve code readability and maintainability."",
        ""Consider using a more descriptive name for the `_tigAsset` variable in the `editAsset` function, such as `_assetAddress`."",
        ""Use consistent naming conventions throughout the contract.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `Lock` serves as an interface for users to interact with a bonding system represented by `IBondNFT` and a governance/fee mechanism represented by `IGovNFT`. It allows users to lock ERC20 assets for a specified period to likely receive rewards or benefits, manage these locks (extend, release), and claim associated earnings or debt. It also handles the claiming and distribution of fees generated through the `GovNFT` system. The contract includes administrative functions for managing allowed assets and retrieving potentially accumulated GovNFTs."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""Lock"",
    ""Purpose"": ""To facilitate locking of allowed ERC20 assets, manage interactions with BondNFT (creation, extension, release, claim), and handle fee claiming/distribution via GovNFT and BondNFT."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Ownable""
      ],
      ""Imports"": [
        ""hardhat/console.sol"",
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""./interfaces/IBondNFT.sol"",
        ""./interfaces/IGovNFT.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""minPeriod"",
        ""Type"": ""uint"",
        ""Purpose"": ""Constant defining the minimum lock duration (7 days).""
      },
      {
        ""Name"": ""maxPeriod"",
        ""Type"": ""uint"",
        ""Purpose"": ""Constant defining the maximum lock duration (365 days).""
      },
      {
        ""Name"": ""bondNFT"",
        ""Type"": ""IBondNFT"",
        ""Purpose"": ""Immutable reference to the external BondNFT contract.""
      },
      {
        ""Name"": ""govNFT"",
        ""Type"": ""IGovNFT"",
        ""Purpose"": ""Immutable reference to the external GovNFT contract.""
      },
      {
        ""Name"": ""allowedAssets"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks which ERC20 assets are permitted for locking.""
      },
      {
        ""Name"": ""totalLocked"",
        ""Type"": ""mapping(address => uint)"",
        ""Purpose"": ""Tracks the total amount of each asset currently held by this contract, presumably representing locked principal.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract by setting the addresses of the BondNFT and GovNFT contracts."",
        ""Parameters"": [
          ""address _bondNFTAddress"",
          ""address _govNFT""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""claim"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims rewards/yield from a specific bond NFT, transfers them to the caller, and triggers fee distribution."",
        ""Parameters"": [
          ""uint256 _id""
        ],
        ""Returns"": [
          ""address (_tigAsset)""
        ]
      },
      {
        ""Name"": ""claimDebt"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Claims debt associated with a specific asset for the caller via the BondNFT contract and triggers fee distribution."",
        ""Parameters"": [
          ""address _tigAsset""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""lock"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Locks a specified amount of an allowed asset for a given period by transferring the asset to this contract and creating a lock via the BondNFT contract. Triggers fee distribution."",
        ""Parameters"": [
          ""address _asset"",
          ""uint _amount"",
          ""uint _period""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""extendLock"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Extends an existing lock with an additional amount and period. Claims existing yield first, then requires a new transfer for the extension amount, and calls BondNFT to extend."",
        ""Parameters"": [
          ""uint _id"",
          ""uint _amount"",
          ""uint _period""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""release"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Releases a completed lock via the BondNFT contract, transfers the principal/amount back to the owner, updates total locked amount, and triggers fee distribution."",
        ""Parameters"": [
          ""uint _id""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""claimGovFees"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims fees from the GovNFT contract for all assets, approves the BondNFT contract to spend the claimed fees, and distributes them via the BondNFT contract."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""editAsset"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner-only function to allow or disallow an asset for locking."",
        ""Parameters"": [
          ""address _tigAsset"",
          ""bool _isAllowed""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""sendNFTs"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner-only function to transfer GovNFTs held by this contract to the owner."",
        ""Parameters"": [
          ""uint[] memory _ids""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""Ownable Modifiers"",
        ""Visibility"": ""internal/external"",
        ""Purpose"": ""Standard OpenZeppelin Ownable modifiers (onlyOwner) applied to administrative functions."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IBondNFT: Calls `claim`, `claimDebt`, `createLock`, `extendLock`, `release`, `getAssets`, `distribute` on the external BondNFT contract."",
    ""IGovNFT: Calls `claim` and `safeTransferMany` on the external GovNFT contract."",
    ""IERC20: Calls `transfer`, `transferFrom`, `balanceOf`, `approve` on various ERC20 token contracts specified as assets.""
  ],
  ""SpecialMechanisms"": [
    ""Facade Pattern: The contract acts as a user-facing facade, simplifying interactions with the more complex underlying BondNFT and GovNFT systems."",
    ""Fee Claiming and Distribution: Implements a specific workflow in `claimGovFees` to pull fees from `GovNFT` and push them into `BondNFT` for distribution."",
    ""Infinite Approval: The `claimGovFees` function grants `type(uint256).max` approval to the `bondNFT` contract for claimed assets repeatedly. This is a potential security risk if the `bondNFT` contract is compromised."",
    ""Ownership Control: Uses OpenZeppelin's `Ownable` for access control on administrative functions (`editAsset`, `sendNFTs`)."",
    ""State Tracking: Maintains `totalLocked` state, attempting to mirror the principal held within the contract corresponding to active locks.""
  ],
  ""Questions"": [
    ""The `extendLock` function calls `claim(_id)` first, which transfers claimed amounts to `msg.sender`. It then requires `msg.sender` to `transferFrom` a *new* `_amount` to the contract before calling `bondNFT.extendLock`. Is this intended? Does `bondNFT.extendLock` expect only the *additional* amount, or the *total* new lock amount?"",
    ""What are the exact return values and side effects of `IBondNFT.claim` and `IBondNFT.release`? Specifically, does `release` return principal in `amount` and the original locked amount in `lockAmount`? Is `_owner` always `msg.sender` or the original locker?"",
    ""What does `IGovNFT.claim(asset)` do? Does it transfer ERC20 tokens to this `Lock` contract?"",
    ""Why is infinite approval granted to `bondNFT` in `claimGovFees` on every call? Could this be done once or with more limited approvals to reduce risk?"",
    ""Is the `totalLocked` mapping purely informational, or is it used for critical logic elsewhere? Its accuracy depends on `bondNFT.release` returning the correct `lockAmount`."",
    ""Under what circumstances does this `Lock` contract receive GovNFTs that need to be retrieved via `sendNFTs`?"",
    ""The `claimGovFees` function is called at the beginning of `claim`, `claimDebt`, `lock`, and `release`. This could lead to high gas costs and frequent (potentially unnecessary) fee distributions. Is this the desired behavior?"",
    ""Should `hardhat/console.sol` be removed before deployment?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in claimGovFees and other functions"",
      ""Severity"": ""High"",
      ""Description"": ""The `claimGovFees` function iterates through a list of assets and calls `IGovNFT(govNFT).claim(assets[i])`, which can potentially re-enter the `Lock` contract if the `GovNFT` contract has a malicious implementation or contains a vulnerability.  Additionally, functions like `claim`, `claimDebt`, `lock`, `extendLock`, and `release` lack reentrancy protection when interacting with external contracts. A malicious `GovNFT` or other contract could call back into the `Lock` contract before state updates are finalized, potentially leading to inconsistent state, fund theft, or denial of service. Reentrancy can also occur when extending a lock, since the function `extendLock` calls `claim(_id)` which in turn calls `claimGovFees`."",
      ""Impact"": ""Allows attacker to potentially drain funds from the contract by repeatedly claiming fees within the same transaction before the intended accounting or distribution has occurred. May lead to other unexpected state inconsistencies, fund theft, and denial of service."",
      ""Location"": ""`Lock.claimGovFees`, `Lock.claim`, `Lock.claimDebt`, `Lock.lock`, `Lock.extendLock`, `Lock.release` functions, specifically the call to `IGovNFT(govNFT).claim(assets[i])` and the subsequent `bondNFT.distribute` call.""
    },
    {
      ""Issue"": ""Uncontrolled Approval in claimGovFees"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `claimGovFees` function, the contract approves `bondNFT` to spend tokens without checking if `bondNFT` is a trusted contract, using `IERC20(assets[i]).approve(address(bondNFT), type(uint256).max)`. This gives `bondNFT` unlimited spending rights over the `Lock` contract\'s tokens and persists even after fees are distributed. If `bondNFT` is compromised, it could drain all approved tokens from the Lock contract, even future deposits."",
      ""Impact"": ""If `bondNFT` is malicious or compromised, it can steal all tokens held by the `Lock` contract or lead to potential fund loss if `bondNFT.distribute` transfers a very large amount."",
      ""Location"": ""claimGovFees function""
    },
    {
      ""Issue"": ""Missing Access Control on `claimGovFees` and `claimDebt`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `claimGovFees` function is currently `public`, meaning anyone can call it. This function distributes governance fees, and allowing anyone to trigger it could disrupt the intended fee distribution mechanism or lead to denial-of-service. The `claimDebt` function also lacks access control, potentially allowing unauthorized users to claim debt on behalf of others and trigger computationally expensive operations."",
      ""Impact"": ""Unexpected behavior in `claimGovFees` that might lead to token distribution issues and potential fund loss. Potential griefing attack due to lack of access control on `claimDebt`, possibly leading to excessive gas consumption and unauthorized debt claims."",
      ""Location"": ""`Lock.claimGovFees` function, `Lock.claimDebt` function.""
    },
    {
      ""Issue"": ""Unchecked TransferFrom Amount and Transfer Return Values"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `extendLock` function claims the token using `claim(_id)` and then attempts to transfer an additional `_amount` using `transferFrom`. If the user's allowance is less than `_amount`, the `transferFrom` call will revert, but the previously claimed amount is already gone, leading to a loss of funds for the user. Additionally, the code uses `IERC20(_asset).transferFrom` and `IERC20(_tigAsset).transfer` without checking the return value. If the transfer fails, the transaction will not revert in some ERC20 implementations, leading to unexpected behavior and potential inconsistencies in the contract's state."",
      ""Impact"": ""Loss of user funds if the `transferFrom` call fails due to insufficient allowance, as the `claim` operation has already transferred tokens. Incorrect accounting of locked tokens and potential loss of funds."",
      ""Location"": ""extendLock function, lock function, claim function, claimDebt function, release function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `claimGovFees`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `claimGovFees` calculates the amount to distribute using `balanceAfter - balanceBefore`. If `balanceAfter` is less than `balanceBefore` due to unexpected token transfers, this could result in an underflow, wrapping around to a very large number and potentially causing unintended behavior in the `bondNFT.distribute` function."",
      ""Impact"": ""Incorrect distribution of governance fees and potential unexpected behavior within the `bondNFT.distribute` function."",
      ""Location"": ""claimGovFees function""
    },
     {
      ""Issue"": ""Missing Input Validation for NFT Contract Addresses and Amount in `extendLock`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The constructor does not validate that `_bondNFTAddress` and `_govNFT` are not the zero address.  The `extendLock` function does not validate `_amount` against reasonable limits (e.g., _amount being zero)."",
      ""Impact"": ""Contract malfunction or denial of service. Potential for unintended behavior and logic errors in BondNFT contract."",
      ""Location"": ""Constructor, extendLock function""
    },
    {
      ""Issue"": ""Release Amount Mismatch"",
      ""Severity"": ""High"",
      ""Description"": ""In the `release` function, the code retrieves `amount` and `lockAmount` from `bondNFT.release`. It then subtracts `lockAmount` from `totalLocked` but transfers `amount` to the owner. If `amount` and `lockAmount` differ, the state of `totalLocked` might become inconsistent with the actual tokens held by the contract, leading to accounting errors and potential loss of funds."",
      ""Impact"": ""Inconsistent state of `totalLocked` potentially causing loss of funds due to accounting errors."",
      ""Location"": ""release function""
    },
    {
      ""Issue"": ""Unbounded Loop in claimGovFees may lead to DOS"",
      ""Severity"": ""Low"",
      ""Description"": ""The `claimGovFees` function iterates through `bondNFT.getAssets()`. If the length of the returned array becomes very large, the execution of this loop could exceed the block gas limit, effectively causing a denial-of-service. Also, approving `bondNFT` with `type(uint256).max` in each iteration of loop may introduce DOS if the number of `assets` is large."",
      ""Impact"": ""Denial-of-service if the loop in `claimGovFees` exceeds the block gas limit."",
      ""Location"": ""claimGovFees function""
    },
    {
      ""Issue"": ""Potential Rounding Errors During Fee Distribution"",
      ""Severity"": ""Low"",
      ""Description"": ""The `claimGovFees` function calculates the difference between the balance before and after claiming fees. Rounding errors in the `govNFT.claim()` or IERC20 balance calculations can potentially lead to inaccuracies in the amount distributed to bondNFT."",
      ""Impact"": ""Minor inaccuracies in fee distribution."",
      ""Location"": ""claimGovFees function""
    },
    {
      ""Issue"": ""Approval Race Condition in `claimGovFees` function."",
      ""Severity"": ""Low"",
      ""Description"": ""The `claimGovFees` function approves the `bondNFT` contract to spend tokens using `IERC20(assets[i]).approve(address(bondNFT), type(uint256).max)`. If another contract or user approves a different amount for the same token and the same spender (bondNFT) between the time `claimGovFees` is called and the `bondNFT.distribute` function is executed, the `bondNFT` contract might not have the correct approval amount."",
      ""Impact"": ""Potential failure to distribute governance fees."",
      ""Location"": ""claimGovFees function""
    },
    {
      ""Issue"": ""Missing event emission after critical state changes."",
      ""Severity"": ""Low"",
      ""Description"": ""The contract lacks event emission when critical state changes are performed. For example, it would be useful to emit an event when the asset is edited via the `editAsset` function, or when the `sendNFTs` function is called. These events are essential for off-chain monitoring and analysis."",
      ""Impact"": ""Difficult to track and monitor the contract state changes."",
      ""Location"": ""Lock.sol:91, Lock.sol:98""
    },
    {
      ""Issue"": ""Lack of slippage control in `claim` and `claimDebt`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `claim` and `claimDebt` functions transfers the full amount of tokens claimed to `msg.sender`. If the transferred token price is affected by the transaction, then the function should include slippage control to protect `msg.sender` from the adverse effect caused by unexpected price changes."",
      ""Impact"": ""The `msg.sender` might receive less of what they should."",
      ""Location"": ""Lock.sol:23, Lock.sol:32""
    },
      {
      ""Issue"": ""Inconsistent use of `_owner` variable after the call to `bondNFT.release`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `release` function retrieves the parameters of the lock by calling `bondNFT.release`. After the call, the address of the original lock owner is available in the `_owner` variable. There is no check performed to guarantee that `msg.sender` is indeed the owner of the lock before releasing it, leaving space for potential malicious or unintended behaviors."",
      ""Impact"": ""Anyone can release any lock."",
      ""Location"": ""Lock.sol:61""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `lock` function."",
      ""Severity"": ""Low"",
      ""Description"": ""An attacker could monitor the mempool for `lock` transactions and front-run the transaction by calling the same function with a slightly higher gas price. This could cause the attacker's transaction to be executed first, potentially taking advantage of any favorable conditions before the original user's transaction is executed."",
      ""Impact"": ""The attacker can steal opportunities from users who try to lock assets in `lock` function."",
      ""Location"": ""`Lock.lock` function""
    },
    {
      ""Issue"": ""Lack of slippage protection in `claimGovFees` function."",
      ""Severity"": ""Low"",
      ""Description"": ""The `claimGovFees` function assumes that the amount claimed from the GovNFT will always be sufficient to cover the fees to be distributed. If the GovNFT implementation has any dynamic fee structures, or if external factors influence the claim amount, there is no guarantee that `balanceAfter - balanceBefore` will be positive or large enough. This could lead to the contract being unable to fulfill its intended function."",
      ""Impact"": ""Possible issues if the GovNFT implementation changes or if external factors influence claimed amount."",
      ""Location"": ""claimGovFees function""
    },
     {
      ""Issue"": ""Missing Input Validation on `sendNFTs`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `sendNFTs` function takes an array of NFT IDs as input. There's no check to verify that the NFT IDs are valid or that the contract owns the NFTs before transferring them."",
      ""Impact"": ""Potential for transferring invalid NFTs or NFTs not owned by the contract, which could lead to unexpected behavior or errors in the `govNFT` contract."",
      ""Location"": ""Lock.sol:97""
    }
  ],
  ""IssueNumber"": 33,
  ""OutputList"": 16
}",226.738883733749,3788.0,33.0,"### **[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost**

**Report Description**:  
The `extendLock` function in `Lock.sol` allows users to extend the lock period or increase the locked amount. However, it fails to update the `totalLocked[_asset]` variable, which tracks the total locked assets. When the `release` function is called, it reduces `totalLocked[_asset]` based on the initial locked amount, not the extended amount. This discrepancy can cause an underflow when releasing assets, leading to a revert. As a result, assets deposited via `extendLock` cannot be released, effectively locking them permanently.

**Match in Response List**:  
Matches with the issue titled **""Release Amount Mismatch""**.

**Validation**:  
**Partially Correct**. The response identifies a mismatch between `amount` and `lockAmount` in the `release` function, which could lead to inconsistent accounting. However, it does not explicitly address the failure to update `totalLocked[_asset]` in the `extendLock` function, which is the root cause of the issue. The response partially covers the problem but misses critical details.

---

### **[M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract**

**Report Description**:  
The `claimGovFees` function calls `bondNFT.distribute` to distribute assets. However, if the assets are not allowed or have no shares in the `BondNFT` contract, the `distribute` call will silently fail. This can result in assets being stuck in the `Lock` contract, as the function does not handle such failures or revert the transaction.

**Match in Response List**:  
Matches with the issue titled **""Unbounded Loop in claimGovFees may lead to DOS""**.

**Validation**:  
**Incorrect**. The response focuses on the potential denial-of-service (DOS) risk due to an unbounded loop in `claimGovFees`. It does not address the silent failure of `bondNFT.distribute` or the issue of assets being stuck in the contract. The core issue is misidentified.

---

### **[M-02] Must approve 0 first**

**Report Description**:  
Some tokens (e.g., USDT) require setting the allowance to zero before approving a new non-zero value. The `claimGovFees` function does not follow this practice, which could cause the approval to fail for certain tokens. This oversight could prevent the function from working as intended with such tokens.

**Match in Response List**:  
Matches with the issue titled **""Approval Race Condition in `claimGovFees` function.""**.

**Validation**:  
**Incorrect**. The response discusses a race condition in the approval mechanism but does not address the specific requirement of approving zero first for certain tokens. The core issue is misidentified.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost**

**Missed Issues from Issue Report**:  
- **[M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract**  
- **[M-02] Must approve 0 first**

---

### **Overall Analysis**  
The `response_list` partially addresses one issue ([H-01]) but misidentifies or misses the other two issues ([M-01] and [M-02]). The responses focus on broader vulnerabilities (e.g., reentrancy, DOS, race conditions) but fail to address the specific problems described in the `issue` report. Improvements are needed to ensure accurate and sufficient coverage of the reported issues.","```
None.
```",0.0
BondNFT.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract BondNFT is ERC721Enumerable, Ownable {
    
    uint constant private DAY = 24 * 60 * 60;

    struct Bond {
        uint id;
        address owner;
        address asset;
        uint amount;
        uint mintEpoch;
        uint mintTime;
        uint expireEpoch;
        uint pending;
        uint shares;
        uint period;
        bool expired;
    }

    mapping(address => uint256) public epoch;
    uint private totalBonds;
    string public baseURI;
    address public manager;
    address[] public assets;

    mapping(address => bool) public allowedAsset;
    mapping(address => uint) private assetsIndex;
    mapping(uint256 => mapping(address => uint256)) private bondPaid;
    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare
    mapping(uint => Bond) private _idToBond;
    mapping(address => uint) public totalShares;
    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount

    constructor(
        string memory _setBaseURI,
        string memory _name,
        string memory _symbol
    ) ERC721(_name, _symbol) {
        baseURI = _setBaseURI;
    }

    /**
     * @notice Create a bond
     * @dev Should only be called by a manager contract
     * @param _asset tigAsset token to lock
     * @param _amount tigAsset amount
     * @param _period time to lock for in days
     * @param _owner address to receive the bond
     * @return id ID of the minted bond
     */
    function createLock(
        address _asset,
        uint _amount,
        uint _period,
        address _owner
    ) external onlyManager() returns(uint id) {
        require(allowedAsset[_asset], ""!Asset"");
        unchecked {
            uint shares = _amount * _period / 365;
            uint expireEpoch = epoch[_asset] + _period;
            id = ++totalBonds;
            totalShares[_asset] += shares;
            Bond memory _bond = Bond(
                id,             // id
                address(0),     // owner
                _asset,         // tigAsset token
                _amount,        // tigAsset amount
                epoch[_asset],  // mint epoch
                block.timestamp,// mint timestamp
                expireEpoch,    // expire epoch
                0,              // pending
                shares,         // linearly scaling share of rewards
                _period,        // lock period
                false           // is expired boolean
            );
            _idToBond[id] = _bond;
            _mint(_owner, _bond);
        }
        emit Lock(_asset, _amount, _period, _owner, id);
    }

    /** 
     * @notice Extend the lock period and/or amount of a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond
     * @param _asset tigAsset token address
     * @param _amount amount of tigAsset being added
     * @param _period days being added to the bond
     * @param _sender address extending the bond
     */
    function extendLock(
        uint _id,
        address _asset,
        uint _amount,
        uint _period,
        address _sender
    ) external onlyManager() {
        Bond memory bond = idToBond(_id);
        Bond storage _bond = _idToBond[_id];
        require(bond.owner == _sender, ""!owner"");
        require(!bond.expired, ""Expired"");
        require(bond.asset == _asset, ""!BondAsset"");
        require(bond.pending == 0);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(bond.period+_period <= 365, ""MAX PERIOD"");
        unchecked {
            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;
            uint expireEpoch = block.timestamp/DAY + bond.period + _period;
            totalShares[bond.asset] += shares-bond.shares;
            _bond.shares = shares;
            _bond.amount += _amount;
            _bond.expireEpoch = expireEpoch;
            _bond.period += _period;
            _bond.mintTime = block.timestamp;
            _bond.mintEpoch = epoch[bond.asset];
            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;
        }
        emit ExtendLock(_period, _amount, _sender,  _id);
    }

    /**
     * @notice Release a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond
     * @param _releaser address initiating the release of the bond
     * @return amount amount of tigAsset returned
     * @return lockAmount amount of tigAsset locked in the bond
     * @return asset tigAsset token released
     * @return _owner bond owner
     */
    function release(
        uint _id,
        address _releaser
    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {
        Bond memory bond = idToBond(_id);
        require(bond.expired, ""!expire"");
        if (_releaser != bond.owner) {
            unchecked {
                require(bond.expireEpoch + 7 < epoch[bond.asset], ""Bond owner priority"");
            }
        }
        amount = bond.amount;
        unchecked {
            totalShares[bond.asset] -= bond.shares;
            (uint256 _claimAmount,) = claim(_id, bond.owner);
            amount += _claimAmount;
        }
        asset = bond.asset;
        lockAmount = bond.amount;
        _owner = bond.owner;
        _burn(_id);
        emit Release(asset, lockAmount, _owner, _id);
    }
    /**
     * @notice Claim rewards from a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond to claim rewards from
     * @param _claimer address claiming rewards
     * @return amount amount of tigAsset claimed
     * @return tigAsset tigAsset token address
     */
    function claim(
        uint _id,
        address _claimer
    ) public onlyManager() returns(uint amount, address tigAsset) {
        Bond memory bond = idToBond(_id);
        require(_claimer == bond.owner, ""!owner"");
        amount = bond.pending;
        tigAsset = bond.asset;
        unchecked {
            if (bond.expired) {
                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);
                if (totalShares[bond.asset] > 0) {
                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];
                }
            }
            bondPaid[_id][bond.asset] += amount;
        }
        IERC20(tigAsset).transfer(manager, amount);
        emit ClaimFees(tigAsset, amount, _claimer, _id);
    }

    /**
     * @notice Claim user debt left from bond transfer
     * @dev Should only be called by a manager contract
     * @param _user user address
     * @param _tigAsset tigAsset token address
     * @return amount amount of tigAsset claimed
     */
    function claimDebt(
        address _user,
        address _tigAsset
    ) public onlyManager() returns(uint amount) {
        amount = userDebt[_user][_tigAsset];
        userDebt[_user][_tigAsset] = 0;
        IERC20(_tigAsset).transfer(manager, amount);
        emit ClaimDebt(_tigAsset, amount, _user);
    }

    /**
     * @notice Distribute rewards to bonds
     * @param _tigAsset tigAsset token address
     * @param _amount tigAsset amount
     */
    function distribute(
        address _tigAsset,
        uint _amount
    ) external {
        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;
        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);
        unchecked {
            uint aEpoch = block.timestamp / DAY;
            if (aEpoch > epoch[_tigAsset]) {
                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {
                    epoch[_tigAsset] += 1;
                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];
                }
            }
            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];
        }
        emit Distribution(_tigAsset, _amount);
    }

    /**
     * @notice Get all data for a bond
     * @param _id ID of the bond
     * @return bond Bond object
     */
    function idToBond(uint256 _id) public view returns (Bond memory bond) {
        bond = _idToBond[_id];
        bond.owner = ownerOf(_id);
        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;
        unchecked {
            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];
            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];
        }
    }

    /*
     * @notice Get expired boolean for a bond
     * @param _id ID of the bond
     * @return bool true if bond is expired
     */
    function isExpired(uint256 _id) public view returns (bool) {
        Bond memory bond = _idToBond[_id];
        return bond.expireEpoch <= epoch[bond.asset] ? true : false;
    }

    /*
     * @notice Get pending rewards for a bond
     * @param _id ID of the bond
     * @return bool true if bond is expired
     */
    function pending(
        uint256 _id
    ) public view returns (uint256) {
        return idToBond(_id).pending;
    }

    function totalAssets() public view returns (uint256) {
        return assets.length;
    }

    /*
     * @notice Gets an array of all whitelisted token addresses
     * @return address array of addresses
     */
    function getAssets() public view returns (address[] memory) {
        return assets;
    }

    function _baseURI() internal override view returns (string memory) {
        return baseURI;
    }

    function safeTransferMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _transfer(_msgSender(), _to, _ids[i]);
            }
        }
    }

    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                safeTransferFrom(_from, _to, _ids[i]);
            }
        }
    }

    function approveMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                approve(_to, _ids[i]);
            }
        }
    }

    function _mint(
        address to,
        Bond memory bond
    ) internal {
        unchecked {
            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;
        }
        _mint(to, bond.id);
    }

    function _burn(
        uint256 _id
    ) internal override {
        delete _idToBond[_id];
        super._burn(_id);
    }

    function _transfer(
        address from,
        address to,
        uint256 _id
    ) internal override {
        Bond memory bond = idToBond(_id);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(!bond.expired, ""Expired!"");
        unchecked {
            require(block.timestamp > bond.mintTime + 300, ""Recent update"");
            userDebt[from][bond.asset] += bond.pending;
            bondPaid[_id][bond.asset] += bond.pending;
        }
        super._transfer(from, to, _id);
    }

    function balanceIds(address _user) public view returns (uint[] memory) {
        uint[] memory _ids = new uint[](balanceOf(_user));
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _ids[i] = tokenOfOwnerByIndex(_user, i);
            }
        }
        return _ids;
    }

    function addAsset(address _asset) external onlyOwner {
        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, ""Already added"");
        assetsIndex[_asset] = assets.length;
        assets.push(_asset);
        allowedAsset[_asset] = true;
        epoch[_asset] = block.timestamp/DAY;
    }

    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {
        require(assets[assetsIndex[_asset]] == _asset, ""Not added"");
        allowedAsset[_asset] = _bool;
    }

    function setBaseURI(string calldata _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
    }

    function setManager(
        address _manager
    ) public onlyOwner() {
        manager = _manager;
    }

    modifier onlyManager() {
        require(msg.sender == manager, ""!manager"");
        _;
    }

    event Distribution(address _tigAsset, uint256 _amount);
    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);
    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);
    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);
    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);
    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);
}",3270,384,"[H-05] Malicious user can steal all assets in BondNFT
Malicious user can drain all assets in BondNFT, and other users will lose their rewards.
When calling `claim()` for an expired bond, it will recalculate `accRewardsPerShare`. This is because the reward after the `expireEpoch` does not belong to that expired bond and needs to be redistributed to all other bonds.
  [M-06] BondNFTs can revert when transferred
In the function `_transfer`, `BondNFTs` should be transferrable. According the the proposal and the sponsor, BondNFTs should could be sold and borrowed against.
  [M-14] BondNFT.sol#claim() needs to correct all the missing epochs
In `claim()`, `accRewardsPerShare[][]` is amended to reflect the expired shares. But only `accRewardsPerShare[bond.asset][epoch[bond.asset]]` is updated. All the epochs between `bond.expireEpoch-1` and `epoch[bond.asset]` are missed.
 
[M-16] distribute() won't update epoch[tigAsset] when totalShares[tigAsset]==0 which can cause later created bond for this tigAsset to have wrong mint epoch
Function `BondNFT.createLock()` creates a bond and it sets bond's mint epoch as `epoch[asset]`. Function Lock.lock() first calls `claimGovFees()` which calls `BondNFT.distribute()` for all assets and updates the `epoch[assets]` for all assets. So during normal bond creation, the value of `epoch[asset]` would be updated and bond would be created from `today` epoch to `today+period` epoch. But if `totalShares[tigAsset] == 0` for an asset, then `distribute()` won't update `epoch[asset]` for that asset and epoch[asset] will be some old epoch(will be the start time where asset is added or the time where `totalShares[_tigAsset] != 0`). This would make `createLock()` set very wrong values for bond's mint epoch when `totalShares[tigAsset] == 0`.
  [M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT
After a lock has expired, it doesn't get any rewards distributed to it. But, unreleased locks cause other existing bonds to not receive the full amount of tokens either. The issue is that as long as the bond is not released, the `totalShares` value isn't updated. Everybody receives a smaller cut of the distribution. Thus, bond owners receive less rewards than they should.   [M-23] Governance NFT holder, whose NFT was minted before `Trading._handleOpenFees` function is called, can lose deserved rewards after `Trading._handleOpenFees` function is called
Calling the following `Trading._handleOpenFees` function does not approve the GovNFT contract for spending any of the Trading contract's `_tigAsset` balance, which is unlike calling the `Trading._handleCloseFees` function below that executes `IStable(_tigAsset).approve(address(gov), type(uint).max)`.",6,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract BondNFT is ERC721Enumerable, Ownable {
    
    uint constant private DAY = 24 * 60 * 60;

    struct Bond {
        uint id;
        address owner;
        address asset;
        uint amount;
        uint mintEpoch;
        uint mintTime;
        uint expireEpoch;
        uint pending;
        uint shares;
        uint period;
        bool expired;
    }

    mapping(address => uint256) public epoch;
    uint private totalBonds;
    string public baseURI;
    address public manager;
    address[] public assets;

    mapping(address => bool) public allowedAsset;
    mapping(address => uint) private assetsIndex;
    mapping(uint256 => mapping(address => uint256)) private bondPaid;
    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; 
    mapping(uint => Bond) private _idToBond;
    mapping(address => uint) public totalShares;
    mapping(address => mapping(address => uint)) public userDebt; 

    constructor(
        string memory _setBaseURI,
        string memory _name,
        string memory _symbol
    ) ERC721(_name, _symbol) {
        baseURI = _setBaseURI;
    }

    
    function createLock(
        address _asset,
        uint _amount,
        uint _period,
        address _owner
    ) external onlyManager() returns(uint id) {
        require(allowedAsset[_asset], ""!Asset"");
        unchecked {
            uint shares = _amount * _period / 365;
            uint expireEpoch = epoch[_asset] + _period;
            id = ++totalBonds;
            totalShares[_asset] += shares;
            Bond memory _bond = Bond(
                id,             
                address(0),     
                _asset,         
                _amount,        
                epoch[_asset],  
                block.timestamp,
                expireEpoch,    
                0,              
                shares,         
                _period,        
                false           
            );
            _idToBond[id] = _bond;
            _mint(_owner, _bond);
        }
        emit Lock(_asset, _amount, _period, _owner, id);
    }

    
    function extendLock(
        uint _id,
        address _asset,
        uint _amount,
        uint _period,
        address _sender
    ) external onlyManager() {
        Bond memory bond = idToBond(_id);
        Bond storage _bond = _idToBond[_id];
        require(bond.owner == _sender, ""!owner"");
        require(!bond.expired, ""Expired"");
        require(bond.asset == _asset, ""!BondAsset"");
        require(bond.pending == 0);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(bond.period+_period <= 365, ""MAX PERIOD"");
        unchecked {
            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;
            uint expireEpoch = block.timestamp/DAY + bond.period + _period;
            totalShares[bond.asset] += shares-bond.shares;
            _bond.shares = shares;
            _bond.amount += _amount;
            _bond.expireEpoch = expireEpoch;
            _bond.period += _period;
            _bond.mintTime = block.timestamp;
            _bond.mintEpoch = epoch[bond.asset];
            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;
        }
        emit ExtendLock(_period, _amount, _sender,  _id);
    }

    
    function release(
        uint _id,
        address _releaser
    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {
        Bond memory bond = idToBond(_id);
        require(bond.expired, ""!expire"");
        if (_releaser != bond.owner) {
            unchecked {
                require(bond.expireEpoch + 7 < epoch[bond.asset], ""Bond owner priority"");
            }
        }
        amount = bond.amount;
        unchecked {
            totalShares[bond.asset] -= bond.shares;
            (uint256 _claimAmount,) = claim(_id, bond.owner);
            amount += _claimAmount;
        }
        asset = bond.asset;
        lockAmount = bond.amount;
        _owner = bond.owner;
        _burn(_id);
        emit Release(asset, lockAmount, _owner, _id);
    }
    
    function claim(
        uint _id,
        address _claimer
    ) public onlyManager() returns(uint amount, address tigAsset) {
        Bond memory bond = idToBond(_id);
        require(_claimer == bond.owner, ""!owner"");
        amount = bond.pending;
        tigAsset = bond.asset;
        unchecked {
            if (bond.expired) {
                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);
                if (totalShares[bond.asset] > 0) {
                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];
                }
            }
            bondPaid[_id][bond.asset] += amount;
        }
        IERC20(tigAsset).transfer(manager, amount);
        emit ClaimFees(tigAsset, amount, _claimer, _id);
    }

    
    function claimDebt(
        address _user,
        address _tigAsset
    ) public onlyManager() returns(uint amount) {
        amount = userDebt[_user][_tigAsset];
        userDebt[_user][_tigAsset] = 0;
        IERC20(_tigAsset).transfer(manager, amount);
        emit ClaimDebt(_tigAsset, amount, _user);
    }

    
    function distribute(
        address _tigAsset,
        uint _amount
    ) external {
        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;
        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);
        unchecked {
            uint aEpoch = block.timestamp / DAY;
            if (aEpoch > epoch[_tigAsset]) {
                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {
                    epoch[_tigAsset] += 1;
                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];
                }
            }
            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];
        }
        emit Distribution(_tigAsset, _amount);
    }

    
    function idToBond(uint256 _id) public view returns (Bond memory bond) {
        bond = _idToBond[_id];
        bond.owner = ownerOf(_id);
        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;
        unchecked {
            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];
            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];
        }
    }

    
    function isExpired(uint256 _id) public view returns (bool) {
        Bond memory bond = _idToBond[_id];
        return bond.expireEpoch <= epoch[bond.asset] ? true : false;
    }

    
    function pending(
        uint256 _id
    ) public view returns (uint256) {
        return idToBond(_id).pending;
    }

    function totalAssets() public view returns (uint256) {
        return assets.length;
    }

    
    function getAssets() public view returns (address[] memory) {
        return assets;
    }

    function _baseURI() internal override view returns (string memory) {
        return baseURI;
    }

    function safeTransferMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _transfer(_msgSender(), _to, _ids[i]);
            }
        }
    }

    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                safeTransferFrom(_from, _to, _ids[i]);
            }
        }
    }

    function approveMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                approve(_to, _ids[i]);
            }
        }
    }

    function _mint(
        address to,
        Bond memory bond
    ) internal {
        unchecked {
            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;
        }
        _mint(to, bond.id);
    }

    function _burn(
        uint256 _id
    ) internal override {
        delete _idToBond[_id];
        super._burn(_id);
    }

    function _transfer(
        address from,
        address to,
        uint256 _id
    ) internal override {
        Bond memory bond = idToBond(_id);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(!bond.expired, ""Expired!"");
        unchecked {
            require(block.timestamp > bond.mintTime + 300, ""Recent update"");
            userDebt[from][bond.asset] += bond.pending;
            bondPaid[_id][bond.asset] += bond.pending;
        }
        super._transfer(from, to, _id);
    }

    function balanceIds(address _user) public view returns (uint[] memory) {
        uint[] memory _ids = new uint[](balanceOf(_user));
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _ids[i] = tokenOfOwnerByIndex(_user, i);
            }
        }
        return _ids;
    }

    function addAsset(address _asset) external onlyOwner {
        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, ""Already added"");
        assetsIndex[_asset] = assets.length;
        assets.push(_asset);
        allowedAsset[_asset] = true;
        epoch[_asset] = block.timestamp/DAY;
    }

    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {
        require(assets[assetsIndex[_asset]] == _asset, ""Not added"");
        allowedAsset[_asset] = _bool;
    }

    function setBaseURI(string calldata _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
    }

    function setManager(
        address _manager
    ) public onlyOwner() {
        manager = _manager;
    }

    modifier onlyManager() {
        require(msg.sender == manager, ""!manager"");
        _;
    }

    event Distribution(address _tigAsset, uint256 _amount);
    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);
    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);
    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);
    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);
    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);
}",2608,1,5,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control and Manager Role"",
      ""Tasks"": [
        ""Verify that only the `owner` can set the `manager` address."",
        ""Confirm that all functions intended to be restricted to the `manager` are correctly protected by the `onlyManager` modifier."",
        ""Analyze the trust assumptions associated with the `manager` role. Document the potential impact if the `manager` is compromised."",
        ""Investigate the rationale behind requiring the `manager` to handle user-initiated actions like `createLock`, `extendLock`, `claim`, and `release`. Evaluate whether this centralization is necessary and if alternative designs could enhance decentralization and user autonomy."",
        ""Explore potential attack vectors where a malicious `manager` could exploit their privileges to the detriment of bondholders."",
        ""Review the events emitted by functions to confirm actions can be tracked and verified.""
      ]
    },
    {
      ""Area"": ""Reward Distribution and Accounting"",
      ""Tasks"": [
        ""Thoroughly review the `distribute` function to assess whether it should be restricted to a specific role (e.g., `owner` or `manager`) to prevent unauthorized reward distribution."",
        ""Examine the logic within the `claim` function to fully understand the calculation of `_pendingDelta` and its impact on `accRewardsPerShare`, especially in the case of expired bonds."",
        ""Simulate various scenarios in `claim` (expired vs. non-expired bonds) with different distribution amounts and total shares to determine if calculations work."",
        ""Analyze the accounting of `bondPaid` in relation to calculating claimable amounts. Confirm correctness in all circumstances."",
        ""Investigate the potential for rounding errors in the share calculation and reward distribution logic and assess their impact on fairness."",
        ""Verify that reward distribution is proportional to the lock amount and duration (shares)."",
        ""Review `userDebt` implementation during transfers. Check potential rounding errors, logic errors in calculating and transferring owed amounts, especially during multiple transfers."",
        ""Simulate edge cases for reward calculation when totalShares is zero."",
        ""Assess potential for front-running the `distribute` function to manipulate reward distribution.""
      ]
    },
    {
      ""Area"": ""Bond Expiry and Release Mechanism"",
      ""Tasks"": [
        ""Analyze the 7-day grace period in the `release` function. Evaluate its purpose and potential implications for bondholders."",
        ""Confirm that the `isExpired` function accurately determines bond expiry based on the current epoch."",
        ""Simulate scenarios where a bond expires and the owner tries to release versus when the manager releases after the grace period. Verify amounts are calculated properly."",
        ""Verify if the release function correctly reverts if called before expiry."",
        ""Confirm that `_burn` is called only after all asset transfers have been successfully completed in `release`.""
      ]
    },
    {
      ""Area"": ""Transfer Hook and Reward Accounting During Transfers"",
      ""Tasks"": [
        ""Scrutinize the `_transfer` function's reward accounting logic, ensuring that pending rewards are correctly calculated and assigned as debt to the sender (`userDebt`)."",
        ""Verify `require(epoch[bond.asset] == block.timestamp/DAY, \""Bad epoch\"")` to ensure proper accounting and prevent transferring bonds with incorrect timestamps."",
        ""Analyze the `require(block.timestamp > bond.mintTime + 300, \""Recent update\"")` to prevent transferring too quickly after minting, potentially preventing accounting exploits."",
        ""Simulate multiple transfers of the same bond and assess its cumulative effect on `userDebt` and `bondPaid`."",
        ""Check for potential DoS vulnerabilities if many transfers occur within a small period."",
        ""Check underflow/overflow in `userDebt` calculations.""
      ]
    },
    {
      ""Area"": ""Potential Arithmetic Overflow/Underflow"",
      ""Tasks"": [
        ""Although `unchecked` blocks are used, carefully analyze all arithmetic operations, particularly those involving `shares`, `epoch`, `amount`, and `period`, to identify potential overflow or underflow vulnerabilities. Consider the maximum possible values for these variables."",
        ""Review the gas cost associated with unchecked arithmetic to determine whether it offers a significant gas saving."",
        ""Evaluate potential impacts if `totalShares` becomes excessively large.""
      ]
    },
    {
      ""Area"": ""Epoch Handling and Time Sensitivity"",
      ""Tasks"": [
        ""Assess the risks associated with relying on `block.timestamp` for epoch calculations, particularly the potential for time manipulation by miners."",
        ""Investigate the impact of infrequent calls to `distribute` on the accuracy of reward distribution and the functionality of the `extendLock` and `_transfer` functions (due to `Bad epoch` requirements)."",
        ""Clarify what happens if the epoch is not updated regularly, especially concerning reward distribution.""
      ]
    },
    {
      ""Area"": ""ERC721 Compliance and Security"",
      ""Tasks"": [
        ""Verify adherence to the ERC721 standard, focusing on transfer restrictions, metadata handling, and ownership."",
        ""Check for any reentrancy vulnerabilities related to ERC721 functions."",
        ""Ensure safe minting and burning of NFTs. Check that the `_mint` and `_burn` functions operate as intended, especially concerning NFT ownership and metadata consistency."",
        ""Investigate gas costs when calling `safeTransferMany`, `safeTransferFromMany`, and `approveMany` functions. Can these functions be targets of a DoS attack? Is there any limitations to the length of the array?""
      ]
    },
     {
      ""Area"": ""Asset Handling and Configuration"",
      ""Tasks"": [
        ""Ensure that only the contract owner can add or remove allowed assets."",
        ""Validate that the `addAsset` function prevents duplicate assets from being added."",
        ""Verify that the `setAllowedAsset` function correctly enables or disables assets."",
        ""Assess the implications of disabling an asset and how it impacts existing bonds."",
        ""Investigate the mechanism by which assets are initially transferred into the contract before being locked via `createLock`. Does this rely on manager interaction or prior user approval?""
      ]
    },
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Analyze all external calls (especially to the ERC20 token contract) for potential reentrancy vulnerabilities. Although direct reentrancy may be unlikely, consider less obvious reentrancy paths."",
        ""Consider implementing reentrancy guards in critical functions if needed.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `BondNFT` implements an ERC721 token where each NFT represents a time-locked deposit (bond) of a specific ERC20 asset. It allows creating, extending, and releasing these bonds. Rewards can be distributed to bondholders based on the locked amount and duration (represented as 'shares'). The contract uses a daily epoch system for reward calculation and expiry tracking. It features an `Ownable` pattern for administrative tasks and a separate `manager` role for core bond operations like creation, release, and claiming, suggesting potential integration with an off-chain service or a trusted intermediary. Reward accounting uses an accumulated rewards per share mechanism."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""BondNFT"",
    ""Purpose"": ""To create and manage NFTs representing time-locked deposits (bonds) of ERC20 tokens, allowing holders to earn rewards distributed proportionally to their 'shares' (amount * lock period)."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""ERC721Enumerable"",
        ""Ownable""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""@openzeppelin/contracts/access/Ownable.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""DAY"",
        ""Type"": ""uint constant"",
        ""Purpose"": ""Defines the number of seconds in a day, used for epoch calculations.""
      },
      {
        ""Name"": ""Bond"",
        ""Type"": ""struct"",
        ""Purpose"": ""Data structure to hold all information about a specific bond.""
      },
      {
        ""Name"": ""epoch"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks the current epoch number for each allowed asset.""
      },
      {
        ""Name"": ""totalBonds"",
        ""Type"": ""uint"",
        ""Purpose"": ""Counter used to generate unique bond IDs (NFT token IDs).""
      },
      {
        ""Name"": ""baseURI"",
        ""Type"": ""string"",
        ""Purpose"": ""Base URI for constructing NFT metadata URLs.""
      },
      {
        ""Name"": ""manager"",
        ""Type"": ""address"",
        ""Purpose"": ""Address authorized to perform core bond operations (create, extend, release, claim).""
      },
      {
        ""Name"": ""assets"",
        ""Type"": ""address[]"",
        ""Purpose"": ""List of allowed ERC20 asset addresses for creating bonds.""
      },
      {
        ""Name"": ""allowedAsset"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Flags whether an asset address is currently allowed for bonding.""
      },
      {
        ""Name"": ""assetsIndex"",
        ""Type"": ""mapping(address => uint)"",
        ""Purpose"": ""Provides an index lookup for the `assets` array.""
      },
      {
        ""Name"": ""bondPaid"",
        ""Type"": ""mapping(uint256 => mapping(address => uint256))"",
        ""Purpose"": ""Tracks the amount of rewards already accounted for or paid out for a specific bond ID and asset.""
      },
      {
        ""Name"": ""accRewardsPerShare"",
        ""Type"": ""mapping(address => mapping(uint256 => uint256))"",
        ""Purpose"": ""Stores the accumulated rewards per share for each asset at each epoch.""
      },
      {
        ""Name"": ""_idToBond"",
        ""Type"": ""mapping(uint => Bond)"",
        ""Purpose"": ""Stores the internal Bond struct data associated with each bond ID.""
      },
      {
        ""Name"": ""totalShares"",
        ""Type"": ""mapping(address => uint)"",
        ""Purpose"": ""Tracks the total active shares for each asset, used in reward distribution calculations.""
      },
      {
        ""Name"": ""userDebt"",
        ""Type"": ""mapping(address => mapping(address => uint))"",
        ""Purpose"": ""Tracks pending rewards owed to a user (previous owner) after an NFT transfer.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract, setting the base URI, NFT name, and symbol."",
        ""Parameters"": [""string memory _setBaseURI"", ""string memory _name"", ""string memory _symbol""],
        ""Returns"": []
      },
      {
        ""Name"": ""createLock"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates a new bond NFT for a specified owner, locking assets for a period (manager only)."",
        ""Parameters"": [""address _asset"", ""uint _amount"", ""uint _period"", ""address _owner""],
        ""Returns"": [""uint id""]
      },
      {
        ""Name"": ""extendLock"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Extends the lock period and potentially adds more amount to an existing bond (manager only)."",
        ""Parameters"": [""uint _id"", ""address _asset"", ""uint _amount"", ""uint _period"", ""address _sender""],
        ""Returns"": []
      },
      {
        ""Name"": ""release"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Releases the locked assets and accrued rewards after expiry, burning the NFT (manager only). Allows non-owner release after a grace period."",
        ""Parameters"": [""uint _id"", ""address _releaser""],
        ""Returns"": [""uint amount"", ""uint lockAmount"", ""address asset"", ""address _owner""]
      },
      {
        ""Name"": ""claim"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims pending rewards for a bond without releasing the principal (manager only, acts on behalf of owner). Transfers rewards to the manager."",
        ""Parameters"": [""uint _id"", ""address _claimer""],
        ""Returns"": [""uint amount"", ""address tigAsset""]
      },
      {
        ""Name"": ""claimDebt"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims rewards accrued by a previous owner ('debt') after an NFT transfer (manager only). Transfers rewards to the manager."",
        ""Parameters"": [""address _user"", ""address _tigAsset""],
        ""Returns"": [""uint amount""]
      },
      {
        ""Name"": ""distribute"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Distributes ERC20 token rewards to the contract, updating reward calculations for a specific asset."",
        ""Parameters"": [""address _tigAsset"", ""uint _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""idToBond"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Retrieves the full details of a bond, including dynamically calculated pending rewards and owner."",
        ""Parameters"": [""uint256 _id""],
        ""Returns"": [""Bond memory bond""]
      },
      {
        ""Name"": ""isExpired"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Checks if a bond has passed its expiry epoch."",
        ""Parameters"": [""uint256 _id""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""pending"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the calculated pending rewards for a specific bond."",
        ""Parameters"": [""uint256 _id""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_transfer"",
        ""Visibility"": ""internal override"",
        ""Purpose"": ""Overrides ERC721 transfer to add reward accounting logic (calculating pending rewards and assigning as debt to the sender) and time-based checks."",
        ""Parameters"": [""address from"", ""address to"", ""uint256 _id""],
        ""Returns"": []
      },
      {
        ""Name"": ""addAsset"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds a new ERC20 asset to the list of allowed assets (owner only)."",
        ""Parameters"": [""address _asset""],
        ""Returns"": []
      },
      {
        ""Name"": ""setAllowedAsset"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Enables or disables an already added asset for new bonds (owner only)."",
        ""Parameters"": [""address _asset"", ""bool _bool""],
        ""Returns"": []
      },
      {
        ""Name"": ""setManager"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the manager address (owner only)."",
        ""Parameters"": [""address _manager""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyManager"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function execution to the designated manager address."",
        ""Parameters"": [],
        ""Returns"": []
      }
      // Other standard ERC721/Enumerable/Ownable functions and helpers like safeTransferMany, approveMany, balanceIds etc. exist but are not detailed here for brevity.
    ]
  },
  ""ExternalInteractions"": [
    ""Interacts with ERC20 token contracts (`IERC20`) to:"",
    ""  - Receive tokens during distribution (`transferFrom`)."",
    ""  - Send tokens during claims (`transfer` in `claim` and `claimDebt`)."",
    ""Inherits from and uses OpenZeppelin contracts (`ERC721Enumerable`, `Ownable`).""
  ],
  ""SpecialMechanisms"": [
    ""**NFT as Bond Representation:** Uses ERC721 to tokenize time-locked asset deposits."",
    ""**Reward Distribution:** Implements a per-share reward mechanism (`accRewardsPerShare`, `totalShares`) based on lock amount and duration."",
    ""**Epoch System:** Uses daily epochs (`block.timestamp / DAY`) for reward tracking and expiry."",
    ""**Manager Role:** A specific address (`manager`) controls core user-facing operations (minting, claiming, releasing), separate from the contract `owner`."",
    ""**Transfer Hook (`_transfer`):** Modifies standard transfer logic to handle pending reward accounting (`userDebt`)."",
    ""**Unchecked Arithmetic:** Uses `unchecked` blocks for potential gas savings, primarily in calculations involving shares, epochs, and reward updates."",
    ""**Release Grace Period:** Allows manager to release an expired bond for a non-owner only after 7 days past expiry.""
  ],
  ""Questions"": [
    ""What is the exact role and trust assumption of the `manager`? Why are user-centric actions like `createLock`, `extendLock`, `claim`, `release` restricted to the manager?"",
    ""In `claim` and `claimDebt`, rewards are transferred to the `manager`. How does the actual bond owner or user receive their funds?"",
    ""The `distribute` function can be called by anyone. Is this intended, or should access be restricted (e.g., to `owner` or `manager`)?"",
    ""Is the share recalculation logic in `extendLock` intended? `shares = (bond.amount + _amount) * (bond.period + _period) / 365` seems to apply the *full new period* to the *full new amount*, potentially over-allocating shares compared to just adding shares for the extension."",
    ""The `require(epoch[bond.asset] == block.timestamp/DAY, \""Bad epoch\"")` check in `_transfer` and `extendLock` seems very strict. What happens if `distribute` (which updates the epoch) hasn't been called for that asset on the current day? Does this prevent transfers/extensions until `distribute` is called?"",
    ""The logic for `_pendingDelta` calculation and its addition back to `accRewardsPerShare[bond.asset][epoch[bond.asset]]` in `claim` when `bond.expired` is true seems complex and potentially counter-intuitive. Needs verification for correctness and purpose."",
    ""How are the initial assets transferred *to* the contract or managed when `createLock` is called by the manager? Is there an assumed preceding `transferFrom`?"",
    ""The `release` function returns values `amount`, `lockAmount`, `asset`, `_owner` but doesn't perform an ERC20 transfer itself. How is the final payout to the `_owner` executed (presumably by the manager off-chain or in a separate transaction)?"",
    ""The `pending` calculation uses `accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]]`. If `bond.expired` is true, it uses the value from the epoch *before* expiry. Is this correct for calculating rewards up to the point of expiry?"",
    ""Is there protection against potential reentrancy, although direct reentrancy seems unlikely given the current structure and external calls?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions, including `claim` and `distribute`, interact with external ERC20 tokens using `transfer` or `transferFrom`. A malicious ERC20 token could call back into the contract before state changes are complete, potentially leading to reentrancy attacks, allowing attackers to drain funds or manipulate reward distribution. The `_transfer` function is also vulnerable if the token being transferred has a `transfer` hook that reverts, potentially causing a deadlock where the user has effectively lost their rewards because they've been recorded as paid, but the token wasn't actually transferred."",
      ""Impact"": ""Potential for malicious ERC20 tokens or managers to drain funds or manipulate reward distribution through reentrancy, causing financial loss to users.  A deadlock scenario where users can't transfer their tokens and also lose their accumulated rewards."",
      ""Location"": ""claim function, distribute function, _transfer function""
    },
    {
      ""Issue"": ""Integer Overflow/Underflow in Share Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""In `createLock` and `extendLock`, the calculation `shares = _amount * _period / 365` and `shares = (bond.amount + _amount) * (bond.period + _period) / 365` is vulnerable to integer overflow if `_amount * _period` or `(bond.amount + _amount) * (bond.period + _period)` exceeds the maximum value of `uint256`. This can lead to unexpected share values, affecting reward distribution and other calculations."",
      ""Impact"": ""Incorrect share calculation, leading to inaccurate reward distribution, potentially allowing users to manipulate the system for their benefit."",
      ""Location"": ""createLock function, extendLock function""
    },
    {
      ""Issue"": ""Incorrect Reward Calculation in Claim Function After Expiry"",
      ""Severity"": ""High"",
      ""Description"": ""The `claim` function calculates pending rewards after expiry based on `accRewardsPerShare`.  If `epoch[bond.asset]` and `bond.expireEpoch` are far apart, and there have been multiple `distribute` calls in between, the accumulated rewards per share could have significantly changed. The calculation only considers the difference between the current `accRewardsPerShare` and the `accRewardsPerShare` at `bond.expireEpoch-1`, potentially underestimating or overestimating the rewards earned during the entire expired period."",
      ""Impact"": ""Incorrect reward calculation post-expiry. Potential loss of funds for users or inflated rewards, destabilizing the system. The current implementation is likely vulnerable to manipulation."",
      ""Location"": ""claim function""
    },
    {
      ""Issue"": ""Inconsistent Epoch Handling and Time Sensitivity"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses `block.timestamp / DAY` to determine the epoch. There are checks in `extendLock` and `_transfer` that rely on `epoch[bond.asset] == block.timestamp/DAY`. If a lock extension is attempted on the same day that a new epoch begins there will be errors. If transactions are mined in different blocks, `block.timestamp` will be different, and `block.timestamp/DAY` will increment at the start of each new day. Also, the contract relies heavily on `block.timestamp` for epoch calculations and bond expiration, which can be manipulated by miners within certain bounds. This inconsistent logic and time dependency can cause unexpected errors, potential manipulation of bond expiration, and inaccurate reward calculations."",
      ""Impact"": ""Unexpected behavior and potential denial of service if the timing of transactions is slightly off. Potential for miners to manipulate bond expiration times and reward distribution, although the extent of manipulation is limited."",
      ""Location"": ""extendLock function, _transfer function, Multiple functions that use block.timestamp""
    },
    {
      ""Issue"": ""Lack of Access Control on distribute Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `distribute` function allows anyone to transfer tokens to the contract for distribution without any explicit access control restrictions. While checks exist for asset validity and total shares, this doesn't prevent malicious actors from calling the function with large amounts to manipulate reward distribution or cause a denial-of-service."",
      ""Impact"": ""A malicious actor could call `distribute` with large amounts, potentially causing a DoS or manipulating reward distribution to benefit themselves at the expense of other users."",
      ""Location"": ""distribute function""
    },
    {
      ""Issue"": ""Potential Division by Zero in `distribute` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `distribute` function divides `_amount * 1e18` by `totalShares[_tigAsset]`. While checks for `totalShares[_tigAsset] == 0` exist, a race condition or external manipulation could cause `totalShares[_tigAsset]` to become zero between the check and the division, leading to a division-by-zero error and reverting the transaction."",
      ""Impact"": ""Transaction reverts if `totalShares[_tigAsset]` is zero when the division is performed, halting reward distribution."",
      ""Location"": ""distribute function""
    },
    {
      ""Issue"": ""Missing Access Control for `safeTransferMany`, `safeTransferFromMany`, and `approveMany`"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `safeTransferMany`, `safeTransferFromMany`, and `approveMany` have no access control, meaning anyone can call them. This could lead to unintended transfers or approvals if a user accidentally calls these functions with incorrect parameters. The functions also do not check to see if the user owns all tokens in the `_ids` array and will revert if one token in the array is not owned by the caller."",
      ""Impact"": ""Unintended transfers or approvals, potentially leading to loss of funds or access control issues. Tokens not owned can be transferred, potential of funds lost."",
      ""Location"": ""safeTransferMany, safeTransferFromMany, approveMany functions""
    },
    {
      ""Issue"": ""Lack of Input Validation for Period"",
      ""Severity"": ""Low"",
      ""Description"": ""The `createLock` function does not validate that `_period` is within a reasonable range. While `extendLock` has `require(bond.period+_period <= 365, \\""MAX PERIOD\\"");`, `createLock` only checks if `allowedAsset[_asset]`. An extremely large or zero period could cause issues with calculations and storage."",
      ""Impact"": ""Potential for unexpected behavior or DoS due to excessive or zero period values."",
      ""Location"": ""createLock function""
    },
    {
      ""Issue"": ""Unsafe Arithmetic Operations"",
      ""Severity"": ""Informational"",
      ""Description"": ""While the code uses `unchecked` blocks in several places, it's important to carefully review each instance to ensure that overflows/underflows are acceptable and won't lead to unexpected behavior. Specifically, review the use of unchecked in `extendLock`, `release`, `claim`, `distribute`, `safeTransferMany`, `safeTransferFromMany`, `approveMany`, `_mint`, and `_transfer` to verify the safety of these operations."",
      ""Impact"": ""Potential for unexpected behavior if overflows or underflows occur where they are not intended."",
      ""Location"": ""Multiple functions""
    },
    {
      ""Issue"": ""Centralization Risk: Reliance on `manager` address and Missing Access Control in Claim Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several critical functions are restricted to the `manager` address. If the `manager` key is compromised or the `manager` acts maliciously, the entire system could be affected.  The `claim` function has a `onlyManager` modifier, but doesn't prevent the manager from claiming on behalf of any user, potentially stealing user rewards."",
      ""Impact"": ""Single point of failure; potential for abuse or compromise if the `manager` key is lost or stolen. The contract manager could potentially steal users' rewards."",
      ""Location"": ""createLock, extendLock, release, claim, claimDebt functions and onlyManager modifier, claim function""
    },
    {
      ""Issue"": ""Inconsistent Epoch Usage and Stale Epoch Handling"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `epoch` mapping stores the current epoch for each asset. However, `epoch` is used inconsistently. Sometimes its value is taken from `block.timestamp / DAY` directly and sometimes it is advanced by a loop in `distribute`. The `extendLock` function requires `epoch[bond.asset] == block.timestamp/DAY`. If `extendLock` isn't called at the start of a new epoch (i.e., the same day), the transaction will revert."",
      ""Impact"": ""Unexpected failures of `extendLock` function, making the bond management unpredictable. Inconvenience for the manager and users. They are forced to perform the extension at the beginning of a day (epoch)."",
      ""Location"": ""createLock, extendLock, distribute, extendLock""
    },
    {
      ""Issue"": ""Race Condition / Front Running in `distribute` and Epoch Update"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `distribute` function checks `aEpoch > epoch[_tigAsset]` and updates the `epoch[_tigAsset]` in a loop. If multiple `distribute` calls for the same `_tigAsset` are made in the same transaction or in rapid succession, the first call may update the epoch, and subsequent calls might distribute rewards based on a more current, but already accounted epoch. Also, because the `distribute` function transfers tokens *before* updating internal state, a malicious actor could potentially monitor the mempool and front-run the transaction, withdrawing all the transferred assets before the accounting updates occur."",
      ""Impact"": ""Rewards are distributed incorrectly across epochs. Front-running could allow for loss of funds."",
      ""Location"": ""distribute""
    },
    {
      ""Issue"": ""Unclear Rationale and Potential Inaccuracy in `claim` Logic"",
      ""Severity"": ""Low"",
      ""Description"": ""The `claim` function includes logic that appears to attempt to adjust `accRewardsPerShare` if the bond has expired. However, the formula `_pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset])` seems to be subtracting the same value from itself, thus always resulting in zero."",
      ""Impact"": ""Potential for incorrect reward calculations and distribution halts when bonds expire and total shares reach zero. Function possibly does nothing"",
      ""Location"": ""claim""
    },
    {
      ""Issue"": ""Potential Rounding Errors in Reward Calculations"",
      ""Severity"": ""Low"",
      ""Description"": ""The calculation of `accRewardsPerShare` and `bond.pending` involves division. Integer division truncates the decimal part, which could lead to small rounding errors. Over time, these errors could accumulate and cause a noticeable discrepancy between the expected and actual rewards."",
      ""Impact"": ""Slightly inaccurate reward distribution, potentially disadvantaging some users over others."",
      ""Location"": ""distribute and idToBond functions""
    },
    {
      ""Issue"": ""Debt accumulation in `_transfer` Function and Possible Deadlock in `_transfer` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `_transfer` function accumulates debt in `userDebt[from][bond.asset] += bond.pending;`. The function requires the `epoch` to be correct and that `block.timestamp` is 5 minutes after mint time. Also, the function updates `userDebt` before calling `super._transfer`. If the token being transferred has a `transfer` hook that reverts under certain conditions after the debt has been recorded, the transfer will fail, but the debt and `bondPaid` have already been updated. This means the user has effectively lost their rewards because they've been recorded as paid, but the token wasn't actually transferred."",
      ""Impact"": ""Potentially incorrect debt accumulation. Potential for users to lose rewards due to failed transfers and debt being incorrectly recorded. This creates a deadlock scenario where users can't transfer and their rewards are effectively burned. Users can't transfer their tokens and end up losing their pending rewards"",
      ""Location"": ""_transfer function""
    },
    {
      ""Issue"": ""Bond Owner Priority Logic Issue"",
      ""Severity"": ""Low"",
      ""Description"": ""The `release` function has a conditional requirement `require(bond.expireEpoch + 7 < epoch[bond.asset], \""Bond owner priority\"");`. This implies that if someone other than the bond owner tries to release the asset before 7 days after expiration, the transaction will fail. However, this introduces a waiting period. The purpose of this check is unclear."",
      ""Impact"": ""Unnecessary delay in releasing the asset after expiration, potentially hindering user experience."",
      ""Location"": ""release function""
    },
    {
      ""Issue"": ""Potential Denial of Service (DoS) in distribute function and Unbounded Loop"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `distribute` function contains a `for` loop that iterates from `epoch[_tigAsset]` to `aEpoch`. If the difference between these two values is very large (e.g., if the `epoch` hasn't been updated for a long time), this loop could consume a significant amount of gas, potentially exceeding the block gas limit and causing the transaction to revert. Also, the `safeTransferMany`, `safeTransferFromMany`, and `approveMany` functions iterate through an array of token IDs using a `for` loop. If the `_ids` array is very large, this could potentially lead to a gas limit issue, causing the transaction to revert."",
      ""Impact"": ""The contract becomes unusable for reward distributions, leading to a loss of incentive for users to participate. Transactions may revert due to gas limit issues when transferring or approving a large number of tokens."",
      ""Location"": ""distribute function, safeTransferMany, safeTransferFromMany, approveMany""
    },
    {
      ""Issue"": ""Missing Access Control on assets array Modification"",
      ""Severity"": ""Medium"",
      ""Description"": ""While `addAsset` and `setAllowedAsset` functions are protected by `onlyOwner` modifier, there's no restriction on modifying the `assets` array or the `allowedAsset` mapping after the initial setup. If an asset is removed from allowedAsset or its mapping is changed, this can lead to inconsistent state and unexpected behavior in reward distribution and other functions that rely on these mappings."",
      ""Impact"": ""Potential for inconsistent state and unexpected behavior, allowing an attacker to manipulate the reward distribution and other functions."",
      ""Location"": ""addAsset, setAllowedAsset functions""
    }
  ],
  ""IssueNumber"": 71,
  ""OutputList"": 17
}",260.312166929245,3998.0,32.0,"### **Output**

---

**[H-05] Malicious user can steal all assets in BondNFT**

**Report Description**:
A malicious user can drain all assets in BondNFT, causing other users to lose their rewards. When calling `claim()` for an expired bond, it recalculates `accRewardsPerShare`. This is because the reward after the `expireEpoch` does not belong to that expired bond and needs to be redistributed to all other bonds.

**Match in Response List**:
Matches with the issue titled **""Incorrect Reward Calculation in Claim Function After Expiry""**.

**Validation**:
**Correct**. The response accurately identifies the issue with incorrect reward calculations after bond expiry. It explains the risks associated with miscalculating `accRewardsPerShare`, which aligns with the reported vulnerability.

---

**[M-06] BondNFTs can revert when transferred**

**Report Description**:
In the function `_transfer`, `BondNFTs` should be transferrable. According to the proposal and the sponsor, BondNFTs should be able to be sold and borrowed against.

**Match in Response List**:
Matches with the issue titled **""Debt accumulation in `_transfer` Function and Possible Deadlock in `_transfer` Function""**.

**Validation**:
**Partially Correct**. The response identifies issues with the `_transfer` function, including potential deadlocks and incorrect debt accumulation. However, it does not explicitly address the transferability requirement mentioned in the issue report.

---

**[M-14] BondNFT.sol#claim() needs to correct all the missing epochs**

**Report Description**:
In `claim()`, `accRewardsPerShare[][]` is amended to reflect the expired shares. But only `accRewardsPerShare[bond.asset][epoch[bond.asset]]` is updated. All the epochs between `bond.expireEpoch-1` and `epoch[bond.asset]` are missed.

**Match in Response List**:
Matches with the issue titled **""Incorrect Reward Calculation in Claim Function After Expiry""**.

**Validation**:
**Correct**. The response correctly identifies the issue with missing epoch updates in the `claim` function, which aligns with the reported vulnerability.

---

**[M-16] distribute() won't update epoch[tigAsset] when totalShares[tigAsset]==0 which can cause later created bond for this tigAsset to have wrong mint epoch**

**Report Description**:
Function `BondNFT.createLock()` creates a bond and sets the bond's mint epoch as `epoch[asset]`. Function `Lock.lock()` first calls `claimGovFees()`, which calls `BondNFT.distribute()` for all assets and updates the `epoch[assets]` for all assets. However, if `totalShares[tigAsset] == 0`, `distribute()` won't update `epoch[asset]`, leading to incorrect mint epochs for later created bonds.

**Match in Response List**:
Matches with the issue titled **""Inconsistent Epoch Usage and Stale Epoch Handling""**.

**Validation**:
**Correct**. The response accurately identifies the issue with inconsistent epoch handling, which aligns with the reported vulnerability.

---

**[M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT**

**Report Description**:
After a lock has expired, it doesn't receive any rewards. However, unreleased locks cause other existing bonds to not receive the full amount of tokens. The issue is that as long as the bond is not released, the `totalShares` value isn't updated, leading to smaller cuts of the distribution for bond owners.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue, which involves flawed reward distribution due to unreleased locks.

---

**[M-23] Governance NFT holder, whose NFT was minted before `Trading._handleOpenFees` function is called, can lose deserved rewards after `Trading._handleOpenFees` function is called**

**Report Description**:
Calling the `Trading._handleOpenFees` function does not approve the `GovNFT` contract for spending any of the `Trading` contract's `_tigAsset` balance, unlike the `Trading._handleCloseFees` function, which executes `IStable(_tigAsset).approve(address(gov), type(uint).max)`.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue, which involves missing approvals in the `Trading._handleOpenFees` function.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-05] Malicious user can steal all assets in BondNFT**
- **[M-14] BondNFT.sol#claim() needs to correct all the missing epochs**
- **[M-16] distribute() won't update epoch[tigAsset] when totalShares[tigAsset]==0 which can cause later created bond for this tigAsset to have wrong mint epoch**

**Partially Correct Matches**:

- **[M-06] BondNFTs can revert when transferred**

**Missed Issues from Issue Report**:

- **[M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT**
- **[M-23] Governance NFT holder, whose NFT was minted before `Trading._handleOpenFees` function is called, can lose deserved rewards after `Trading._handleOpenFees` function is called**

---","```
1. Incorrect Reward Calculation in Claim Function After Expiry
2. Inconsistent Epoch Usage and Stale Epoch Handling
```","To calculate the **Average Precision (AP)**, we follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Incorrect Reward Calculation in Claim Function After Expiry"" appears at rank 3.
   - ""Inconsistent Epoch Usage and Stale Epoch Handling"" appears at rank 11.

2. **Calculate the precision at each rank**:
   - For rank 3: \( P@3 = \frac{1}{3} \approx 0.333 \)
   - For rank 11: \( P@11 = \frac{2}{11} \approx 0.182 \)

3. **Average the precision values**:
   \[
   AP = \frac{0.333 + 0.182}{2} \approx 0.2575
   \]

**Average Precision (AP)**: 0.2575"
Trading.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import ""./utils/MetaContext.sol"";
import ""./interfaces/ITrading.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IPairsContract.sol"";
import ""./interfaces/IReferrals.sol"";
import ""./interfaces/IPosition.sol"";
import ""./interfaces/IGovNFT.sol"";
import ""./interfaces/IStableVault.sol"";
import ""./utils/TradingLibrary.sol"";

interface ITradingExtension {
    function getVerifiedPrice(
        uint _asset,
        PriceData calldata _priceData,
        bytes calldata _signature,
        uint _withSpreadIsLong
    ) external returns(uint256 _price, uint256 _spread);
    function getRef(
        address _trader
    ) external pure returns(address);
    function _setReferral(
        bytes32 _referral,
        address _trader
    ) external;
    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;
    function isPaused() external view returns(bool);
    function minPos(address) external view returns(uint);
    function modifyLongOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function modifyShortOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function paused() external returns(bool);
    function _limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    ) external returns(uint _limitPrice, address _tigAsset);
    function _checkGas() external view;
    function _closePosition(
        uint _id,
        uint _price,
        uint _percent
    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);
}

interface IStable is IERC20 {
    function burnFrom(address account, uint amount) external;
    function mintFor(address account, uint amount) external;
}

interface ExtendedIERC20 is IERC20 {
    function decimals() external view returns (uint);
}

interface ERC20Permit is IERC20 {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

contract Trading is MetaContext, ITrading {

    error LimitNotSet(); //7
    error NotLiquidatable();
    error TradingPaused();
    error BadDeposit();
    error BadWithdraw();
    error ValueNotEqualToMargin();
    error BadLeverage();
    error NotMargin();
    error NotAllowedPair();
    error BelowMinPositionSize();
    error BadClosePercent();
    error NoPrice();
    error LiqThreshold();

    uint constant private DIVISION_CONSTANT = 1e10; // 100%
    uint private constant liqPercent = 9e9; // 90%

    struct Fees {
        uint daoFees;
        uint burnFees;
        uint referralFees;
        uint botFees;
    }
    Fees public openFees = Fees(
        0,
        0,
        0,
        0
    );
    Fees public closeFees = Fees(
        0,
        0,
        0,
        0
    );
    uint public limitOrderPriceRange = 1e8; // 1%

    uint public maxWinPercent;
    uint public vaultFundingPercent;

    IPairsContract private pairsContract;
    IPosition private position;
    IGovNFT private gov;
    ITradingExtension private tradingExtension;

    struct Delay {
        uint delay; // Block number where delay ends
        bool actionType; // True for open, False for close
    }
    mapping(uint => Delay) public blockDelayPassed; // id => Delay
    uint public blockDelay;
    mapping(uint => uint) public limitDelay; // id => block.timestamp

    mapping(address => bool) public allowedVault;

    struct Proxy {
        address proxy;
        uint256 time;
    }

    mapping(address => Proxy) public proxyApprovals;

    constructor(
        address _position,
        address _gov,
        address _pairsContract
    )
    {
        position = IPosition(_position);
        gov = IGovNFT(_gov);
        pairsContract = IPairsContract(_pairsContract);
    }

    // ===== END-USER FUNCTIONS =====

    /**
     * @param _tradeInfo Trade info
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function initiateMarketOrder(
        TradeInfo calldata _tradeInfo,
        PriceData calldata _priceData,
        bytes calldata _signature,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(position.getCount(), true);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);
        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        uint256 _isLong = _tradeInfo.direction ? 1 : 2;
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);
        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(
            _trader,
            _marginAfterFees,
            _tradeInfo.leverage,
            _tradeInfo.asset,
            _tradeInfo.direction,
            _price,
            _tradeInfo.tpPrice,
            _tradeInfo.slPrice,
            0,
            _tigAsset
        );
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        unchecked {
            if (_tradeInfo.direction) {
                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            }
        }
        _updateFunding(_tradeInfo.asset, _tigAsset);
        position.mint(
            _mintTrade
        );
        unchecked {
            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);
        }   
    }

    /**
     * @dev initiate closing position
     * @param _id id of the position NFT
     * @param _percent percent of the position being closed in BP
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _stableVault StableVault address
     * @param _outputToken Token received upon closing trade
     * @param _trader address the trade is initiated for
     */
    function initiateCloseOrder(
        uint _id,
        uint _percent,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _outputToken,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(_id, false);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit        
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);

        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();
        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); 
    }

    /**
     * @param _id position id
     * @param _addMargin margin amount used to add to the position
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _stableVault StableVault address
     * @param _marginAsset Token being used to add to the position
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function addToPosition(
        uint _id,
        uint _addMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _marginAsset,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkDelay(_id, true);
        IPosition.Trade memory _trade = position.trades(_id);
        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);
        _checkVault(_stableVault, _marginAsset);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);
        _handleDeposit(
            _trade.tigAsset,
            _marginAsset,
            _addMargin - _fee,
            _stableVault,
            _permitData,
            _trader
        );
        position.setAccInterest(_id);
        unchecked {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);
            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _addMargin -= _fee;
            uint _newMargin = _trade.margin + _addMargin;
            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;

            position.addToPosition(
                _trade.id,
                _newMargin,
                _newPrice
            );
            
            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);
        }
    }

    /**
     * @param _tradeInfo Trade info
     * @param _orderType type of limit order used to open the position
     * @param _price limit price
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function initiateLimitOrder(
        TradeInfo calldata _tradeInfo,
        uint256 _orderType, // 1 limit, 2 stop
        uint256 _price,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        if (_orderType == 0) revert(""5"");
        if (_price == 0) revert NoPrice();
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        uint256 _id = position.getCount();
        position.mint(
            IPosition.MintTrade(
                _trader,
                _tradeInfo.margin,
                _tradeInfo.leverage,
                _tradeInfo.asset,
                _tradeInfo.direction,
                _price,
                _tradeInfo.tpPrice,
                _tradeInfo.slPrice,
                _orderType,
                _tigAsset
            )
        );
        limitDelay[_id] = block.timestamp + 4;
        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);
    }

    /**
     * @param _id position ID
     * @param _trader address the trade is initiated for
     */
    function cancelLimitOrder(
        uint256 _id,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType == 0) revert();
        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);
        position.burn(_id);
        emit LimitCancelled(_id, _trader);
    }

    /**
     * @param _id position id
     * @param _marginAsset Token being used to add to the position
     * @param _stableVault StableVault address
     * @param _addMargin margin amount being added to the position
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function addMargin(
        uint256 _id,
        address _marginAsset,
        address _stableVault,
        uint256 _addMargin,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _marginAsset);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); //IsLimit
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);
        unchecked {
            uint256 _newMargin = _trade.margin + _addMargin;
            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
            if (_newLeverage < asset.minLeverage) revert(""!lev"");
            position.modifyMargin(_id, _newMargin, _newLeverage);
            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);
        }
    }

    /**
     * @param _id position id
     * @param _stableVault StableVault address
     * @param _outputToken token the trader will receive
     * @param _removeMargin margin amount being removed from the position
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _trader address the trade is initiated for
     */
    function removeMargin(
        uint256 _id,
        address _stableVault,
        address _outputToken,
        uint256 _removeMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); //IsLimit
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        uint256 _newMargin = _trade.margin - _removeMargin;
        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
        if (_newLeverage > asset.maxLeverage) revert(""!lev"");
        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);
        unchecked {
            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();
        }
        position.modifyMargin(_trade.id, _newMargin, _newLeverage);
        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);
        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);
    }

    /**
     * @param _type true for TP, false for SL
     * @param _id position id
     * @param _limitPrice TP/SL trigger price
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _trader address the trade is initiated for
     */
    function updateTpSl(
        bool _type,
        uint _id,
        uint _limitPrice,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        if (_type) {
            position.modifyTp(_id, _limitPrice);
        } else {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            _checkSl(_limitPrice, _trade.direction, _price);
            position.modifySl(_id, _limitPrice);
        }
        emit UpdateTPSL(_id, _type, _limitPrice, _trader);
    }

    /**
     * @param _id position id
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     */
    function executeLimitOrder(
        uint _id, 
        PriceData calldata _priceData,
        bytes calldata _signature
    ) 
        external
    {
        unchecked {
            _checkDelay(_id, true);
            tradingExtension._checkGas();
            if (tradingExtension.paused()) revert TradingPaused();
            require(block.timestamp >= limitDelay[_id]);
            IPosition.Trade memory trade = position.trades(_id);
            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);
            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);
            if (trade.orderType == 0) revert(""5"");
            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(""6""); //LimitNotMet
            if (trade.direction && trade.orderType == 1) {
                if (trade.price < _price) revert(""6""); //LimitNotMet
            } else if (!trade.direction && trade.orderType == 1) {
                if (trade.price > _price) revert(""6""); //LimitNotMet
            } else if (!trade.direction && trade.orderType == 2) {
                if (trade.price < _price) revert(""6""); //LimitNotMet
                trade.price = _price;
            } else {
                if (trade.price > _price) revert(""6""); //LimitNotMet
                trade.price = _price;
            } 
            if(trade.direction) {
                trade.price += trade.price * _spread / DIVISION_CONSTANT;
            } else {
                trade.price -= trade.price * _spread / DIVISION_CONSTANT;
            }
            if (trade.direction) {
                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            } else {
                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            }
            _updateFunding(trade.asset, trade.tigAsset);
            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);
            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());
        }
    }

    /**
     * @notice liquidate position
     * @param _id id of the position NFT
     * @param _priceData verifiable off-chain data
     * @param _signature node signature
     */
    function liquidatePosition(
        uint _id,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        unchecked {
            tradingExtension._checkGas();
            IPosition.Trade memory _trade = position.trades(_id);
            if (_trade.orderType != 0) revert(""4""); //IsLimit

            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);
            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;
            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);
            position.burn(_id);
            emit PositionLiquidated(_id, _trade.trader, _msgSender());
        }
    }

    /**
     * @dev close position at a pre-set price
     * @param _id id of the position NFT
     * @param _tp true if take profit
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     */
    function limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        _checkDelay(_id, false);
        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);
        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);
    }

    /**
     * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.
     * @param _proxy proxy wallet address
     * @param _timestamp end timestamp of approval period
     */
    function approveProxy(address _proxy, uint256 _timestamp) external payable {
        proxyApprovals[_msgSender()] = Proxy(
            _proxy,
            _timestamp
        );
        payable(_proxy).transfer(msg.value);
    }

    // ===== INTERNAL FUNCTIONS =====

    /**
     * @dev close the initiated position.
     * @param _id id of the position NFT
     * @param _percent percent of the position being closed
     * @param _price pair price
     * @param _stableVault StableVault address
     * @param _outputToken Token that trader will receive
     * @param _isBot false if closed via market order
     */
    function _closePosition(
        uint _id,
        uint _percent,
        uint _price,
        address _stableVault,
        address _outputToken,
        bool _isBot
    )
        internal
    {
        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);
        position.setAccInterest(_id);
        _updateFunding(_trade.asset, _trade.tigAsset);
        if (_percent < DIVISION_CONSTANT) {
            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(""!size"");
            position.reducePosition(_id, _percent);
        } else {
            position.burn(_id);
        }
        uint256 _toMint;
        if (_payout > 0) {
            unchecked {
                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);
                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {
                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;
                }
            }
            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);
        }
        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);
    }

    /**
     * @dev handle stablevault deposits for different trading functions
     * @param _tigAsset tigAsset token address
     * @param _marginAsset token being deposited into stablevault
     * @param _margin amount being deposited
     * @param _stableVault StableVault address
     * @param _permitData Data for approval via permit
     * @param _trader Trader address to take tokens from
     */
    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {
        IStable tigAsset = IStable(_tigAsset);
        if (_tigAsset != _marginAsset) {
            if (_permitData.usePermit) {
                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);
            }
            uint256 _balBefore = tigAsset.balanceOf(address(this));
            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());
            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);
            IERC20(_marginAsset).approve(_stableVault, type(uint).max);
            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);
            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();
            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));
        } else {
            tigAsset.burnFrom(_trader, _margin);
        }        
    }

    /**
     * @dev handle stablevault withdrawals for different trading functions
     * @param _trade Position info
     * @param _stableVault StableVault address
     * @param _outputToken Output token address
     * @param _toMint Amount of tigAsset minted to be used for withdrawal
     */
    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {
        IStable(_trade.tigAsset).mintFor(address(this), _toMint);
        if (_outputToken == _trade.tigAsset) {
            IERC20(_outputToken).transfer(_trade.trader, _toMint);
        } else {
            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));
            IStableVault(_stableVault).withdraw(_outputToken, _toMint);
            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();
            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);
        }        
    }

    /**
     * @dev handle fees distribution for opening
     * @param _asset asset id
     * @param _positionSize position size
     * @param _trader trader address
     * @param _tigAsset tigAsset address
     * @param _isBot false if opened via market order
     * @return _feePaid total fees paid during opening
     */
    function _handleOpenFees(
        uint _asset,
        uint _positionSize,
        address _trader,
        address _tigAsset,
        bool _isBot
    )
        internal
        returns (uint _feePaid)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = openFees;
        unchecked {
            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;
        }
        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));
        if (_referrer != address(0)) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _referrer,
                    _positionSize
                    * _fees.referralFees // get referral fee%
                    / DIVISION_CONSTANT // divide by 100%
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;
        }
        if (_isBot) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _positionSize
                    * _fees.botFees // get bot fee%
                    / DIVISION_CONSTANT // divide by 100%
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.botFees;
        } else {
            _fees.botFees = 0;
        }
        unchecked {
            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;
            _feePaid =
                _positionSize
                * (_fees.burnFees + _fees.botFees) // get total fee%
                / DIVISION_CONSTANT // divide by 100%
                + _daoFeesPaid;
            emit FeesDistributed(
                _tigAsset,
                _daoFeesPaid,
                _positionSize * _fees.burnFees / DIVISION_CONSTANT,
                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,
                _positionSize * _fees.botFees / DIVISION_CONSTANT,
                _referrer
            );
            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        }
        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));
    }

    /**
     * @dev handle fees distribution for closing
     * @param _asset asset id
     * @param _payout payout to trader before fees
     * @param _tigAsset margin asset
     * @param _positionSize position size
     * @param _trader trader address
     * @param _isBot false if closed via market order
     * @return payout_ payout to trader after fees
     */
    function _handleCloseFees(
        uint _asset,
        uint _payout,
        address _tigAsset,
        uint _positionSize,
        address _trader,
        bool _isBot
    )
        internal
        returns (uint payout_)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = closeFees;
        uint _daoFeesPaid;
        uint _burnFeesPaid;
        uint _referralFeesPaid;
        unchecked {
            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
        }
        uint _botFeesPaid;
        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));
        if (_referrer != address(0)) {
            unchecked {
                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            }
            IStable(_tigAsset).mintFor(
                _referrer,
                _referralFeesPaid
            );
             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;
        }
        if (_isBot) {
            unchecked {
                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _botFeesPaid
                );
            }
            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;
        }
        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);
        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;
        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        IStable(_tigAsset).approve(address(gov), type(uint).max);
        gov.distribute(_tigAsset, _daoFeesPaid);
        return payout_;
    }

    /**
     * @dev update funding rates after open interest changes
     * @param _asset asset id
     * @param _tigAsset tigAsset used for OI
     */
    function _updateFunding(uint256 _asset, address _tigAsset) internal {
        position.updateFunding(
            _asset,
            _tigAsset,
            pairsContract.idToOi(_asset, _tigAsset).longOi,
            pairsContract.idToOi(_asset, _tigAsset).shortOi,
            pairsContract.idToAsset(_asset).baseFundingRate,
            vaultFundingPercent
        );
    }

    /**
     * @dev check that SL price is valid compared to market price
     * @param _sl SL price
     * @param _direction long/short
     * @param _price market price
     */
    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {
        if (_direction) {
            if (_sl > _price) revert(""3""); //BadStopLoss
        } else {
            if (_sl < _price && _sl != 0) revert(""3""); //BadStopLoss
        }
    }

    /**
     * @dev check that trader address owns the position
     * @param _id position id
     * @param _trader trader address
     */
    function _checkOwner(uint _id, address _trader) internal view {
        if (position.ownerOf(_id) != _trader) revert(""2""); //NotPositionOwner   
    }

    /**
     * @notice Check that sufficient time has passed between opening and closing
     * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the ""valid signature pool"".
     * @param _id position id
     * @param _type true for opening, false for closing
     */
    function _checkDelay(uint _id, bool _type) internal {
        unchecked {
            Delay memory _delay = blockDelayPassed[_id];
            if (_delay.actionType == _type) {
                blockDelayPassed[_id].delay = block.number + blockDelay;
            } else {
                if (block.number < _delay.delay) revert(""0""); //Wait
                blockDelayPassed[_id].delay = block.number + blockDelay;
                blockDelayPassed[_id].actionType = _type;
            }
        }
    }

    /**
     * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault
     * @param _stableVault StableVault address
     * @param _token Margin asset token address
     */
    function _checkVault(address _stableVault, address _token) internal view {
        require(allowedVault[_stableVault], ""Unapproved stablevault"");
        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), ""Token not approved in vault"");
    }

    /**
     * @dev Check that the trader has approved the proxy address to trade for it
     * @param _trader Trader address
     */
    function _validateProxy(address _trader) internal view {
        if (_trader != _msgSender()) {
            Proxy memory _proxy = proxyApprovals[_trader];
            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, ""Proxy not approved"");
        }
    }

    // ===== GOVERNANCE-ONLY =====

    /**
     * @dev Sets block delay between opening and closing
     * @notice In blocks not seconds
     * @param _blockDelay delay amount
     */
    function setBlockDelay(
        uint _blockDelay
    )
        external
        onlyOwner
    {
        blockDelay = _blockDelay;
    }

    /**
     * @dev Whitelists a stablevault contract address
     * @param _stableVault StableVault address
     * @param _bool true if allowed
     */
    function setAllowedVault(
        address _stableVault,
        bool _bool
    )
        external
        onlyOwner
    {
        allowedVault[_stableVault] = _bool;
    }

    /**
     * @dev Sets max payout % compared to margin
     * @param _maxWinPercent payout %
     */
    function setMaxWinPercent(
        uint _maxWinPercent
    )
        external
        onlyOwner
    {
        maxWinPercent = _maxWinPercent;
    }

    /**
     * @dev Sets executable price range for limit orders
     * @param _range price range in %
     */
    function setLimitOrderPriceRange(uint _range) external onlyOwner {
        limitOrderPriceRange = _range;
    }

    /**
     * @dev Sets the fees for the trading protocol
     * @param _open True if open fees are being set
     * @param _daoFees Fees distributed to the DAO
     * @param _burnFees Fees which get burned
     * @param _referralFees Fees given to referrers
     * @param _botFees Fees given to bots that execute limit orders
     * @param _percent Percent of earned funding fees going to StableVault
     */
    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {
        unchecked {
            require(_daoFees >= _botFees+_referralFees*2);
            if (_open) {
                openFees.daoFees = _daoFees;
                openFees.burnFees = _burnFees;
                openFees.referralFees = _referralFees;
                openFees.botFees = _botFees;
            } else {
                closeFees.daoFees = _daoFees;
                closeFees.burnFees = _burnFees;
                closeFees.referralFees = _referralFees;
                closeFees.botFees = _botFees;                
            }
            require(_percent <= DIVISION_CONSTANT);
            vaultFundingPercent = _percent;
        }
    }

    /**
     * @dev Sets the extension contract address for trading
     * @param _ext extension contract address
     */
    function setTradingExtension(
        address _ext
    ) external onlyOwner() {
        tradingExtension = ITradingExtension(_ext);
    }

    // ===== EVENTS =====

    event PositionOpened(
        TradeInfo _tradeInfo,
        uint _orderType,
        uint _price,
        uint _id,
        address _trader,
        uint _marginAfterFees
    );

    event PositionClosed(
        uint _id,
        uint _closePrice,
        uint _percent,
        uint _payout,
        address _trader,
        address _executor
    );

    event PositionLiquidated(
        uint _id,
        address _trader,
        address _executor
    );

    event LimitOrderExecuted(
        uint _asset,
        bool _direction,
        uint _openPrice,
        uint _lev,
        uint _margin,
        uint _id,
        address _trader,
        address _executor
    );

    event UpdateTPSL(
        uint _id,
        bool _isTp,
        uint _price,
        address _trader
    );

    event LimitCancelled(
        uint _id,
        address _trader
    );

    event MarginModified(
        uint _id,
        uint _newMargin,
        uint _newLeverage,
        bool _isMarginAdded,
        address _trader
    );

    event AddToPosition(
        uint _id,
        uint _newMargin,
        uint _newPrice,
        address _trader
    );

    event FeesDistributed(
        address _tigAsset,
        uint _daoFees,
        uint _burnFees,
        uint _refFees,
        uint _botFees,
        address _referrer
    );
}",9443,1055,"[H-02] Riskless trades due to delay check
`Trading.limitClose()` uses `_checkDelay()`. This allows for riskless trades, by capturing price rises through increasing the stop-loss, while preventing the underwater position to be closed in case of the price dropping by continuously increasing the delay.
  [H-06] Incorrect calculation of new price while adding position
The formula used for calculating `_newPrice` in `addToPosition()` function of Trading.sol is not correct, users will lose part of their funds/profit while using this function.
  [H-09] Users can bypass the `maxWinPercent` limit using a partially closing
Users can bypass the `maxWinPercent` limit using a partial closing.
As a result, users can receive more funds than their upper limit from the protocol.
  [H-11] Not enough margin pulled or burned from user when adding to a position
When adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol, lowering the collateralization ratio of tigAsset.
  [M-04] Approved operators of Position token can't call Trading.initiateCloseOrder
Approved operators of owner of Position token can't call several function in Trading.
Functions that accept Position token in Trading are checking that the caller is owner of token using `_checkOwner` function.
  [M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`. This directly impacts margin calculations
Formula for `fee paid` in the `_handleOpenFees`  is incorrect leading to incorrect margin calculations. Since this directly impacts the trader margin and associated fee calculations, I've marked as HIGH risk.   [M-12] Centralization risks: owner can freeze withdraws and use timelock to steal all funds
The function `initiateCloseOrder()`   [M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()
The open price of a stop order might be changed during execution but it doesn't validate StopLoss/TakeProfit for the changed price.
  [M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18
In Trading.sol a deposit or withdrawal of tokens with decimals higher than 18 will always revert.
  [M-20] Trading#initiateMarketOrder allows to open a position with more margin than expected due to _handleOpenFees wrong calculation when a trade is referred
When `initiateMarketOrder` is called, `_marginAfterFees` are calculated and then used to calculate `_positionSize`.",10,,"pragma solidity ^0.8.0;

import ""./utils/MetaContext.sol"";
import ""./interfaces/ITrading.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IPairsContract.sol"";
import ""./interfaces/IReferrals.sol"";
import ""./interfaces/IPosition.sol"";
import ""./interfaces/IGovNFT.sol"";
import ""./interfaces/IStableVault.sol"";
import ""./utils/TradingLibrary.sol"";

interface ITradingExtension {
    function getVerifiedPrice(
        uint _asset,
        PriceData calldata _priceData,
        bytes calldata _signature,
        uint _withSpreadIsLong
    ) external returns(uint256 _price, uint256 _spread);
    function getRef(
        address _trader
    ) external pure returns(address);
    function _setReferral(
        bytes32 _referral,
        address _trader
    ) external;
    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;
    function isPaused() external view returns(bool);
    function minPos(address) external view returns(uint);
    function modifyLongOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function modifyShortOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function paused() external returns(bool);
    function _limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    ) external returns(uint _limitPrice, address _tigAsset);
    function _checkGas() external view;
    function _closePosition(
        uint _id,
        uint _price,
        uint _percent
    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);
}

interface IStable is IERC20 {
    function burnFrom(address account, uint amount) external;
    function mintFor(address account, uint amount) external;
}

interface ExtendedIERC20 is IERC20 {
    function decimals() external view returns (uint);
}

interface ERC20Permit is IERC20 {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

contract Trading is MetaContext, ITrading {

    error LimitNotSet(); 
    error NotLiquidatable();
    error TradingPaused();
    error BadDeposit();
    error BadWithdraw();
    error ValueNotEqualToMargin();
    error BadLeverage();
    error NotMargin();
    error NotAllowedPair();
    error BelowMinPositionSize();
    error BadClosePercent();
    error NoPrice();
    error LiqThreshold();

    uint constant private DIVISION_CONSTANT = 1e10; 
    uint private constant liqPercent = 9e9; 

    struct Fees {
        uint daoFees;
        uint burnFees;
        uint referralFees;
        uint botFees;
    }
    Fees public openFees = Fees(
        0,
        0,
        0,
        0
    );
    Fees public closeFees = Fees(
        0,
        0,
        0,
        0
    );
    uint public limitOrderPriceRange = 1e8; 

    uint public maxWinPercent;
    uint public vaultFundingPercent;

    IPairsContract private pairsContract;
    IPosition private position;
    IGovNFT private gov;
    ITradingExtension private tradingExtension;

    struct Delay {
        uint delay; 
        bool actionType; 
    }
    mapping(uint => Delay) public blockDelayPassed; 
    uint public blockDelay;
    mapping(uint => uint) public limitDelay; 

    mapping(address => bool) public allowedVault;

    struct Proxy {
        address proxy;
        uint256 time;
    }

    mapping(address => Proxy) public proxyApprovals;

    constructor(
        address _position,
        address _gov,
        address _pairsContract
    )
    {
        position = IPosition(_position);
        gov = IGovNFT(_gov);
        pairsContract = IPairsContract(_pairsContract);
    }

    

    
    function initiateMarketOrder(
        TradeInfo calldata _tradeInfo,
        PriceData calldata _priceData,
        bytes calldata _signature,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(position.getCount(), true);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);
        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        uint256 _isLong = _tradeInfo.direction ? 1 : 2;
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);
        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(
            _trader,
            _marginAfterFees,
            _tradeInfo.leverage,
            _tradeInfo.asset,
            _tradeInfo.direction,
            _price,
            _tradeInfo.tpPrice,
            _tradeInfo.slPrice,
            0,
            _tigAsset
        );
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        unchecked {
            if (_tradeInfo.direction) {
                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            }
        }
        _updateFunding(_tradeInfo.asset, _tigAsset);
        position.mint(
            _mintTrade
        );
        unchecked {
            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);
        }   
    }

    
    function initiateCloseOrder(
        uint _id,
        uint _percent,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _outputToken,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(_id, false);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); 
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);

        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();
        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); 
    }

    
    function addToPosition(
        uint _id,
        uint _addMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _marginAsset,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkDelay(_id, true);
        IPosition.Trade memory _trade = position.trades(_id);
        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);
        _checkVault(_stableVault, _marginAsset);
        if (_trade.orderType != 0) revert(""4""); 
        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);
        _handleDeposit(
            _trade.tigAsset,
            _marginAsset,
            _addMargin - _fee,
            _stableVault,
            _permitData,
            _trader
        );
        position.setAccInterest(_id);
        unchecked {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);
            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _addMargin -= _fee;
            uint _newMargin = _trade.margin + _addMargin;
            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;

            position.addToPosition(
                _trade.id,
                _newMargin,
                _newPrice
            );
            
            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);
        }
    }

    
    function initiateLimitOrder(
        TradeInfo calldata _tradeInfo,
        uint256 _orderType, 
        uint256 _price,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        if (_orderType == 0) revert(""5"");
        if (_price == 0) revert NoPrice();
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        uint256 _id = position.getCount();
        position.mint(
            IPosition.MintTrade(
                _trader,
                _tradeInfo.margin,
                _tradeInfo.leverage,
                _tradeInfo.asset,
                _tradeInfo.direction,
                _price,
                _tradeInfo.tpPrice,
                _tradeInfo.slPrice,
                _orderType,
                _tigAsset
            )
        );
        limitDelay[_id] = block.timestamp + 4;
        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);
    }

    
    function cancelLimitOrder(
        uint256 _id,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType == 0) revert();
        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);
        position.burn(_id);
        emit LimitCancelled(_id, _trader);
    }

    
    function addMargin(
        uint256 _id,
        address _marginAsset,
        address _stableVault,
        uint256 _addMargin,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _marginAsset);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); 
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);
        unchecked {
            uint256 _newMargin = _trade.margin + _addMargin;
            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
            if (_newLeverage < asset.minLeverage) revert(""!lev"");
            position.modifyMargin(_id, _newMargin, _newLeverage);
            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);
        }
    }

    
    function removeMargin(
        uint256 _id,
        address _stableVault,
        address _outputToken,
        uint256 _removeMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); 
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        uint256 _newMargin = _trade.margin - _removeMargin;
        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
        if (_newLeverage > asset.maxLeverage) revert(""!lev"");
        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);
        unchecked {
            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();
        }
        position.modifyMargin(_trade.id, _newMargin, _newLeverage);
        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);
        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);
    }

    
    function updateTpSl(
        bool _type,
        uint _id,
        uint _limitPrice,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); 
        if (_type) {
            position.modifyTp(_id, _limitPrice);
        } else {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            _checkSl(_limitPrice, _trade.direction, _price);
            position.modifySl(_id, _limitPrice);
        }
        emit UpdateTPSL(_id, _type, _limitPrice, _trader);
    }

    
    function executeLimitOrder(
        uint _id, 
        PriceData calldata _priceData,
        bytes calldata _signature
    ) 
        external
    {
        unchecked {
            _checkDelay(_id, true);
            tradingExtension._checkGas();
            if (tradingExtension.paused()) revert TradingPaused();
            require(block.timestamp >= limitDelay[_id]);
            IPosition.Trade memory trade = position.trades(_id);
            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);
            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);
            if (trade.orderType == 0) revert(""5"");
            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(""6""); 
            if (trade.direction && trade.orderType == 1) {
                if (trade.price < _price) revert(""6""); 
            } else if (!trade.direction && trade.orderType == 1) {
                if (trade.price > _price) revert(""6""); 
            } else if (!trade.direction && trade.orderType == 2) {
                if (trade.price < _price) revert(""6""); 
                trade.price = _price;
            } else {
                if (trade.price > _price) revert(""6""); 
                trade.price = _price;
            } 
            if(trade.direction) {
                trade.price += trade.price * _spread / DIVISION_CONSTANT;
            } else {
                trade.price -= trade.price * _spread / DIVISION_CONSTANT;
            }
            if (trade.direction) {
                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            } else {
                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            }
            _updateFunding(trade.asset, trade.tigAsset);
            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);
            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());
        }
    }

    
    function liquidatePosition(
        uint _id,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        unchecked {
            tradingExtension._checkGas();
            IPosition.Trade memory _trade = position.trades(_id);
            if (_trade.orderType != 0) revert(""4""); 

            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);
            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;
            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);
            position.burn(_id);
            emit PositionLiquidated(_id, _trade.trader, _msgSender());
        }
    }

    
    function limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        _checkDelay(_id, false);
        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);
        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);
    }

    
    function approveProxy(address _proxy, uint256 _timestamp) external payable {
        proxyApprovals[_msgSender()] = Proxy(
            _proxy,
            _timestamp
        );
        payable(_proxy).transfer(msg.value);
    }

    

    
    function _closePosition(
        uint _id,
        uint _percent,
        uint _price,
        address _stableVault,
        address _outputToken,
        bool _isBot
    )
        internal
    {
        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);
        position.setAccInterest(_id);
        _updateFunding(_trade.asset, _trade.tigAsset);
        if (_percent < DIVISION_CONSTANT) {
            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(""!size"");
            position.reducePosition(_id, _percent);
        } else {
            position.burn(_id);
        }
        uint256 _toMint;
        if (_payout > 0) {
            unchecked {
                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);
                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {
                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;
                }
            }
            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);
        }
        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);
    }

    
    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {
        IStable tigAsset = IStable(_tigAsset);
        if (_tigAsset != _marginAsset) {
            if (_permitData.usePermit) {
                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);
            }
            uint256 _balBefore = tigAsset.balanceOf(address(this));
            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());
            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);
            IERC20(_marginAsset).approve(_stableVault, type(uint).max);
            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);
            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();
            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));
        } else {
            tigAsset.burnFrom(_trader, _margin);
        }        
    }

    
    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {
        IStable(_trade.tigAsset).mintFor(address(this), _toMint);
        if (_outputToken == _trade.tigAsset) {
            IERC20(_outputToken).transfer(_trade.trader, _toMint);
        } else {
            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));
            IStableVault(_stableVault).withdraw(_outputToken, _toMint);
            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();
            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);
        }        
    }

    
    function _handleOpenFees(
        uint _asset,
        uint _positionSize,
        address _trader,
        address _tigAsset,
        bool _isBot
    )
        internal
        returns (uint _feePaid)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = openFees;
        unchecked {
            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;
        }
        address _referrer = tradingExtension.getRef(_trader); 
        if (_referrer != address(0)) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _referrer,
                    _positionSize
                    * _fees.referralFees 
                    / DIVISION_CONSTANT 
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;
        }
        if (_isBot) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _positionSize
                    * _fees.botFees 
                    / DIVISION_CONSTANT 
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.botFees;
        } else {
            _fees.botFees = 0;
        }
        unchecked {
            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;
            _feePaid =
                _positionSize
                * (_fees.burnFees + _fees.botFees) 
                / DIVISION_CONSTANT 
                + _daoFeesPaid;
            emit FeesDistributed(
                _tigAsset,
                _daoFeesPaid,
                _positionSize * _fees.burnFees / DIVISION_CONSTANT,
                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,
                _positionSize * _fees.botFees / DIVISION_CONSTANT,
                _referrer
            );
            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        }
        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));
    }

    
    function _handleCloseFees(
        uint _asset,
        uint _payout,
        address _tigAsset,
        uint _positionSize,
        address _trader,
        bool _isBot
    )
        internal
        returns (uint payout_)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = closeFees;
        uint _daoFeesPaid;
        uint _burnFeesPaid;
        uint _referralFeesPaid;
        unchecked {
            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
        }
        uint _botFeesPaid;
        address _referrer = tradingExtension.getRef(_trader);
        if (_referrer != address(0)) {
            unchecked {
                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            }
            IStable(_tigAsset).mintFor(
                _referrer,
                _referralFeesPaid
            );
             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;
        }
        if (_isBot) {
            unchecked {
                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _botFeesPaid
                );
            }
            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;
        }
        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);
        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;
        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        IStable(_tigAsset).approve(address(gov), type(uint).max);
        gov.distribute(_tigAsset, _daoFeesPaid);
        return payout_;
    }

    
    function _updateFunding(uint256 _asset, address _tigAsset) internal {
        position.updateFunding(
            _asset,
            _tigAsset,
            pairsContract.idToOi(_asset, _tigAsset).longOi,
            pairsContract.idToOi(_asset, _tigAsset).shortOi,
            pairsContract.idToAsset(_asset).baseFundingRate,
            vaultFundingPercent
        );
    }

    
    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {
        if (_direction) {
            if (_sl > _price) revert(""3""); 
        } else {
            if (_sl < _price && _sl != 0) revert(""3""); 
        }
    }

    
    function _checkOwner(uint _id, address _trader) internal view {
        if (position.ownerOf(_id) != _trader) revert(""2""); 
    }

    
    function _checkDelay(uint _id, bool _type) internal {
        unchecked {
            Delay memory _delay = blockDelayPassed[_id];
            if (_delay.actionType == _type) {
                blockDelayPassed[_id].delay = block.number + blockDelay;
            } else {
                if (block.number < _delay.delay) revert(""0""); 
                blockDelayPassed[_id].delay = block.number + blockDelay;
                blockDelayPassed[_id].actionType = _type;
            }
        }
    }

    
    function _checkVault(address _stableVault, address _token) internal view {
        require(allowedVault[_stableVault], ""Unapproved stablevault"");
        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), ""Token not approved in vault"");
    }

    
    function _validateProxy(address _trader) internal view {
        if (_trader != _msgSender()) {
            Proxy memory _proxy = proxyApprovals[_trader];
            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, ""Proxy not approved"");
        }
    }

    

    
    function setBlockDelay(
        uint _blockDelay
    )
        external
        onlyOwner
    {
        blockDelay = _blockDelay;
    }

    
    function setAllowedVault(
        address _stableVault,
        bool _bool
    )
        external
        onlyOwner
    {
        allowedVault[_stableVault] = _bool;
    }

    
    function setMaxWinPercent(
        uint _maxWinPercent
    )
        external
        onlyOwner
    {
        maxWinPercent = _maxWinPercent;
    }

    
    function setLimitOrderPriceRange(uint _range) external onlyOwner {
        limitOrderPriceRange = _range;
    }

    
    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {
        unchecked {
            require(_daoFees >= _botFees+_referralFees*2);
            if (_open) {
                openFees.daoFees = _daoFees;
                openFees.burnFees = _burnFees;
                openFees.referralFees = _referralFees;
                openFees.botFees = _botFees;
            } else {
                closeFees.daoFees = _daoFees;
                closeFees.burnFees = _burnFees;
                closeFees.referralFees = _referralFees;
                closeFees.botFees = _botFees;                
            }
            require(_percent <= DIVISION_CONSTANT);
            vaultFundingPercent = _percent;
        }
    }

    
    function setTradingExtension(
        address _ext
    ) external onlyOwner() {
        tradingExtension = ITradingExtension(_ext);
    }

    

    event PositionOpened(
        TradeInfo _tradeInfo,
        uint _orderType,
        uint _price,
        uint _id,
        address _trader,
        uint _marginAfterFees
    );

    event PositionClosed(
        uint _id,
        uint _closePrice,
        uint _percent,
        uint _payout,
        address _trader,
        address _executor
    );

    event PositionLiquidated(
        uint _id,
        address _trader,
        address _executor
    );

    event LimitOrderExecuted(
        uint _asset,
        bool _direction,
        uint _openPrice,
        uint _lev,
        uint _margin,
        uint _id,
        address _trader,
        address _executor
    );

    event UpdateTPSL(
        uint _id,
        bool _isTp,
        uint _price,
        address _trader
    );

    event LimitCancelled(
        uint _id,
        address _trader
    );

    event MarginModified(
        uint _id,
        uint _newMargin,
        uint _newLeverage,
        bool _isMarginAdded,
        address _trader
    );

    event AddToPosition(
        uint _id,
        uint _newMargin,
        uint _newPrice,
        address _trader
    );

    event FeesDistributed(
        address _tigAsset,
        uint _daoFees,
        uint _burnFees,
        uint _refFees,
        uint _botFees,
        address _referrer
    );
}",7509,4,6,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities: Reentrancy"",
      ""Tasks"": [
        ""Analyze `_handleOpenFees` for potential reentrancy vulnerabilities due to the external `IStable(_tigAsset).mintFor` call.  Consider scenarios where the receiver is a malicious contract that calls back into `Trading`."",
        ""Analyze `_handleCloseFees` for potential reentrancy vulnerabilities due to the external `IStable(_tigAsset).mintFor` call and subsequent `gov.distribute` call. Consider scenarios where the receiver is a malicious contract that calls back into `Trading`."",
        ""Analyze `_handleDeposit` for potential reentrancy vulnerabilities, especially considering the interaction with `IStableVault` and token transfers. Can a malicious vault re-enter during deposit or during `burnFrom`?"",
        ""Analyze `_handleWithdraw` for potential reentrancy vulnerabilities related to `IStableVault.withdraw` and token transfers. Can a malicious vault or token contract re-enter during withdrawal?"",
        ""Examine the state update order in functions interacting with external contracts (`IStable.mintFor`, `gov.distribute`, `IStableVault.deposit/withdraw`, `IERC20.transferFrom/transfer`) to see if state changes occur *before* external calls to prevent reentrancy.""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities: Arithmetic Overflows/Underflows"",
      ""Tasks"": [
        ""Thoroughly examine all `unchecked` blocks for potential overflow/underflow vulnerabilities, paying close attention to calculations involving `_positionSize`, `_margin`, `_leverage`, `_price`, `DIVISION_CONSTANT`, and fee percentages. Consider edge cases like very large or very small values."",
        ""Specifically, review the calculation of `_positionSize` in `initiateMarketOrder` and `addToPosition` to ensure that the multiplication and division operations do not lead to unexpected results."",
        ""Verify that `_handleOpenFees`'s fee calculations, especially when subtracting fees from `_daoFees`, doesn't result in underflows (e.g. when `_referrer` exists and `_isBot` is true)."",
        ""Check all calculations related to `_payout` in `_closePosition` to ensure overflows are impossible, especially the multiplication of `_positionSize` with `_percent` before division by `DIVISION_CONSTANT`."",
        ""Review the liquidation logic in `liquidatePosition` to confirm no overflows are possible when determining if a position is liquidatable.""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities: Price Manipulation & Oracle Integrity"",
      ""Tasks"": [
        ""Investigate the implementation of `ITradingExtension.getVerifiedPrice` to understand how price data is obtained, validated, and signed. Analyze its vulnerability to price manipulation attacks."",
        ""Assess the risk of stale prices being used in `initiateMarketOrder`, `initiateCloseOrder`, `addToPosition`, `removeMargin`, `updateTpSl`, `executeLimitOrder`, and `liquidatePosition`. Are there sufficient checks to ensure prices are up-to-date?"",
        ""Analyze the potential impact of large price swings on liquidation and margin calculations."",
        ""Evaluate the security of the off-chain signature verification process in `ITradingExtension.getVerifiedPrice`.  How are signatures generated, and how can replay attacks be prevented?"",
        ""Consider potential scenarios where a malicious actor could manipulate the price feed within the `limitOrderPriceRange` allowed in `executeLimitOrder` to their advantage.""
      ]
    },
    {
      ""Area"": ""Compliance & Access Control"",
      ""Tasks"": [
        ""Verify that the `onlyOwner` modifier is used appropriately to protect sensitive functions like `setBlockDelay`, `setAllowedVault`, `setMaxWinPercent`, `setLimitOrderPriceRange`, `setFees`, and `setTradingExtension`."",
        ""Analyze the `_validateProxy` function to ensure that the proxy approval mechanism is secure and prevents unauthorized trading. Verify that the timestamp check is correct and prevents replay attacks."",
        ""Check that access to modify or close a position is restricted to the owner of the position via `_checkOwner`."",
        ""Confirm that the `MetaContext` contract and its `onlyOwner` modifier are correctly implemented and secure.""
      ]
    },
    {
      ""Area"": ""Complex Logic: Fee Calculation and Distribution"",
      ""Tasks"": [
        ""Thoroughly review the fee calculation and distribution logic in `_handleOpenFees` and `_handleCloseFees` to ensure that fees are calculated correctly and distributed to the intended recipients (DAO, burn, referrer, bot)."",
        ""Verify that the fee percentages are within acceptable ranges and that the `vaultFundingPercent` is used appropriately."",
        ""Analyze the impact of different fee configurations on the profitability of the platform and the incentives for different actors (traders, referrers, bots)."",
        ""Check that the `distribute` function in the `IGovNFT` contract correctly handles the distributed fees and that there are no vulnerabilities in its implementation."",
        ""Ensure the asset.feeMultiplier usage won't cause unexpected high fees (check its possible values).""
      ]
    },
    {
      ""Area"": ""External Interactions and Trust Assumptions"",
      ""Tasks"": [
        ""Document and analyze all external contract interactions (IPosition, ITradingExtension, IPairsContract, IStableVault, IERC20/IStable/ExtendedIERC20/ERC20Permit, IGovNFT, TradingLibrary) to understand the trust assumptions and potential risks associated with each interaction."",
        ""Assess the security of the `ITradingExtension` contract, as it handles critical logic like price verification and open interest management. Understand how this contract is deployed and managed."",
        ""Evaluate the potential impact of vulnerabilities in the external contracts on the `Trading` contract.  Are there fallback mechanisms or safeguards in place?"",
        ""Examine the `IStableVault` interactions for potential risks related to token swapping, slippage, and front-running."",
        ""Determine the minting/burning authorization setup of `IStable`. Ensure only this contract can call `mintFor` and `burnFrom`.""
      ]
    },
    {
      ""Area"": ""Denial of Service"",
      ""Tasks"": [
        ""Analyze potential denial-of-service vulnerabilities related to gas limits, especially in functions that iterate over collections or perform complex calculations. For example, review the gas consumption of `_handleOpenFees` and `_handleCloseFees`."",
        ""Assess the impact of large numbers of open positions on the performance of the platform and the potential for denial-of-service attacks. Are there any limitations on the number of open positions?"",
        ""Investigate the gas cost of `tradingExtension._checkGas()` and its impact on the overall cost of transactions.""
      ]
    },
    {
      ""Area"": ""Inconsistent Error Handling & Revert Strings"",
      ""Tasks"": [
        ""Replace the magic revert strings (\""0\"", \""2\"", \""3\"", \""4\"", \""5\"", \""6\"", \""!lev\"", \""!size\"") with descriptive custom errors for improved debugging and clarity.  This will make it easier to identify the root cause of reverts."",
        ""Ensure that all error conditions are handled gracefully and that appropriate error messages are emitted."",
        ""Check functions to make sure errors revert properly and never proceed on failure.""
      ]
    },
    {
      ""Area"": ""Potential for Front-Running"",
      ""Tasks"": [
        ""Analyze the `initiateMarketOrder` function for potential front-running vulnerabilities. A malicious actor could observe the transaction and submit a transaction with a higher gas price to execute their trade before the original transaction, potentially manipulating the price to their advantage."",
        ""Assess the impact of transaction ordering on the execution of limit orders in the `executeLimitOrder` function."",
        ""Evaluate the effectiveness of the `limitOrderPriceRange` check in preventing front-running attacks."",
        ""Examine the `updateTpSl` function for front-running opportunities by changing TP/SL before execution.""
      ]
    },
    {
      ""Area"": ""Incorrect or Missing Checks"",
      ""Tasks"":[
         ""Review function `addMargin`. New leverage is being calculated (`_newLeverage = _trade.margin * _trade.leverage / _newMargin;`), but it's not validated via `tradingExtension.validateTrade`. It should be."",
         ""Check the math in the `removeMargin` function when calculating `_newLeverage`. It seems it calculates it correctly but it's redundant to load it since it's not being passed to any subsequent function. Recommend removing it since this function does not modify leverage (the underlying position margin is decreased without re-calculating/changing leverage)."",
         ""The functions `limitClose`, `liquidatePosition`, `executeLimitOrder` should have `_validateProxy(_trader)` check added. They are missing the validations present in other function calls, allowing anyone to call these functions by impersonating a Trader.""
      ]
    },
     {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Review all functions for potential gas optimization opportunities, such as reducing redundant calculations, using more efficient data structures, and minimizing state variable reads and writes."",
        ""Identify opportunities to use calldata instead of memory for function parameters where appropriate."",
        ""Consolidate similar checks and operations to reduce code duplication and gas costs."",
        ""Consider using assembly code for performance-critical sections of the code, such as the fee calculation and distribution logic."",
         ""Review the use of `SSTORE` operations. Are there ways to delay or batch `SSTORE` operations to reduce gas costs?"",
         ""Check redundant variable assignments (e.g. `removeMargin`)."",
         ""Consider pre-calculating or caching values that are used multiple times within a function to reduce redundant calculations (e.g., fee calculation parts).""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `Trading` serves as the central logic hub for a decentralized leveraged trading platform. It orchestrates interactions between users, position management (likely NFTs via `IPosition`), price oracles/validation (`ITradingExtension`), collateral vaults (`IStableVault`), fee distribution (`IGovNFT`), and asset pair information (`IPairsContract`). It handles opening market and limit orders, closing positions, adding/removing margin, liquidations, TP/SL updates, and fee calculations. It employs mechanisms like block delays, proxy approvals, and ERC20 permits."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""Trading"",
    ""Purpose"": ""To manage the lifecycle of leveraged trading positions, including opening, closing, modification, liquidation, and fee handling, while interacting with various other system components."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""MetaContext"",
        ""ITrading""
      ],
      ""Imports"": [
        ""./utils/MetaContext.sol"",
        ""./interfaces/ITrading.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""./interfaces/IPairsContract.sol"",
        ""./interfaces/IReferrals.sol"",
        ""./interfaces/IPosition.sol"",
        ""./interfaces/IGovNFT.sol"",
        ""./interfaces/IStableVault.sol"",
        ""./utils/TradingLibrary.sol"",
        ""ITradingExtension (Interface defined in code)"",
        ""IStable (Interface defined in code)"",
        ""ExtendedIERC20 (Interface defined in code)"",
        ""ERC20Permit (Interface defined in code)""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""DIVISION_CONSTANT"",
        ""Type"": ""uint constant"",
        ""Purpose"": ""A constant (1e10) used for high-precision division, likely representing 100%.""
      },
      {
        ""Name"": ""liqPercent"",
        ""Type"": ""uint private constant"",
        ""Purpose"": ""A constant (9e9, 90% of DIVISION_CONSTANT) defining the liquidation threshold percentage relative to margin.""
      },
      {
        ""Name"": ""openFees"",
        ""Type"": ""Fees (struct)"",
        ""Purpose"": ""Stores the fee percentages (DAO, burn, referral, bot) applied when opening a position.""
      },
      {
        ""Name"": ""closeFees"",
        ""Type"": ""Fees (struct)"",
        ""Purpose"": ""Stores the fee percentages (DAO, burn, referral, bot) applied when closing a position.""
      },
      {
        ""Name"": ""limitOrderPriceRange"",
        ""Type"": ""uint"",
        ""Purpose"": ""Allowed deviation percentage (relative to DIVISION_CONSTANT) between the requested limit price and the execution price.""
      },
      {
        ""Name"": ""maxWinPercent"",
        ""Type"": ""uint"",
        ""Purpose"": ""Maximum win percentage allowed relative to the initial margin (scaled by DIVISION_CONSTANT).""
      },
      {
        ""Name"": ""vaultFundingPercent"",
        ""Type"": ""uint"",
        ""Purpose"": ""Percentage (relative to DIVISION_CONSTANT) used in funding rate calculations, possibly related to vault contributions.""
      },
      {
        ""Name"": ""pairsContract"",
        ""Type"": ""IPairsContract private"",
        ""Purpose"": ""Reference to the contract managing trading pair information (leverage limits, fees, OI).""
      },
      {
        ""Name"": ""position"",
        ""Type"": ""IPosition private"",
        ""Purpose"": ""Reference to the contract managing individual position data (likely NFTs).""
      },
      {
        ""Name"": ""gov"",
        ""Type"": ""IGovNFT private"",
        ""Purpose"": ""Reference to the contract handling governance fee distribution.""
      },
      {
        ""Name"": ""tradingExtension"",
        ""Type"": ""ITradingExtension private"",
        ""Purpose"": ""Reference to an extension contract handling logic like price verification, OI updates, trade validation etc.""
      },
      {
        ""Name"": ""blockDelayPassed"",
        ""Type"": ""mapping(uint => Delay)"",
        ""Purpose"": ""Tracks the block number until which certain actions (open/close type) are delayed for a given position ID.""
      },
      {
        ""Name"": ""blockDelay"",
        ""Type"": ""uint"",
        ""Purpose"": ""The number of blocks to delay actions after a previous action on the same position.""
      },
      {
        ""Name"": ""limitDelay"",
        ""Type"": ""mapping(uint => uint)"",
        ""Purpose"": ""Tracks the timestamp after which a specific limit order (by ID) can be executed.""
      },
      {
        ""Name"": ""allowedVault"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Whitelist of approved stablecoin vault contracts.""
      },
      {
        ""Name"": ""proxyApprovals"",
        ""Type"": ""mapping(address => Proxy)"",
        ""Purpose"": ""Stores approvals granted by users to proxy addresses to trade on their behalf until a certain timestamp.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes references to essential contracts: `IPosition`, `IGovNFT`, `IPairsContract`."",
        ""Parameters"": [""_position"", ""_gov"", ""_pairsContract""],
        ""Returns"": []
      },
      {
        ""Name"": ""initiateMarketOrder"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Opens a new market position after validating inputs, handling deposits/fees, getting price, modifying OI, and minting the position."",
        ""Parameters"": [""_tradeInfo"", ""_priceData"", ""_signature"", ""_permitData"", ""_trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""initiateCloseOrder"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initiates the process to close a percentage of an existing market position."",
        ""Parameters"": [""_id"", ""_percent"", ""_priceData"", ""_signature"", ""_stableVault"", ""_outputToken"", ""_trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""addToPosition"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds margin to an existing position, increasing its size and recalculating the average entry price."",
        ""Parameters"": [""_id"", ""_addMargin"", ""_priceData"", ""_signature"", ""_stableVault"", ""_marginAsset"", ""_permitData"", ""_trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""initiateLimitOrder"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates a new limit or stop order (position is minted but not active)."",
        ""Parameters"": [""_tradeInfo"", ""_orderType"", ""_price"", ""_permitData"", ""_trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""cancelLimitOrder"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Cancels a pending limit/stop order and refunds the margin."",
        ""Parameters"": [""_id"", ""_trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""addMargin"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds collateral (margin) to an existing position without changing its size, thus reducing leverage."",
        ""Parameters"": [""_id"", ""_marginAsset"", ""_stableVault"", ""_addMargin"", ""_permitData"", ""_trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""removeMargin"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Removes collateral (margin) from an existing position, increasing leverage, subject to liquidation checks."",
        ""Parameters"": [""_id"", ""_stableVault"", ""_outputToken"", ""_removeMargin"", ""_priceData"", ""_signature"", ""_trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateTpSl"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the Take Profit (TP) or Stop Loss (SL) price for an existing position."",
        ""Parameters"": [""_type"", ""_id"", ""_limitPrice"", ""_priceData"", ""_signature"", ""_trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""executeLimitOrder"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Executes a pending limit/stop order when price conditions are met (likely called by a bot)."",
        ""Parameters"": [""_id"", ""_priceData"", ""_signature""],
        ""Returns"": []
      },
      {
        ""Name"": ""liquidatePosition"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Forcefully closes an undercollateralized position (likely called by a bot)."",
        ""Parameters"": [""_id"", ""_priceData"", ""_signature""],
        ""Returns"": []
      },
      {
        ""Name"": ""limitClose"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Closes a position triggered by its TP or SL price (likely called by a bot via `tradingExtension`)."",
        ""Parameters"": [""_id"", ""_tp"", ""_priceData"", ""_signature""],
        ""Returns"": []
      },
      {
        ""Name"": ""approveProxy"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to approve a proxy address to execute transactions on their behalf for a limited time."",
        ""Parameters"": [""_proxy"", ""_timestamp""],
        ""Returns"": []
      },
      {
        ""Name"": ""_closePosition"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Core logic for closing a position (fully or partially), calculating payout, handling fees, burning/modifying the position NFT, and handling withdrawals."",
        ""Parameters"": [""_id"", ""_percent"", ""_price"", ""_stableVault"", ""_outputToken"", ""_isBot""],
        ""Returns"": []
      },
      {
        ""Name"": ""_handleDeposit"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles depositing margin, potentially swapping input tokens via a stable vault, and burning the stablecoin used as collateral."",
        ""Parameters"": [""_tigAsset"", ""_marginAsset"", ""_margin"", ""_stableVault"", ""_permitData"", ""_trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""_handleWithdraw"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles withdrawing funds after closing/reducing a position, potentially swapping the stablecoin collateral back to a desired output token via a stable vault."",
        ""Parameters"": [""_trade"", ""_stableVault"", ""_outputToken"", ""_toMint""],
        ""Returns"": []
      },
      {
        ""Name"": ""_handleOpenFees"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates, distributes (DAO, burn, referral, bot), and returns the total fee amount deducted from margin on position open/increase."",
        ""Parameters"": [""_asset"", ""_positionSize"", ""_trader"", ""_tigAsset"", ""_isBot""],
        ""Returns"": [""_feePaid""]
      },
      {
        ""Name"": ""_handleCloseFees"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates, distributes (DAO, burn, referral, bot), and returns the net payout after deducting fees on position close."",
        ""Parameters"": [""_asset"", ""_payout"", ""_tigAsset"", ""_positionSize"", ""_trader"", ""_isBot""],
        ""Returns"": [""payout_""]
      },
      {
        ""Name"": ""_updateFunding"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Triggers an update of the funding rate calculation in the `IPosition` contract."",
        ""Parameters"": [""_asset"", ""_tigAsset""],
        ""Returns"": []
      },
      {
        ""Name"": ""_checkSl"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Validates that the stop-loss price is logical relative to the current/entry price and trade direction."",
        ""Parameters"": [""_sl"", ""_direction"", ""_price""],
        ""Returns"": []
      },
      {
        ""Name"": ""_checkOwner"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Verifies that the caller owns the specified position ID."",
        ""Parameters"": [""_id"", ""_trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""_checkDelay"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Enforces a block delay between consecutive actions of the same type (open/close) on a position."",
        ""Parameters"": [""_id"", ""_type""],
        ""Returns"": []
      },
      {
        ""Name"": ""_checkVault"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Validates that the provided stable vault is allowed and the specified token is usable within that vault."",
        ""Parameters"": [""_stableVault"", ""_token""],
        ""Returns"": []
      },
      {
        ""Name"": ""_validateProxy"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if the `_msgSender()` is either the trader themselves or an approved, non-expired proxy for the trader."",
        ""Parameters"": [""_trader""],
        ""Returns"": []
      },
      {
        ""Name"": ""setBlockDelay"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to set the action block delay."",
        ""Parameters"": [""_blockDelay""],
        ""Returns"": []
      },
      {
        ""Name"": ""setAllowedVault"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to add/remove allowed stable vaults."",
        ""Parameters"": [""_stableVault"", ""_bool""],
        ""Returns"": []
      },
      {
        ""Name"": ""setMaxWinPercent"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to set the maximum win percentage cap."",
        ""Parameters"": [""_maxWinPercent""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLimitOrderPriceRange"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to set the allowed price deviation for limit order execution."",
        ""Parameters"": [""_range""],
        ""Returns"": []
      },
      {
        ""Name"": ""setFees"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to set open or close fee percentages and the vault funding percentage."",
        ""Parameters"": [""_open"", ""_daoFees"", ""_burnFees"", ""_referralFees"", ""_botFees"", ""_percent""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTradingExtension"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to set the address of the `ITradingExtension` contract."",
        ""Parameters"": [""_ext""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IPosition: Minting, burning, modifying trade data (margin, price, TP/SL, interest), reading trade data, getting owner."",
    ""ITradingExtension: Price verification (`getVerifiedPrice`), referral handling (`getRef`, `_setReferral`), trade validation (`validateTrade`), checking pause status (`isPaused`, `paused`), getting min position size (`minPos`), modifying open interest (`modifyLongOi`, `modifyShortOi`), executing limit closes (`_limitClose`), checking gas (`_checkGas`), performing position closure calculations (`_closePosition`)."",
    ""IPairsContract: Reading asset metadata (fee multiplier, leverage limits, base funding rate), reading open interest data (`idToOi`)."",
    ""IStableVault: Depositing collateral (`deposit`), withdrawing collateral (`withdraw`), checking allowed tokens (`allowed`), getting the vault's stablecoin address (`stable`)."",
    ""IERC20 / IStable / ExtendedIERC20 / ERC20Permit: Transferring tokens (`transferFrom`, `transfer`), minting/burning stablecoins (`mintFor`, `burnFrom`), approving spends (`approve`), checking balance (`balanceOf`), getting decimals (`decimals`), using permits (`permit`)."",
    ""IGovNFT: Distributing collected DAO fees (`distribute`)."",
    ""TradingLibrary: Calculating profit and loss (`pnl`).""
  ],
  ""SpecialMechanisms"": [
    ""Proxy Trading Approval (`approveProxy`, `_validateProxy`): Allows users to delegate trading actions to another address for a set duration."",
    ""Action Delay (`_checkDelay`, `blockDelay`): Prevents users from performing rapid consecutive actions (like opening then immediately closing) on the same position within a configurable number of blocks."",
    ""Limit Order Execution Delay (`limitDelay`): Prevents limit orders from being executed immediately after creation (minimum 4 seconds)."",
    ""ERC20 Permit (`_handleDeposit`): Supports EIP-2612 for gasless token approvals."",
    ""Extensive reliance on `ITradingExtension`: Delegates critical logic like price verification, trade validation, and OI management, making this contract an orchestrator."",
    ""Complex Fee Structure (`_handleOpenFees`, `_handleCloseFees`): Calculates and distributes fees to multiple parties (DAO, burn, referrals, bots) based on configurable percentages and position size."",
    ""Vault Interaction (`_handleDeposit`, `_handleWithdraw`): Uses `IStableVault` potentially as a DEX aggregator or liquidity source for handling deposits/withdrawals in different tokens."",
    ""NFT-based Positions: Implied by interaction with `IPosition` (which likely follows ERC721 standard based on `ownerOf` usage)."",
    ""Use of `unchecked` blocks: For performance optimization in arithmetic operations where overflow/underflow is deemed impossible or acceptable (requires careful review).""
  ],
  ""Questions"": [
    ""What specific logic is implemented in the `ITradingExtension` contract, particularly for `getVerifiedPrice` (oracle mechanism?), `validateTrade`, `modifyLong/ShortOi`, `_limitClose`, and `_closePosition`?"",
    ""How is the off-chain `_signature` for price data generated and verified within `ITradingExtension.getVerifiedPrice`?"",
    ""Are there potential reentrancy vulnerabilities, especially within the fee handling (`_handleOpenFees`, `_handleCloseFees`) and deposit/withdraw functions (`_handleDeposit`, `_handleWithdraw`) due to external calls (mint/transfer/distribute)?"",
    ""How robust are the checks against price manipulation, especially considering the reliance on `ITradingExtension` and potential delays in price feeds?"",
    ""What is the exact mechanism for funding rate calculation triggered by `_updateFunding`?"",
    ""Why are revert strings (\""0\"", \""2\"", \""3\"", \""4\"", \""5\"", \""6\"", \""!lev\"", \""!size\"") used in several places instead of custom errors, reducing clarity?"",
    ""Have the `unchecked` blocks been thoroughly vetted to prevent unintended overflows/underflows in all scenarios (e.g., extreme price movements, fee calculations)?"",
    ""What is the specific purpose and impact of `tradingExtension._checkGas()`?"",
    ""Is the `limitOrderPriceRange` check in `executeLimitOrder` sufficient to prevent front-running or unfavorable execution within the allowed range?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `_handleWithdraw` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `_handleWithdraw` function mints tokens to the contract and then transfers tokens to the trader. If the `_outputToken` is an ERC777 token or a malicious contract, the transfer could trigger a callback to the `Trading` contract before the state is updated, potentially leading to reentrancy attacks. This is especially problematic as `_handleWithdraw` is called in crucial functions like `_closePosition` and `removeMargin`. The calls to `IStableVault(_stableVault).withdraw` and `IERC20(_outputToken).transfer` could both trigger reentrancy."",
      ""Impact"": ""An attacker could potentially re-enter the contract during the token transfer and manipulate the contract's state, leading to theft of funds or other unintended consequences. For example, an attacker could call `removeMargin` then re-enter through a malicious token callback and call `removeMargin` again before the original call has finished."",
      ""Location"": ""Trading.sol:_handleWithdraw""
    },
    {
      ""Issue"": ""Lack of access control on `liquidatePosition`"",
      ""Severity"": ""High"",
      ""Description"": ""The function `liquidatePosition` can be called by anyone. The check `if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT))` is inversed (should be `if (_payout < int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT))`) and can be bypassed. This allows anyone to liquidate a position, potentially griefing traders or exploiting vulnerabilities if liquidation logic is flawed. A proper permissioning mechanism or whitelisting approach should be implemented to restrict liquidation to authorized accounts."",
      ""Impact"": ""Anyone can liquidate anyone\'s position."",
      ""Location"": ""Trading.sol:liquidatePosition""
    },
    {
      ""Issue"": ""Incorrect check on _percent in `initiateCloseOrder` function"",
      ""Severity"": ""High"",
      ""Description"": ""The function `initiateCloseOrder` checks that `_percent > DIVISION_CONSTANT || _percent == 0`. This check is incorrect and should be `_percent > DIVISION_CONSTANT && _percent == 0` to ensure `_percent` is within the valid range."",
      ""Impact"": ""A trader can close a position with any percentage"",
      ""Location"": ""Trading.sol:initiateCloseOrder""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in Fee Distribution and Deposit/Withdraw"",
      ""Severity"": ""High"",
      ""Description"": ""The `_handleOpenFees` and `_handleCloseFees` functions call `gov.distribute`, which could potentially call back into the contract if the `gov` contract is malicious or compromised. The `_handleDeposit` and `_handleWithdraw` functions interact with stable vaults which may also allow a reentrancy attack."",
      ""Impact"": ""Possible theft of funds or denial of service if a malicious or compromised contract triggers a reentrancy attack during fee distribution or deposit/withdraw operations."",
      ""Location"": ""`_handleOpenFees`, `_handleCloseFees`, `_handleDeposit`, `_handleWithdraw` functions.""
    },
    {
      ""Issue"": ""Potential for Division by Zero in `addToPosition` if `_newMargin` is zero."",
      ""Severity"": ""High"",
      ""Description"": ""In the function `addToPosition`, a new price `_newPrice` is calculated by using `_trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin`. If `_newMargin`, calculated as `_trade.margin + _addMargin`, ever becomes zero, this calculation will result in division by zero, causing a revert. A check is needed to ensure `_newMargin` is not zero."",
      ""Impact"": ""Denial of service"",
      ""Location"": ""Trading.sol:addToPosition""
    },
    {
      ""Issue"": ""Incorrect Comparison in `removeMargin` leading to liquidation threshold issue"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `removeMargin` function, the condition `if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT))` allows removing margin even if the resulting position is below liquidation threshold due to allowing negative payouts."",
      ""Impact"": ""The contract allows removing margin even if the resulting position is below liquidation threshold, defeating the safety mechanism."",
      ""Location"": ""Trading.sol:removeMargin""
    },
    {
      ""Issue"": ""Lack of Slippage Control in `_handleWithdraw` and `_handleDeposit` Functions when Withdrawing to or depositing from a different token"",
      ""Severity"": ""Medium"",
      ""Description"": ""When withdrawing to or depositing from a token other than the base stablecoin, the contract interacts with `IStableVault` which might execute a swap on an AMM or other exchange. If the liquidity is low or the trade size is large, the user might receive significantly fewer tokens than expected due to slippage. The contract lacks any slippage control mechanism. Also can cause reverts due to `BadDeposit`."",
      ""Impact"": ""Users may receive less value than expected when withdrawing to a different token, or trades might revert due to slippage, leading to financial losses or denial of service."",
      ""Location"": ""Trading.sol:_handleWithdraw, Trading.sol:_handleDeposit""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Fee Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions, particularly `_handleOpenFees` and `_handleCloseFees`, perform arithmetic operations on fee components and position sizes using unchecked arithmetic. While `unchecked` blocks are used, integer overflow or underflow could still occur if intermediate results exceed the maximum or fall below the minimum representable value for the `uint` data type. This could lead to incorrect fee calculations and fund misallocation."",
      ""Impact"": ""Incorrect fee calculations, potentially resulting in loss of funds for the contract owner or traders."",
      ""Location"": ""Trading.sol:_handleOpenFees, Trading.sol:_handleCloseFees""
    },
    {
      ""Issue"": ""Missing input validation for `setFees` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `setFees` checks that `_daoFees >= _botFees+_referralFees*2`, but doesn't check individual fee values (daoFees, burnFees, referralFees and botFees) against DIVISION_CONSTANT which could lead to unexpected behavior in fee calculations."",
      ""Impact"": ""Incorrect fee calculation due to unexpected fees values."",
      ""Location"": ""Trading.sol:setFees""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `approveProxy`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `approveProxy` function allows a trader to authorize a proxy address to trade on their behalf until a specific timestamp and sends `msg.value` to the proxy. An attacker could potentially front-run the `approveProxy` transaction and replace the proxy address with their own address, or replace the code in the proxy before this transaction, leading to fund theft."",
      ""Impact"": ""Unauthorized trading on behalf of the victim, potentially leading to financial losses or theft of funds."",
      ""Location"": ""Trading.sol:approveProxy""
    },
    {
      ""Issue"": ""Lack of Input Validation for Leverage Multiplier"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies on the `tradingExtension.validateTrade` function to check if provided `leverage` is valid. However, the `Trading` contract does not check if the `_tradeInfo.leverage` value used in functions like `initiateMarketOrder` is reasonable before passing to `tradingExtension.validateTrade`. An attacker could set a very high leverage value and cause unexpected behavior, if `tradingExtension.validateTrade` is not implemented correctly."",
      ""Impact"": ""Unexpected behavior such as integer overflows in calculations or Denial of Service (DoS) due to high gas consumption, if the `tradingExtension` contract does not implement appropriate checks."",
      ""Location"": ""Trading.sol:initiateMarketOrder, Trading.sol:addToPosition""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `initiateMarketOrder` and other functions using `getVerifiedPrice`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `initiateMarketOrder` function (and others that call `tradingExtension.getVerifiedPrice`) relies on external price feeds to determine the trade price. Since the price data is provided externally through `PriceData` and a `_signature`, there is a window of opportunity for an attacker to front-run the transaction if they can observe the `_signature` and manipulate the order."",
      ""Impact"": ""Adverse price impact for traders, potential for attackers to profit at the expense of traders."",
      ""Location"": ""Trading.sol:initiateMarketOrder""
    },
    {
      ""Issue"": ""Missing Input Validation for `_percent` in `initiateCloseOrder` and potential division by zero in `removeMargin`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `initiateCloseOrder` checks that `_percent > DIVISION_CONSTANT || _percent == 0`, and reverts if either is true. However, there is no check that `_percent` is within a sensible range and can lead to unexpected behaviors. In the function `removeMargin`, there's no check to ensure `_newMargin` is not zero before calculating `_newLeverage`, potentially causing a division by zero."",
      ""Impact"": ""Unexpected behavior during close position, potential loss of funds due to wrong calculations, or transaction reverts due to division by zero."",
      ""Location"": ""Trading.sol:initiateCloseOrder, Trading.sol:removeMargin""
    },
    {
      ""Issue"": ""Potential DOS attack vector in `executeLimitOrder` due to GasLimit and potential frontrunning"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `executeLimitOrder` function the require(block.timestamp >= limitDelay[_id]); and tradingExtension._checkGas(); is called. If these operations fails or exceed the current Gas Limit, the whole transaction will revert, DOSing all LimitOrders. Furthermore, a malicious actor can monitor the mempool and manipulate the price within limitOrderPriceRange before execution of the transaction."",
      ""Impact"": ""All `executeLimitOrder` will revert if the gas limit is not high enough and traders may have their limit orders executed at prices less favorable than anticipated due to front-running."",
      ""Location"": ""Trading.sol:executeLimitOrder""
    },
    {
      ""Issue"": ""Missing Access Control for `_limitClose` Function of `ITradingExtension`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `limitClose` function in `Trading` contract directly calls `tradingExtension._limitClose`. There needs to be a careful assessment if the function `_limitClose` of `tradingExtension` requires a special access control or a general access control check such as `onlyOwner` in `tradingExtension`."",
      ""Impact"": ""The missing access control check of a very important function in the `tradingExtension` contract can cause security issues."",
      ""Location"": ""The `limitClose` function calling the external `tradingExtension._limitClose` function.""
    },
    {
      ""Issue"": ""Unsafe Downcasting in `_handleDeposit`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_handleDeposit` function, the code `uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());` calculates a multiplier based on the decimals of the `_marginAsset`. However, if `ExtendedIERC20(_marginAsset).decimals()` returns a value greater than 18, the result of `18-ExtendedIERC20(_marginAsset).decimals()` will underflow, leading to a very large multiplier."",
      ""Impact"": ""The contract can transfer very low amounts of tokens due to integer overflow."",
      ""Location"": ""Trading.sol:_handleDeposit""
    },
    {
      ""Issue"": ""Vulnerability in _checkDelay and blockDelay mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""The current implementation of `_checkDelay` using `blockDelayPassed` and `blockDelay` is susceptible to manipulation. An attacker can front-run legitimate transactions to update the delay and cause reverts in the subsequent legitimate transaction. Moreover, the `blockDelayPassed` mapping is unbounded."",
      ""Impact"": ""Legitimate operations can be blocked or delayed, causing financial losses or a poor user experience."",
      ""Location"": ""Trading.sol:_checkDelay""
    },
    {
      ""Issue"": ""Reliance on External Oracle for Price Data Without Sufficient Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies on an external oracle (via `tradingExtension.getVerifiedPrice`) for price data. The contract lacks detailed information on the trustworthiness and security of this external oracle. A compromised or manipulated oracle could provide incorrect price data, leading to significant financial losses for users."",
      ""Impact"": ""Potential for manipulation of trades, liquidations, and overall platform integrity if the external oracle is compromised."",
      ""Location"": ""Trading.sol:initiateMarketOrder, Trading.sol:initiateCloseOrder, Trading.sol:addToPosition, Trading.sol:removeMargin, Trading.sol:updateTpSl, Trading.sol:executeLimitOrder, Trading.sol:liquidatePosition""
    },
    {
      ""Issue"": ""Potential Denial of Service in `executeLimitOrder` due to `tradingExtension._checkGas()`"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `executeLimitOrder` calls `tradingExtension._checkGas()` without any context on its implementation. If the `_checkGas()` function has a high gas cost or becomes more expensive over time due to changes in gas prices or state, it could potentially make `executeLimitOrder` too expensive to execute, resulting in a denial of service for limit orders."",
      ""Impact"": ""Inability to execute limit orders due to high gas costs."",
      ""Location"": ""Trading.sol:executeLimitOrder""
    },
    {
      ""Issue"": ""Lack of precision in Leverage Calculations in `addMargin` and `removeMargin`"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `addMargin` and `removeMargin` functions, the new leverage is calculated as `_trade.margin * _trade.leverage / _newMargin`. This integer division can lead to loss of precision, potentially affecting the risk profile of the position, especially for smaller positions or with higher leverage."",
      ""Impact"": ""Slight inaccuracies in leverage calculations, potentially affecting risk management."",
      ""Location"": ""Trading.sol:addMargin, Trading.sol:removeMargin""
    },
    {
      ""Issue"": ""Possible vulnerability in `approveProxy`"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `approveProxy` allows any user to call it by paying fees. The fees will be transferred to the proxy. There\'s no specific check that this function has to be used only once by a user. So, a user could call this function many times, paying fees to the proxy without actually executing trades. Also, the timestamp could be manipulated by the user."",
      ""Impact"": ""The user could waste money by mistake or intentionally send money to a proxy address."",
      ""Location"": ""Trading.sol:approveProxy""
    },
    {
      ""Issue"": ""Inconsistent Use of Unchecked Arithmetic"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses `unchecked` arithmetic blocks in several places, but not consistently throughout the codebase. While this can optimize gas costs, it\'s crucial to ensure that the absence of overflow/underflow checks is deliberate and that all potential overflow/underflow situations are properly handled. Inconsistencies can lead to unexpected behavior and subtle bugs."",
      ""Impact"": ""Potential for inconsistent behavior and hidden bugs related to arithmetic operations."",
      ""Location"": ""Multiple locations throughout the contract""
    },
    {
      ""Issue"": ""Unbounded Loop Vulnerability in `gov.distribute` Call"",
      ""Severity"": ""Low"",
      ""Description"": ""The `gov.distribute` function is called within both `_handleOpenFees` and `_handleCloseFees`. If `gov.distribute` contains an unbounded loop or a loop that iterates based on external factors, this could potentially lead to a denial-of-service (DoS) attack by making the gas cost of these function calls unpredictable or excessively high."",
      ""Impact"": ""Potential DoS attack making it difficult or impossible to open or close positions if `gov.distribute` consumes too much gas."",
      ""Location"": ""Trading.sol:_handleOpenFees, Trading.sol:_handleCloseFees""
    },
    {
      ""Issue"": ""Race condition when checking minPos in _closePosition"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `_closePosition` has the check `if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(\""!size\"");`. The state variable `tradingExtension.minPos(_trade.tigAsset)` could change in a different transaction. If `tradingExtension.minPos(_trade.tigAsset)` increases to be greater than the result of the calculation, then a revert will occur."",
      ""Impact"": ""If `tradingExtension.minPos(_trade.tigAsset)` increases after user has initiated the closePosition, the transaction will revert."",
      ""Location"": ""Trading.sol:_closePosition""
    },
    {
      ""Issue"": ""Rounding Errors in Price Averaging During `addToPosition`"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `addToPosition` function, the new price is calculated using a weighted average: `_newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;`. Due to integer division, there might be rounding errors that accumulate over multiple additions."",
      ""Impact"": ""Slightly inaccurate price representation, potentially affecting profit/loss calculations, especially over multiple `addToPosition` calls."",
      ""Location"": ""Trading.sol:addToPosition""
    },
    {
      ""Issue"": ""Redundant check in `_closePosition`"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `_closePosition` checks that `if (_percent < DIVISION_CONSTANT) { ... }` but further inside that check, it divides by DIVISION_CONSTANT. This is logically equivalent to always doing that check."",
      ""Impact"": ""Unnecessary gas usage"",
      ""Location"": ""Trading.sol:_closePosition""
    },
    {
      ""Issue"": ""Lack of Zero-Address Checks for Critical Addresses"",
      ""Severity"": ""Low"",
      ""Description"": ""The constructor and the `setTradingExtension` function do not check for zero addresses. If any of `_position`, `_gov`, `_pairsContract` or `_ext` are set to the zero address, the contract will likely malfunction or become unusable."",
      ""Impact"": ""The contract could become unusable, leading to a loss of funds for users who have positions open."",
      ""Location"": ""Trading.sol:constructor, Trading.sol:setTradingExtension""
    },
    {
      ""Issue"": ""Missing Access Control for `approveProxy` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `approveProxy` function allows any user to approve a proxy to act on their behalf. However, there is no verification that the `_proxy` address is actually a valid proxy contract or that the `_timestamp` is a reasonable value."",
      ""Impact"": ""An attacker could potentially gain control over a user\'s positions, leading to financial losses for the user."",
      ""Location"": ""Trading.sol:approveProxy""
    },
    {
      ""Issue"": ""Inconsistent usage of division constant and vaultFundingPercent validation"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses `DIVISION_CONSTANT = 1e10` for percentage calculations. Ensure that all percentage calculations use this constant consistently and correctly. Also, there is no validation that `vaultFundingPercent` is non-negative or too high. "",
      ""Impact"": ""Potential for rounding errors and miscalculation of positions."",
      ""Location"": ""Trading.sol, Trading.sol:setFees, Trading.sol:_updateFunding""
    },
    {
      ""Issue"": ""Possible DOS due to blockDelay"",
      ""Severity"": ""Low"",
      ""Description"": ""The _checkDelay function uses block.number for delay check. If blockDelay is set to a large number, this could cause a denial of service as trades might be blocked for excessive amount of time."",
      ""Impact"": ""Trades being blocked due to excessive delay."",
      ""Location"": ""Trading.sol:_checkDelay""
    },
    {
      ""Issue"": ""Lack of Input Validation for `limitOrderPriceRange`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setLimitOrderPriceRange` function allows the owner to set the `limitOrderPriceRange`. However, there is no validation to ensure that `_range` is within a reasonable limit. Setting an excessively large `limitOrderPriceRange` could allow limit orders to be executed at significantly different prices than intended, potentially disadvantaging traders."",
      ""Impact"": ""Traders may experience unexpected execution prices for limit orders if the `limitOrderPriceRange` is set too high."",
      ""Location"": ""Trading.sol:setLimitOrderPriceRange""
    },
    {
      ""Issue"": ""Lack of access control for important state variables"",
      ""Severity"": ""Low"",
      ""Description"": ""Important state variables such as the `liqPercent` constant are not configurable. If the constant value is not properly calibrated, it could lead to erroneous liquidations."",
      ""Impact"": ""Potential for incorrect or unexpected behaviour when the constant values are not suitable for trading conditions."",
      ""Location"": ""Trading.sol""
    },
        {
      ""Issue"": ""Lack of Check for Zero Address in Setter Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `setTradingExtension`, `setAllowedVault` allow setting the address of an external contract. These functions do not check if the provided address is the zero address. Setting the zero address may cause unexpected behaviour in the contract and break core functionality."",
      ""Impact"": ""Unexpected behaviour or denial of service."",
      ""Location"": ""Trading.sol:setTradingExtension, Trading.sol:setAllowedVault""
    }
  ],
  ""IssueNumber"": 60,
  ""OutputList"": 30
}",298.642703056335,5739.0,36.0,"### **Comparison of Issues and Responses**

---

#### **[H-02] Riskless trades due to delay check**

**Report Description**:  
The `Trading.limitClose()` function uses `_checkDelay()`, which allows for riskless trades. Traders can capture price rises by increasing the stop-loss while preventing underwater positions from being closed by continuously increasing the delay. This creates an unfair advantage and potential financial risks for the protocol.

**Match in Response List**:  
Matches with the issue titled **""Vulnerability in _checkDelay and blockDelay mechanism""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the `_checkDelay` mechanism, explaining how it can be manipulated to delay or block legitimate transactions. This aligns with the reported vulnerability of riskless trades due to delay manipulation.

---

#### **[H-06] Incorrect calculation of new price while adding position**

**Report Description**:  
The formula used for calculating `_newPrice` in the `addToPosition()` function of `Trading.sol` is incorrect. This leads to users losing part of their funds or profits when using this function.

**Match in Response List**:  
Matches with the issue titled **""Rounding Errors in Price Averaging During `addToPosition`""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of rounding errors in the `addToPosition` function but does not explicitly address the incorrect formula mentioned in the report. The response focuses on rounding errors rather than the core issue of incorrect calculations.

---

#### **[H-09] Users can bypass the `maxWinPercent` limit using partial closing**

**Report Description**:  
Users can bypass the `maxWinPercent` limit by partially closing positions. This allows users to receive more funds than their upper limit from the protocol, leading to potential financial losses for the protocol.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The ability to bypass the `maxWinPercent` limit through partial closing is a significant vulnerability that is not covered in the responses.

---

#### **[H-11] Not enough margin pulled or burned from user when adding to a position**

**Report Description**:  
When adding to a position, the amount of margin pulled from the user is insufficient. This leaks value from the protocol and lowers the collateralization ratio of `tigAsset`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The insufficient margin calculation is a critical vulnerability that is not covered in the responses.

---

#### **[M-04] Approved operators of Position token can't call Trading.initiateCloseOrder**

**Report Description**:  
Approved operators of the owner of a Position token cannot call several functions in `Trading`, including `initiateCloseOrder`. This is because functions that accept Position tokens check that the caller is the owner using the `_checkOwner` function.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The lack of access for approved operators is a significant oversight that is not covered in the responses.

---

#### **[M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`**

**Report Description**:  
The formula for `_feePaid` in the `_handleOpenFees` function is incorrect, leading to incorrect margin calculations. This directly impacts trader margins and associated fee calculations, posing a high risk.

**Match in Response List**:  
Matches with the issue titled **""Potential Integer Overflow/Underflow in Fee Calculations""**.

**Validation**:  
**Partially Correct**. The response identifies potential integer overflow/underflow in fee calculations but does not explicitly address the incorrect formula for `_feePaid` mentioned in the report. The response focuses on arithmetic issues rather than the core issue of incorrect fee calculations.

---

#### **[M-12] Centralization risks: owner can freeze withdraws and use timelock to steal all funds**

**Report Description**:  
The owner can freeze withdrawals and use a timelock to steal all funds, posing a significant centralization risk.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The centralization risk of the owner freezing withdrawals and stealing funds is a critical vulnerability that is not covered in the responses.

---

#### **[M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()**

**Report Description**:  
The open price of a stop order might change during execution, but the function does not validate StopLoss/TakeProfit for the changed price, leading to potential financial losses.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The lack of validation for StopLoss/TakeProfit after price changes is a significant vulnerability that is not covered in the responses.

---

#### **[M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18**

**Report Description**:  
In `Trading.sol`, deposits or withdrawals of tokens with decimals higher than 18 will always revert, leading to potential user frustration and financial losses.

**Match in Response List**:  
Matches with the issue titled **""Unsafe Downcasting in `_handleDeposit`""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with tokens having decimals higher than 18, explaining how it can lead to unsafe downcasting and potential reverts. This aligns with the reported vulnerability.

---

#### **[M-20] Trading#initiateMarketOrder allows opening a position with more margin than expected due to `_handleOpenFees` wrong calculation when a trade is referred**

**Report Description**:  
When `initiateMarketOrder` is called, `_marginAfterFees` is calculated incorrectly when a trade is referred, allowing users to open a position with more margin than expected.

**Match in Response List**:  
Matches with the issue titled **""Potential Integer Overflow/Underflow in Fee Calculations""**.

**Validation**:  
**Partially Correct**. The response identifies potential integer overflow/underflow in fee calculations but does not explicitly address the incorrect calculation of `_marginAfterFees` mentioned in the report. The response focuses on arithmetic issues rather than the core issue of incorrect margin calculations.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] Riskless trades due to delay check**
- **[M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18**

**Partially Correct Matches**:

- **[H-06] Incorrect calculation of new price while adding position**
- **[M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`**
- **[M-20] Trading#initiateMarketOrder allows opening a position with more margin than expected due to `_handleOpenFees` wrong calculation when a trade is referred**

**Missed Issues from Issue Report**:

- **[H-09] Users can bypass the `maxWinPercent` limit using partial closing**
- **[H-11] Not enough margin pulled or burned from user when adding to a position**
- **[M-04] Approved operators of Position token can't call Trading.initiateCloseOrder**
- **[M-12] Centralization risks: owner can freeze withdraws and use timelock to steal all funds**
- **[M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()**

--- 

The response list covers some issues but misses several critical vulnerabilities, particularly those related to access control, centralization risks, and specific calculation errors.","1. Vulnerability in _checkDelay and blockDelay mechanism  
2. Unsafe Downcasting in `_handleDeposit`","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives**:
   - ""Vulnerability in _checkDelay and blockDelay mechanism"" appears at rank **18**.
   - ""Unsafe Downcasting in `_handleDeposit`"" appears at rank **17**.

2. **Calculate the precision at each rank**:
   - For rank 17: \( P@17 = \frac{1}{17} \approx 0.0588 \)
   - For rank 18: \( P@18 = \frac{2}{18} \approx 0.1111 \)

3. **Compute the Average Precision (AP)**:
   \[
   AP = \frac{0.0588 + 0.1111}{2} \approx 0.08495
   \]

**Average Precision (AP)**: 0.085"
