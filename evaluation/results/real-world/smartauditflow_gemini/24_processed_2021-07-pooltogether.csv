nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
SwappableYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.7.6;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";
import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""./access/AssetManager.sol"";

/// @title Swappable yield source contract to allow a PoolTogether prize pool to swap between different yield sources.
/// @dev This contract adheres to the PoolTogether yield source interface.
/// @dev This contract inherits AssetManager which extends OwnableUpgradable.
/// @notice Swappable yield source for a PoolTogether prize pool that generates yield by depositing into the specified yield source.
contract SwappableYieldSource is ERC20Upgradeable, IYieldSource, AssetManager, ReentrancyGuardUpgradeable {
  using SafeMathUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;

  /// @notice Emitted when the swappable yield source is initialized.
  /// @param yieldSource Address of yield source used to initialize this swappable yield source.
  /// @param decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.
  /// @param symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).
  /// @param name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).
  /// @param owner Swappable yield source owner.
  event SwappableYieldSourceInitialized(
    IYieldSource indexed yieldSource,
    uint8 decimals,
    string symbol,
    string name,
    address indexed owner
  );

  /// @notice Emitted when a yield source has been successfuly set.
  /// @param yieldSource Yield source address that was set.
  event SwappableYieldSourceSet(
    IYieldSource indexed yieldSource
  );

  /// @notice Emitted when funds are successfully transferred from specified yield source to current yield source.
  /// @param yieldSource Yield source address that provided funds.
  /// @param amount Amount of funds transferred.
  event FundsTransferred(
    IYieldSource indexed yieldSource,
    uint256 amount
  );

  /// @notice Emitted when ERC20 tokens other than yield source's tokens are withdrawn from the swappable yield source.
  /// @param from Address that transferred funds.
  /// @param to Address that received funds.
  /// @param amount Amount of tokens transferred.
  /// @param token ERC20 token transferred.
  event TransferredERC20(
    address indexed from,
    address indexed to,
    uint256 amount,
    IERC20Upgradeable indexed token
  );

  /// @notice Yield source interface.
  IYieldSource public yieldSource;

  /// @notice Mock Initializer to initialize implementations used by minimal proxies.
  function freeze() public initializer {
    //no-op
  }

  /// @notice Hack to determine if address passed is an actual yield source.
  /// @dev If depositTokenAddressData.length is not superior to 0, then staticcall didn't return any data.
  /// @param _yieldSource Yield source address to check.
  function _requireYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(0), ""SwappableYieldSource/yieldSource-not-zero-address"");

    (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));

    bool isInvalidYieldSource;

    if (depositTokenAddressData.length > 0) {
      (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));

      isInvalidYieldSource = depositTokenAddress != address(0);
    }

    require(isInvalidYieldSource, ""SwappableYieldSource/invalid-yield-source"");
  }

  /// @notice Initializes the swappable yield source with the yieldSource address provided.
  /// @dev We approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI), to save gas for future calls.
  /// @param _yieldSource Yield source address used to initialize this swappable yield source.
  /// @param _decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.
  /// @param _symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).
  /// @param _name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).
  /// @param _owner Swappable yield source owner.
  /// @return true if operation is successful.
  function initialize(
    IYieldSource _yieldSource,
    uint8 _decimals,
    string calldata _symbol,
    string calldata _name,
    address _owner
  ) public initializer returns (bool) {
    _requireYieldSource(_yieldSource);
    yieldSource = _yieldSource;

    __Ownable_init();

    require(_owner != address(0), ""SwappableYieldSource/owner-not-zero-address"");
    transferOwnership(_owner);

    __ReentrancyGuard_init();

    __ERC20_init(_name, _symbol);
    require(_decimals > 0, ""SwappableYieldSource/decimals-gt-zero"");
    _setupDecimals(_decimals);

    IERC20Upgradeable(_yieldSource.depositToken()).safeApprove(address(_yieldSource), type(uint256).max);

    emit SwappableYieldSourceInitialized(
      _yieldSource,
      _decimals,
      _symbol,
      _name,
      _owner
    );

    return true;
  }

  /// @notice Approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI).
  /// @dev Emergency function to re-approve max amount if approval amount dropped too low.
  /// @return true if operation is successful.
  function approveMaxAmount() external onlyOwner returns (bool) {
    IYieldSource _yieldSource = yieldSource;
    IERC20Upgradeable _depositToken = IERC20Upgradeable(_yieldSource.depositToken());

    uint256 allowance = _depositToken.allowance(address(this), address(_yieldSource));
    _depositToken.safeIncreaseAllowance(address(_yieldSource), type(uint256).max.sub(allowance));

    return true;
  }

  /// @notice Calculates the number of shares that should be minted or burned when a user deposit or withdraw.
  /// @param tokens Amount of tokens.
  /// @return Number of shares.
  function _tokenToShares(uint256 tokens) internal returns (uint256) {
    uint256 shares;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      shares = tokens;
    } else {
      // rate = tokens / shares
      // shares = tokens * (totalShares / swappableYieldSourceTotalSupply)
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this)));
      shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);
    }

    return shares;
  }

  /// @notice Calculates the number of tokens a user has in the yield source.
  /// @param shares Amount of shares.
  /// @return Number of tokens.
  function _sharesToToken(uint256 shares) internal returns (uint256) {
    uint256 tokens;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      tokens = shares;
    } else {
      // tokens = shares * (yieldSourceTotalSupply / totalShares)
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply);
      tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);
    }

    return tokens;
  }

  /// @notice Mint tokens to the user.
  /// @dev Shares corresponding to the number of tokens supplied are minted to user's balance.
  /// @param mintAmount Amount of asset tokens to be minted.
  /// @param to User whose balance will receive the tokens.
  function _mintShares(uint256 mintAmount, address to) internal {
    uint256 shares = _tokenToShares(mintAmount);

    require(shares > 0, ""SwappableYieldSource/shares-gt-zero"");

    _mint(to, shares);
  }

  /// @notice Burn shares from user's balance.
  /// @dev Shares corresponding to the number of tokens withdrawn are burnt from user's balance.
  /// @param burnAmount Amount of asset tokens to be burnt.
  function _burnShares(uint256 burnAmount) internal {
    uint256 shares = _tokenToShares(burnAmount);
    _burn(msg.sender, shares);
  }

  /// @notice Supplies tokens to the current yield source.  Allows assets to be supplied on other user's behalf using the `to` param.
  /// @dev Asset tokens are supplied to the yield source, then deposited into the underlying yield source (eg: Aave, Compound, etc...).
  /// @dev Shares from the yield source are minted to the swappable yield source address (this contract).
  /// @dev Shares from the swappable yield source are minted to the `to` address.
  /// @param amount Amount of `depositToken()` to be supplied.
  /// @param to User whose balance will receive the tokens.
  function supplyTokenTo(uint256 amount, address to) external override nonReentrant {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _depositToken.safeTransferFrom(msg.sender, address(this), amount);
    yieldSource.supplyTokenTo(amount, address(this));

    _mintShares(amount, to);
  }

  /// @notice Returns the ERC20 asset token used for deposits.
  /// @return ERC20 asset token address.
  function depositToken() public view override returns (address) {
    return yieldSource.depositToken();
  }

  /// @notice Returns the total balance in swappable tokens (eg: swsDAI).
  /// @return Underlying balance of swappable tokens.
  function balanceOfToken(address addr) external override returns (uint256) {
    return _sharesToToken(balanceOf(addr));
  }

  /// @notice Redeems tokens from the current yield source.
  /// @dev Shares of the swappable yield source address (this contract) are burnt from the yield source.
  /// @dev Shares of the `msg.sender` address are burnt from the swappable yield source.
  /// @param amount Amount of `depositToken()` to withdraw.
  /// @return Actual amount of tokens that were redeemed.
  function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _burnShares(amount);

    uint256 redeemableBalance = yieldSource.redeemToken(amount);
    _depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance);

    return redeemableBalance;
  }

  /// @notice Determine if passed yield source is different from current yield source.
  /// @param _yieldSource Yield source address to check.
  function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(yieldSource), ""SwappableYieldSource/same-yield-source"");
  }

  /// @notice Set new yield source.
  /// @dev After setting the new yield source, we need to approve it to spend maxUint256 amount of depositToken (eg: DAI).
  /// @param _newYieldSource New yield source address to set.
  function _setYieldSource(IYieldSource _newYieldSource) internal {
    _requireDifferentYieldSource(_newYieldSource);
    require(_newYieldSource.depositToken() == yieldSource.depositToken(), ""SwappableYieldSource/different-deposit-token"");

    yieldSource = _newYieldSource;
    IERC20Upgradeable(_newYieldSource.depositToken()).safeApprove(address(_newYieldSource), type(uint256).max);

    emit SwappableYieldSourceSet(_newYieldSource);
  }

  /// @notice Set new yield source.
  /// @dev This function is only callable by the owner or asset manager.
  /// @param _newYieldSource New yield source address to set.
  /// @return true if operation is successful.
  function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    _setYieldSource(_newYieldSource);
    return true;
  }

  /// @notice Transfer funds from specified yield source to current yield source.
  /// @dev We check that the `currentBalance` transferred is at least equal or superior to the `amount` requested.
  /// @dev `currentBalance` can be superior to `amount` if yield has been accruing between redeeming and checking for a mathematical error.
  /// @param _yieldSource Yield source address to transfer funds from.
  /// @param _amount Amount of funds to transfer from passed yield source to current yield source.
  function _transferFunds(IYieldSource _yieldSource, uint256 _amount) internal {
    IYieldSource _currentYieldSource = yieldSource;

    _yieldSource.redeemToken(_amount);
    uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));

    require(_amount <= currentBalance, ""SwappableYieldSource/transfer-amount-different"");

    _currentYieldSource.supplyTokenTo(currentBalance, address(this));

    emit FundsTransferred(_yieldSource, _amount);
  }

  /// @notice Transfer funds from specified yield source to current yield source.
  /// @dev We only verify it is a different yield source in the public function cause we already check for it in `_setYieldSource` function.
  /// @param _yieldSource Yield source address to transfer funds from.
  /// @param amount Amount of funds to transfer from passed yield source to current yield source.
  /// @return true if operation is successful.
  function transferFunds(IYieldSource _yieldSource, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    _requireDifferentYieldSource(_yieldSource);
    _transferFunds(_yieldSource, amount);
    return true;
  }

  /// @notice Swap current yield source for new yield source.
  /// @dev This function is only callable by the owner or asset manager.
  /// @dev We set a new yield source and then transfer funds from the now previous yield source to the new current yield source.
  /// @param _newYieldSource New yield source address to set and transfer funds to.
  /// @return true if operation is successful.
  function swapYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    IYieldSource _currentYieldSource = yieldSource;
    uint256 balance = _currentYieldSource.balanceOfToken(address(this));

    _setYieldSource(_newYieldSource);
    _transferFunds(_currentYieldSource, balance);

    return true;
  }

  /// @notice Transfer ERC20 tokens other than the yield source's tokens held by this contract to the recipient address.
  /// @dev This function is only callable by the owner or asset manager.
  /// @param erc20Token ERC20 token to transfer.
  /// @param to Recipient of the tokens.
  /// @param amount Amount of tokens to transfer.
  /// @return true if operation is successful.
  function transferERC20(IERC20Upgradeable erc20Token, address to, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    require(address(erc20Token) != address(yieldSource), ""SwappableYieldSource/yield-source-token-transfer-not-allowed"");
    erc20Token.safeTransfer(to, amount);
    emit TransferredERC20(msg.sender, to, amount, erc20Token);
    return true;
  }
}

",3524,331,"[H-01] onlyOwnerOrAssetManager can swap Yield Source in SwappableYieldSource at any time, immediately rugging all funds from old yield source

The function `swapYieldSource` SwappableYieldSource.sol` L307
Can be called by the owner (deployer / initializer) or Asset Manager. The function will take all funds from the old Yield Source, and transfer them to the new Yield source. Any contract that implement the function function depositToken() external returns (address) will pass the check
However, if either the owner or the assetManager have malicious intent, this function allows them to instantly rug all funds
Create a contract that implements the function depositToken() external returns (address)
Be the Owner or AssetManager
Call setYieldSource while pointing at your malicious contract
Profit
 [H-02] redeemToken can fail for certain tokens
The `SwappableYieldSource.redeemToken` function transfers tokens from the contract back to the sender, however, it uses the ERC20.transferFrom(address(this), msg.sender, redeemableBalance) function for this. Some deposit token implementations might fail as transferFrom checks if the contract approved itself for the redeemableBalance instead of skipping the allowance check in case the sender is the from address.  [H-03] setYieldSource leads to temporary wrong results
 The use of `setYieldSource` leaves the contract in a temporary inconsistent state because it changes the underlying yield source, but doesn't (yet) transfer the underlying balances, while the shares stay the same.
The function balanceOfToken will show the wrong results, because it is based on _sharesToToken, which uses yieldSource.balanceOfToken(address(this)), that isn't updated yet.
More importantly supplyTokenTo will give the wrong amount of shares back: First it supplies tokens to the yieldsource. Then is calls _mintShares, which calls _tokenToShares, which calculates the shares, using yieldSource.balanceOfToken(address(this)) This yieldSource.balanceOfToken(address(this)) only contains the just supplied tokens, but doesn't include the tokens from the previous YieldSource. So the wrong amount of shares is given back to the user; they will be given more shares than appropriate which means they can drain funds later on (once transferFunds has been done).
  [H-04] SwappableYieldSource: Missing same deposit token check in transferFunds()
 `transferFunds()` will transfer funds from a specified yield source _yieldSource to the current yield source set in the contract _currentYieldSource. However, it fails to check that the deposit tokens are the same. If the specified yield source's assets are of a higher valuation, then a malicious owner or asset manager will be able to exploit and pocket the difference.  [M-01] Single-step process for critical ownership transfer/renounce is risky
 The `SwappableYieldSource` allows owners and asset managers to set/swap/transfer yield sources/funds. As such, the contract ownership plays a critical role in the protocol.
Given that AssetManager is derived from Ownable, the ownership management of this contract defaults to Ownable’s transferOwnership() and renounceOwnership() methods which are not overridden here. Such critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.  [M-02] Use of `safeApprove` will always cause `approveMax` to revert

Unlike SwappableYieldSource which uses safeIncreaseAllowance to increase the allowance to uint256.max, mStableYieldSource uses OpenZeppelin’s safeApprove() which has been documented as (1) Deprecated because of approve-like race condition and (2) To be used only for initial setting of allowance (current allowance == 0) or resetting to 0 because it reverts otherwise.
The usage here is intended to allow increase of allowance when it falls low similar to the documented usage in SwappableYieldSource. Using it for that scenario will not work as expected because it will always revert if current allowance is != 0. The initial allowance is already set as uint256.max in constructor. And once it gets reduced, it can never be increased using this function unless it is invoked when allowance is reduced completely to 0. See issue page for referenced code.

[M-03] Inconsistent balance when supplying transfer-on-fee or deflationary tokens

The supplyTokenTo function of SwappableYieldSource assumes that amount of _depositToken is transferred to itself after calling the safeTransferFrom function (and thus it supplies amount of token to the yield source). However, this may not be true if the _depositToken is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount. SwappableYieldSource.sol L211-L212  [M-04] Old yield source still has infinite approval
 After swapping a yield source, the old yield source still has infinite approval. Infinite approval has been used in large attacks if the yield source isn't perfectly safe (see furucombo).

",8,,"pragma solidity 0.7.6;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";
import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""./access/AssetManager.sol"";





contract SwappableYieldSource is ERC20Upgradeable, IYieldSource, AssetManager, ReentrancyGuardUpgradeable {
  using SafeMathUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;

  
  
  
  
  
  
  event SwappableYieldSourceInitialized(
    IYieldSource indexed yieldSource,
    uint8 decimals,
    string symbol,
    string name,
    address indexed owner
  );

  
  
  event SwappableYieldSourceSet(
    IYieldSource indexed yieldSource
  );

  
  
  
  event FundsTransferred(
    IYieldSource indexed yieldSource,
    uint256 amount
  );

  
  
  
  
  
  event TransferredERC20(
    address indexed from,
    address indexed to,
    uint256 amount,
    IERC20Upgradeable indexed token
  );

  
  IYieldSource public yieldSource;

  
  function freeze() public initializer {
    
  }

  
  
  
  function _requireYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(0), ""SwappableYieldSource/yieldSource-not-zero-address"");

    (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));

    bool isInvalidYieldSource;

    if (depositTokenAddressData.length > 0) {
      (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));

      isInvalidYieldSource = depositTokenAddress != address(0);
    }

    require(isInvalidYieldSource, ""SwappableYieldSource/invalid-yield-source"");
  }

  
  
  
  
  
  
  
  
  function initialize(
    IYieldSource _yieldSource,
    uint8 _decimals,
    string calldata _symbol,
    string calldata _name,
    address _owner
  ) public initializer returns (bool) {
    _requireYieldSource(_yieldSource);
    yieldSource = _yieldSource;

    __Ownable_init();

    require(_owner != address(0), ""SwappableYieldSource/owner-not-zero-address"");
    transferOwnership(_owner);

    __ReentrancyGuard_init();

    __ERC20_init(_name, _symbol);
    require(_decimals > 0, ""SwappableYieldSource/decimals-gt-zero"");
    _setupDecimals(_decimals);

    IERC20Upgradeable(_yieldSource.depositToken()).safeApprove(address(_yieldSource), type(uint256).max);

    emit SwappableYieldSourceInitialized(
      _yieldSource,
      _decimals,
      _symbol,
      _name,
      _owner
    );

    return true;
  }

  
  
  
  function approveMaxAmount() external onlyOwner returns (bool) {
    IYieldSource _yieldSource = yieldSource;
    IERC20Upgradeable _depositToken = IERC20Upgradeable(_yieldSource.depositToken());

    uint256 allowance = _depositToken.allowance(address(this), address(_yieldSource));
    _depositToken.safeIncreaseAllowance(address(_yieldSource), type(uint256).max.sub(allowance));

    return true;
  }

  
  
  
  function _tokenToShares(uint256 tokens) internal returns (uint256) {
    uint256 shares;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      shares = tokens;
    } else {
      
      
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this)));
      shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);
    }

    return shares;
  }

  
  
  
  function _sharesToToken(uint256 shares) internal returns (uint256) {
    uint256 tokens;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      tokens = shares;
    } else {
      
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply);
      tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);
    }

    return tokens;
  }

  
  
  
  
  function _mintShares(uint256 mintAmount, address to) internal {
    uint256 shares = _tokenToShares(mintAmount);

    require(shares > 0, ""SwappableYieldSource/shares-gt-zero"");

    _mint(to, shares);
  }

  
  
  
  function _burnShares(uint256 burnAmount) internal {
    uint256 shares = _tokenToShares(burnAmount);
    _burn(msg.sender, shares);
  }

  
  
  
  
  
  
  function supplyTokenTo(uint256 amount, address to) external override nonReentrant {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _depositToken.safeTransferFrom(msg.sender, address(this), amount);
    yieldSource.supplyTokenTo(amount, address(this));

    _mintShares(amount, to);
  }

  
  
  function depositToken() public view override returns (address) {
    return yieldSource.depositToken();
  }

  
  
  function balanceOfToken(address addr) external override returns (uint256) {
    return _sharesToToken(balanceOf(addr));
  }

  
  
  
  
  
  function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _burnShares(amount);

    uint256 redeemableBalance = yieldSource.redeemToken(amount);
    _depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance);

    return redeemableBalance;
  }

  
  
  function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(yieldSource), ""SwappableYieldSource/same-yield-source"");
  }

  
  
  
  function _setYieldSource(IYieldSource _newYieldSource) internal {
    _requireDifferentYieldSource(_newYieldSource);
    require(_newYieldSource.depositToken() == yieldSource.depositToken(), ""SwappableYieldSource/different-deposit-token"");

    yieldSource = _newYieldSource;
    IERC20Upgradeable(_newYieldSource.depositToken()).safeApprove(address(_newYieldSource), type(uint256).max);

    emit SwappableYieldSourceSet(_newYieldSource);
  }

  
  
  
  
  function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    _setYieldSource(_newYieldSource);
    return true;
  }

  
  
  
  
  
  function _transferFunds(IYieldSource _yieldSource, uint256 _amount) internal {
    IYieldSource _currentYieldSource = yieldSource;

    _yieldSource.redeemToken(_amount);
    uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));

    require(_amount <= currentBalance, ""SwappableYieldSource/transfer-amount-different"");

    _currentYieldSource.supplyTokenTo(currentBalance, address(this));

    emit FundsTransferred(_yieldSource, _amount);
  }

  
  
  
  
  
  function transferFunds(IYieldSource _yieldSource, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    _requireDifferentYieldSource(_yieldSource);
    _transferFunds(_yieldSource, amount);
    return true;
  }

  
  
  
  
  
  function swapYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    IYieldSource _currentYieldSource = yieldSource;
    uint256 balance = _currentYieldSource.balanceOfToken(address(this));

    _setYieldSource(_newYieldSource);
    _transferFunds(_currentYieldSource, balance);

    return true;
  }

  
  
  
  
  
  
  function transferERC20(IERC20Upgradeable erc20Token, address to, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    require(address(erc20Token) != address(yieldSource), ""SwappableYieldSource/yield-source-token-transfer-not-allowed"");
    erc20Token.safeTransfer(to, amount);
    emit TransferredERC20(msg.sender, to, amount, erc20Token);
    return true;
  }
}",1938,4,4,"{
  ""task_list"": [
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Verify that the `nonReentrant` modifier is correctly applied to all external functions that modify state, including `supplyTokenTo` and `redeemToken`."",
        ""Analyze the potential for reentrancy in the `yieldSource.supplyTokenTo` and `yieldSource.redeemToken` calls. Could a malicious yield source re-enter the SwappableYieldSource contract during these calls?"",
        ""Examine the interaction between `_mintShares` and `_burnShares` and the potential for reentrancy if the `yieldSource` is malicious and has control over shares."",
        ""Confirm that no internal functions called by the nonReentrant functions, directly or indirectly, make external calls that could lead to reentrancy.""
      ]
    },
    {
      ""Area"": ""Access Control and Authorization"",
      ""Tasks"": [
        ""Thoroughly review the implementation of `AssetManager` contract to understand how asset managers are added, removed, and what permissions they have."",
        ""Verify that the `onlyOwnerOrAssetManager` modifier correctly restricts access to sensitive functions like `setYieldSource`, `transferFunds`, `swapYieldSource`, and `transferERC20`."",
        ""Check the impact of incorrect `owner` initialization. Test the contract when `_owner` parameter in `initialize()` is the zero address, despite the require statement, to observe behavior."",
        ""Analyze the permissioning logic of the underlying yield source. Can the SwappableYieldSource owner or asset manager inadvertently grant excessive permissions to the yield source contract itself?"",
        ""Investigate potential attacks where a malicious asset manager could drain funds by setting a malicious yield source or transferring ERC20 tokens."",
        ""Evaluate if the `transferOwnership` function in `OwnableUpgradeable` is adequately protected and cannot be abused."",
        ""Verify proper initialization of access control roles during contract deployment and upgrades. Is there a risk of uninitialized roles granting unintended access?""
      ]
    },
    {
      ""Area"": ""Yield Source Validation and Trust Assumptions"",
      ""Tasks"": [
        ""Critically assess the `_requireYieldSource` function's effectiveness. Is simply checking for a non-zero deposit token address sufficient to prevent the use of malicious or incorrectly implemented yield sources?"",
        ""Develop test cases using different types of malicious or faulty `IYieldSource` contracts to assess the robustness of the `SwappableYieldSource` contract."",
        ""Consider whether the `_requireYieldSource` function should also validate other key properties or behaviors of the `IYieldSource` interface to ensure it functions as expected."",
        ""Analyze the potential risks if the underlying `yieldSource` contract is compromised after being set. How can the `SwappableYieldSource` contract owner or asset manager mitigate these risks?"",
        ""Investigate the impact of the `yieldSource` ceasing to function or becoming non-compliant. Can funds be withdrawn safely, and can the contract be gracefully shut down?"",
        ""Check for compatibility issues between different YieldSource implementations and how they might affect the SwappableYieldSource's functionality."",
        ""Verify that the YieldSource is ERC20 compatible and if there might be unexpected behaviour due to corner cases. Check transfer/transferFrom return values, and whether the token supports zero-amount transfers.""
      ]
    },
    {
      ""Area"": ""Tokenomics and Share Calculation"",
      ""Tasks"": [
        ""Analyze the potential for rounding errors or precision loss in the `_tokenToShares` and `_sharesToToken` functions, which utilize the `FixedPoint` library. Determine the maximum possible discrepancy and its impact on users."",
        ""Develop test cases to simulate a wide range of deposit amounts, total supply values, and yield source balances to identify any scenarios where the share calculation is inaccurate or unfair."",
        ""Evaluate whether the `FixedPoint` library is the most appropriate choice for this application. Consider alternative approaches that may offer better precision or gas efficiency."",
        ""Verify correct handling of edge cases in share calculations, especially when the total supply is very small or very large."",
        ""Assess the risk of manipulating share prices by artificially inflating or deflating the yield source balance or total supply."",
        ""Investigate if there is a possibility of share price manipulation using flash loans."",
        ""Consider the impact of extreme changes in the underlying asset's value on the share price and user perception."",
        ""Analyze gas costs associated with FixedPoint math, compare with alternatives (if any), and suggest optimizations.""
      ]
    },
    {
      ""Area"": ""Fund Transfer and Yield Source Swapping"",
      ""Tasks"": [
        ""Analyze the potential race condition in the `transferFunds` and `swapYieldSource` functions if deposit tokens are transferred directly to the `SwappableYieldSource` contract (not via `supplyTokenTo`) between redeeming from the old source and supplying to the new source."",
        ""Verify that the `require(_amount <= currentBalance, ...)` check in `_transferFunds` is sufficient to prevent unexpected behavior in cases of external token transfers."",
        ""Develop test cases to simulate scenarios where the contract receives unexpected token transfers and assess the impact on the fund transfer process."",
        ""Ensure that events are emitted appropriately during fund transfers and yield source swaps, providing clear audit trails."",
        ""Evaluate the gas costs associated with the yield source swapping process and identify potential optimizations."",
        ""Check the handling of yield accrued during the transfer process. Is the yield transferred to the new yield source correctly?"",
        ""Verify that approvals for deposit tokens are properly managed when swapping yield sources, avoiding potential double-spending or insufficient allowance issues."",
        ""Assess potential griefing attacks, for example, an attacker frontrunning a `swapYieldSource` call by donating a small amount of depositToken. The transfer from the previous yieldSource will then fail (due to insufficient funds after the donation) and the swap will be reverted, effectively DoSing the contract.""
      ]
    },
    {
      ""Area"": ""ERC20 Compliance and Token Transfer"",
      ""Tasks"": [
        ""Verify that the `SwappableYieldSource` contract adheres to the ERC20 standard, including proper event emission and return values for token transfer functions."",
        ""Analyze the `transferERC20` function and ensure that it cannot be used to transfer the deposit token of the current `yieldSource`. Ensure the check `address(erc20Token) != address(yieldSource)` is correct, consider `yieldSource.depositToken()` instead."",
        ""Evaluate the potential risks if the `transferERC20` function is used to transfer tokens that are critical to the functionality of the `SwappableYieldSource` contract."",
        ""Check for any unintended side effects or vulnerabilities that could arise from transferring ERC20 tokens with unusual or non-standard behavior."",
        ""Verify that the contract correctly handles tokens with different decimal precisions."",
        ""Test the contract's behaviour with rebasing tokens and fee-on-transfer tokens, which can cause unexpected behaviour in accounting.""
      ]
    },
    {
      ""Area"": ""Initialization and Upgradeability"",
      ""Tasks"": [
        ""Verify that the `freeze()` function serves its intended purpose in preventing re-initialization of implementation contracts after deployment behind a proxy."",
        ""Analyze the initialization process to identify any potential vulnerabilities or misconfigurations that could compromise the contract's security or functionality."",
        ""Review the upgradeability strategy to ensure that it is secure and does not introduce any new risks or vulnerabilities."",
        ""Check compatibility with different proxy patterns (e.g. UUPS, Transparent Proxy).""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Review the contract code to identify opportunities to reduce gas costs, such as using more efficient data structures, caching frequently accessed values, and optimizing loop iterations."",
        ""Analyze the gas costs associated with key functions, such as `supplyTokenTo`, `redeemToken`, and `swapYieldSource`, and compare them to alternative implementations."",
        ""Consider using assembly language or other low-level optimization techniques to further reduce gas costs."",
        ""Optimize storage patterns and variable packing to minimize gas usage during contract execution."",
        ""Check if any external calls can be avoided by caching their results within the contract. Consider caching `yieldSource.depositToken()`"",
        ""Consider batching operations where possible to reduce per-operation overhead.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `SwappableYieldSource` acts as a wrapper around an underlying `IYieldSource` contract. It allows users to deposit an ERC20 token (the `depositToken` of the underlying yield source) and receive shares (represented by this contract's own ERC20 tokens). These shares represent a claim on the deposited tokens plus any yield generated by the underlying `yieldSource`. The key feature is the ability for the owner or a designated asset manager to swap the underlying `yieldSource` to a different one (using the same `depositToken`) without requiring users to withdraw and redeposit. It uses OpenZeppelin upgradeable contracts for core functionalities like ERC20, Ownable, and ReentrancyGuard, suggesting it's designed for proxy-based upgradeability. It also implements the `IYieldSource` interface itself, potentially allowing it to be nested or used where an `IYieldSource` is expected."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""SwappableYieldSource"",
    ""Purpose"": ""To abstract yield generation by wrapping an underlying `IYieldSource`, issue shares representing deposits plus yield, and allow administrative swapping of the underlying yield source."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""ERC20Upgradeable"",
        ""IYieldSource"",
        ""AssetManager"",
        ""ReentrancyGuardUpgradeable""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"",
        ""@pooltogether/fixed-point/contracts/FixedPoint.sol"",
        ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"",
        ""./access/AssetManager.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""yieldSource"",
        ""Type"": ""IYieldSource"",
        ""Purpose"": ""Stores the reference to the current underlying yield source contract.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""freeze"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Empty initializer function, potentially related to upgradeable contract patterns (e.g., preventing re-initialization of implementation contracts)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireYieldSource"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Validates a potential yield source address, ensuring it's non-zero and its `depositToken()` function returns a non-zero address."",
        ""Parameters"": [""IYieldSource _yieldSource""],
        ""Returns"": []
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract state, setting the initial yield source, owner, ERC20 properties (name, symbol, decimals), and approving the yield source."",
        ""Parameters"": [
          ""IYieldSource _yieldSource"",
          ""uint8 _decimals"",
          ""string calldata _symbol"",
          ""string calldata _name"",
          ""address _owner""
        ],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""approveMaxAmount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to grant the maximum `uint256` allowance to the current `yieldSource` contract for spending the deposit token."",
        ""Parameters"": [],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_tokenToShares"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates the number of shares to mint for a given amount of deposit tokens based on the current total supply and underlying balance."",
        ""Parameters"": [""uint256 tokens""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_sharesToToken"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates the amount of deposit tokens corresponding to a given number of shares based on the current total supply and underlying balance."",
        ""Parameters"": [""uint256 shares""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_mintShares"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Mints shares to a recipient after calculating the correct amount using `_tokenToShares`."",
        ""Parameters"": [""uint256 mintAmount"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""_burnShares"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Burns shares from the sender after calculating the correct amount using `_tokenToShares`."",
        ""Parameters"": [""uint256 burnAmount""],
        ""Returns"": []
      },
      {
        ""Name"": ""supplyTokenTo"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Handles user deposits: transfers deposit tokens from user, supplies them to the `yieldSource`, and mints shares to the recipient."",
        ""Parameters"": [""uint256 amount"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""depositToken"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the address of the deposit token used by the current `yieldSource`."",
        ""Parameters"": [],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""balanceOfToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Calculates the underlying deposit token balance corresponding to a user's share balance."",
        ""Parameters"": [""address addr""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""redeemToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Handles user withdrawals: burns user's shares, redeems corresponding tokens from `yieldSource`, and transfers tokens to the user."",
        ""Parameters"": [""uint256 amount""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_requireDifferentYieldSource"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Ensures a new yield source address is different from the current one."",
        ""Parameters"": [""IYieldSource _yieldSource""],
        ""Returns"": []
      },
      {
        ""Name"": ""_setYieldSource"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Updates the `yieldSource`, checks constraints (different source, same deposit token), grants max approval, and emits an event."",
        ""Parameters"": [""IYieldSource _newYieldSource""],
        ""Returns"": []
      },
      {
        ""Name"": ""setYieldSource"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Admin function (Owner or Asset Manager) to change the `yieldSource` without moving funds."",
        ""Parameters"": [""IYieldSource _newYieldSource""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_transferFunds"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Redeems funds from a specified (presumably old) yield source and supplies them to the *current* `yieldSource`."",
        ""Parameters"": [""IYieldSource _yieldSource"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""transferFunds"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Admin function (Owner or Asset Manager) to trigger the movement of funds from a specified yield source into the currently set one."",
        ""Parameters"": [""IYieldSource _yieldSource"", ""uint256 amount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""swapYieldSource"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Admin function (Owner or Asset Manager) to atomically change the `yieldSource` and transfer all funds from the old source to the new one."",
        ""Parameters"": [""IYieldSource _newYieldSource""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""transferERC20"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Admin function (Owner or Asset Manager) to transfer any ERC20 token (except the deposit token) held by this contract to a specified address."",
        ""Parameters"": [""IERC20Upgradeable erc20Token"", ""address to"", ""uint256 amount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""nonReentrant"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Prevents reentrancy attacks (from ReentrancyGuardUpgradeable)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyOwner"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts access to the contract owner (from OwnableUpgradeable)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyOwnerOrAssetManager"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts access to the contract owner or a designated Asset Manager (defined in AssetManager contract)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""initializer"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures a function can only be called once during initialization (from OpenZeppelin upgradeable contracts)."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Calls methods on the `IYieldSource` interface (`yieldSource` state variable): `depositToken()`, `supplyTokenTo()`, `redeemToken()`, `balanceOfToken()`."",
    ""Calls methods on the `IERC20Upgradeable` interface (deposit token): `safeApprove()`, `safeIncreaseAllowance()`, `allowance()`, `safeTransferFrom()`, `safeTransfer()`, `balanceOf()`."",
    ""Calls methods on the `IERC20Upgradeable` interface (arbitrary ERC20 via `transferERC20`): `safeTransfer()`."",
    ""Uses the `FixedPoint` library for share calculations."",
    ""Inherits from and potentially calls functions within OpenZeppelin upgradeable contracts (`OwnableUpgradeable`, `ERC20Upgradeable`, `ReentrancyGuardUpgradeable`)."",
    ""Inherits from `AssetManager`, relying on its access control logic (specifically the `onlyOwnerOrAssetManager` modifier).""
  ],
  ""SpecialMechanisms"": [
    ""**Yield Source Swapping:** The core feature allowing the underlying yield strategy to be changed administratively (`setYieldSource`, `transferFunds`, `swapYieldSource`)."",
    ""**LP Tokenization:** The contract itself is an ERC20 token, representing shares in the pooled deposits and yield."",
    ""**Upgradeable Contract Structure:** Uses OpenZeppelin upgradeable contracts and `initializer` modifiers, indicating deployment behind a proxy."",
    ""**Dual Access Control:** Utilizes both `onlyOwner` (from Ownable) and a custom `onlyOwnerOrAssetManager` (from `AssetManager`) for different functions."",
    ""**Reentrancy Protection:** Uses `nonReentrant` modifier on external state-changing functions (`supplyTokenTo`, `redeemToken`)."",
    ""**FixedPoint Math:** Employs the `FixedPoint` library for potentially precise share/token conversions."",
    ""**Staticcall Validation:** Uses `staticcall` in `_requireYieldSource` for read-only validation of external contract properties.""
  ],
  ""Questions"": [
    ""What is the specific implementation of the `AssetManager` contract and the permissions granted by the `onlyOwnerOrAssetManager` modifier?"",
    ""Why is the `freeze()` function defined as an empty initializer? Is it intended for disabling initializers in implementation contracts post-deployment via proxy?"",
    ""Are potential rounding errors or precision loss in the `FixedPoint` calculations, especially `_tokenToShares` and `_sharesToToken`, considered acceptable? How sensitive is the system to minor discrepancies between calculated shares and actual underlying value?"",
    ""Could the `transferFunds` or `swapYieldSource` functions be problematic if the contract receives deposit tokens directly (not via `supplyTokenTo`) between redeeming from the old source and supplying to the new source?"",
    ""The `_requireYieldSource` only checks `depositToken()` returns non-zero. Does the `IYieldSource` interface sufficiently guarantee that any conforming contract will work correctly, or could setting an improperly implemented `IYieldSource` cause issues despite passing this check?"",
    ""Is there protection against the `yieldSource` contract becoming malicious or non-functional after being set?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Incorrect Logic in `_requireYieldSource` Validation"",
      ""Severity"": ""High"",
      ""Description"": ""The `_requireYieldSource` function aims to validate a potential yield source by checking its `depositToken` address. However, the validation logic is consistently reported as flawed and inverted across multiple analyses. The check `isInvalidYieldSource = depositTokenAddress != address(0);` combined with `require(isInvalidYieldSource, ...)` effectively requires a *non-zero* deposit token address to consider the source *invalid*. This is the opposite of the likely intention, which should be to ensure the `depositToken` address is *not* the zero address for a *valid* source. Furthermore, the check might be skipped entirely if the external call to retrieve the deposit token reverts or returns empty data (`depositTokenAddressData.length == 0`)."",
      ""Impact"": ""This critical flaw allows invalid or malicious contracts (potentially those without a valid deposit token or returning zero) to be set as the `yieldSource`. Interacting with such a source could lead to unpredictable behavior, denial of service, transaction reverts, or potential loss of funds."",
      ""Location"": ""Function `_requireYieldSource` (e.g., SwappableYieldSource.sol:49-61, 59-69)""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerabilities"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions interact with external `yieldSource` contracts (`redeemToken`, `supplyTokenTo`, `transferFunds`, `swapYieldSource`) or arbitrary ERC20 recipients (`transferERC20`). While the contract uses `ReentrancyGuardUpgradeable` and applies the `nonReentrant` modifier to some functions (like `redeemToken`, `supplyTokenTo`), this protection does *not* extend to calls made *by* the external `yieldSource` back into the `SwappableYieldSource` contract (cross-contract reentrancy) during operations like `yieldSource.redeemToken()` or `yieldSource.supplyTokenTo()`. If the `yieldSource` is malicious or compromised, it could call back into `SwappableYieldSource` before the initial operation completes (e.g., before tokens are transferred out in `redeemToken` or after tokens are received but before supply in `supplyTokenTo`), potentially manipulating state, draining funds, or causing incorrect share calculations. The `transferERC20` function also lacks reentrancy protection, posing a risk if transferring to a malicious contract."",
      ""Impact"": ""A malicious yield source or token recipient could exploit reentrancy to drain funds from the `SwappableYieldSource` contract, manipulate share accounting, or cause other unexpected and harmful state changes."",
      ""Location"": ""Functions `redeemToken` (e.g., SwappableYieldSource.sol:155-160, 206, 188), `supplyTokenTo` (e.g., SwappableYieldSource.sol:146, 184), `transferFunds`, `swapYieldSource`, `transferERC20`""
    },
    {
      ""Issue"": ""Unsafe Maximum Approval and Allowance Management"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `initialize`, `setYieldSource`, and `approveMaxAmount` functions grant the `yieldSource` contract an allowance of `type(uint256).max` for the deposit token using `safeApprove` or `safeIncreaseAllowance`. While `safeApprove` mitigates some re-approval risks, granting maximum allowance poses a significant security risk: if the `yieldSource` contract is malicious or becomes compromised, it can drain the entire balance of the deposit token held by `SwappableYieldSource`. Furthermore, when a new yield source is set via `setYieldSource` or `swapYieldSource`, the allowance granted to the *previous* yield source is not revoked (set to zero). This means multiple yield sources (including potentially old, compromised ones) could retain unlimited spending approval."",
      ""Impact"": ""A compromised or malicious yield source (current or previous) could drain all deposit tokens held by the `SwappableYieldSource` contract. Granting maximum allowance is an unnecessarily broad permission."",
      ""Location"": ""Functions `initialize` (e.g., SwappableYieldSource.sol:82, 97), `setYieldSource` (e.g., SwappableYieldSource.sol:193), `_setYieldSource`, `swapYieldSource`, `approveMaxAmount` (e.g., SwappableYieldSource.sol:95, 108)""
    },
    {
      ""Issue"": ""Incorrect Share Calculation or Reliance on Yield Source Balance"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `_mintShares` and `_burnShares` rely on `_tokenToShares` and `_sharesToToken` for conversion. These conversion functions calculate the exchange rate based on the current total supply of shares and the token balance reported by the `yieldSource` (`yieldSource.balanceOfToken(address(this))`). If the `yieldSource` can manipulate the reported balance or if there are precision/rounding errors in the `FixedPoint` arithmetic used, the calculated exchange rate can be incorrect. This could allow users to mint more shares than their deposit warrants or redeem more tokens than their shares represent."",
      ""Impact"": ""Incorrect share calculation can lead to an unfair distribution of underlying tokens, potential economic exploitation by manipulating the apparent balance, loss of funds for legitimate users, and accounting discrepancies within the contract."",
      ""Location"": ""Functions `_mintShares`, `_burnShares`, `_tokenToShares` (e.g., SwappableYieldSource.sol:122-130, 120), `_sharesToToken` (e.g., SwappableYieldSource.sol:138-142, 138)""
    },
    {
      ""Issue"": ""Missing Input Validation for Amounts"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions that handle token amounts lack explicit checks for non-zero values or other necessary bounds. Specifically, `transferFunds` (and `_transferFunds`) does not validate that the `_amount` to transfer is greater than zero or potentially feasible given the source balance before attempting redemption. Similarly, `supplyTokenTo` and `redeemToken` lack checks for zero `amount`."",
      ""Impact"": ""Calling these functions with zero amounts leads to unnecessary gas consumption and potentially unexpected behavior or reverts in the external `yieldSource` contract if it doesn't handle zero amounts correctly. For `transferFunds`, providing an unreasonably large amount could cause reverts during redemption."",
      ""Location"": ""Functions `transferFunds` (e.g., SwappableYieldSource.sol:260), `_transferFunds`, `supplyTokenTo` (e.g., SwappableYieldSource.sol:146), `redeemToken` (e.g., SwappableYieldSource.sol:155)""
    },
    {
      ""Issue"": ""Missing Slippage Control in `redeemToken`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `redeemToken` function calculates the amount to redeem based on shares but does not allow the user to specify a minimum acceptable amount of tokens to receive. It simply calls `yieldSource.redeemToken(amount)` and transfers whatever `redeemableBalance` is returned. If the exchange rate within the `yieldSource` changes negatively between transaction submission and execution (slippage), the user might receive significantly fewer tokens than expected."",
      ""Impact"": ""Users may suffer financial loss due to unfavorable price movements (slippage) during redemption, receiving fewer tokens than anticipated."",
      ""Location"": ""Function `redeemToken` (e.g., SwappableYieldSource.sol:155-160)""
    },
    {
      ""Issue"": ""Potential Rounding Errors in Share/Token Conversion"",
      ""Severity"": ""Low"",
      ""Description"": ""The use of `FixedPoint` arithmetic in `_tokenToShares` and `_sharesToToken` for converting between deposit tokens and shares can introduce small rounding errors. While generally minor, these errors can accumulate over time with many transactions or large value differences, potentially leading to slight discrepancies in accounting or value representation."",
      ""Impact"": ""Minor value drift or accounting inaccuracies may occur over time, potentially disadvantaging users by small amounts in aggregate."",
      ""Location"": ""Functions `_tokenToShares` (e.g., SwappableYieldSource.sol:120), `_sharesToToken` (e.g., SwappableYieldSource.sol:138)""
    },
    {
      ""Issue"": ""Unnecessary `safeTransferFrom` in `redeemToken`"",
      ""Severity"": ""Low"",
      ""Description"": ""After redeeming tokens from the `yieldSource`, the `redeemToken` function uses `_depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance)` to send the tokens to the user. Since the tokens are already held by the `SwappableYieldSource` contract at this point (having been received from the redemption), a standard `_depositToken.safeTransfer(msg.sender, redeemableBalance)` is sufficient and more gas-efficient. Using `safeTransferFrom` implies a need for self-allowance, which is unnecessary here."",
      ""Impact"": ""Minor increase in gas costs for redemption transactions due to the unnecessary `safeTransferFrom` logic."",
      ""Location"": ""Function `redeemToken` (e.g., SwappableYieldSource.sol:159)""
    },
    {
      ""Issue"": ""Potential Integer Underflow/Edge Case in `approveMaxAmount`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `approveMaxAmount` function calculates the amount to increase allowance by using `type(uint256).max.sub(allowance)`. If the current `allowance` is already very close or equal to `type(uint256).max`, this subtraction could theoretically underflow (although `safeIncreaseAllowance` likely prevents this via internal checks or SafeMath reverts). Even if it reverts, it represents an edge case where the intended behavior (setting allowance to max) might fail."",
      ""Impact"": ""In the rare edge case where the allowance is already max, the transaction might revert, preventing the intended state confirmation, or behave unexpectedly depending on the SafeERC20 implementation details."",
      ""Location"": ""Function `approveMaxAmount` (e.g., SwappableYieldSource.sol:95)""
    },
    {
      ""Issue"": ""Missing Checks for Zero Amount Transfers"",
      ""Severity"": ""Informational"",
      ""Description"": ""Functions `supplyTokenTo`, `redeemToken`, and `transferERC20` do not explicitly check if the input `amount` is zero before proceeding with transfers or interactions. While underlying `safeTransfer` calls might handle this or revert appropriately, adding explicit zero-amount checks improves clarity, prevents unnecessary external calls and associated gas costs, and avoids potential edge cases in external contracts."",
      ""Impact"": ""Potential for wasted gas on zero-amount calls and slightly less robust code."",
      ""Location"": ""Functions `supplyTokenTo` (e.g., SwappableYieldSource.sol:168), `redeemToken` (e.g., SwappableYieldSource.sol:188), `transferERC20` (e.g., SwappableYieldSource.sol:259)""
    },
    {
      ""Issue"": ""Miscellaneous Low Severity Issues"",
      ""Severity"": ""Informational"",
      ""Description"": ""Several other minor issues were noted: \n1. Missing check in `initialize` that `_decimals <= 18`, potentially affecting compatibility with systems assuming standard ERC20 decimals.\n2. Missing event emission when approvals are set in `initialize` and `setYieldSource`, making off-chain tracking harder.\n3. `freeze` function is empty, public, and has an `initializer` modifier, serving no apparent purpose and potentially causing confusion.\n4. `transferERC20` lacks a check for `erc20Token` being the zero address.\n5. `transferERC20` does not strictly follow the checks-effects-interactions pattern regarding event emission."",
      ""Impact"": ""These issues represent deviations from best practices, potential minor incompatibilities, reduced off-chain observability, or code clutter, but are unlikely to cause direct fund loss."",
      ""Location"": ""Functions `initialize`, `setYieldSource`, `freeze` (e.g., SwappableYieldSource.sol:52), `transferERC20`""
    }
  ],
  ""IssueNumber"": 50,
  ""OutputList"": 11
}",277.59393310546875,5073.0,32.0,"### **Comparison of Issues and Responses**

---

#### **[H-01] onlyOwnerOrAssetManager can swap Yield Source in SwappableYieldSource at any time, immediately rugging all funds from old yield source**

**Report Description**:  
The `swapYieldSource` function in `SwappableYieldSource.sol` can be called by the owner or Asset Manager to transfer all funds from the old yield source to a new one. If either the owner or Asset Manager is malicious, they can exploit this function to rug-pull funds by setting a malicious yield source contract that implements `depositToken()`.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the specific issue of rug-pulling via `swapYieldSource`. While it covers reentrancy and allowance management, it misses the critical risk of malicious actors exploiting the `swapYieldSource` function.

---

#### **[H-02] redeemToken can fail for certain tokens**

**Report Description**:  
The `redeemToken` function in `SwappableYieldSource.sol` uses `ERC20.transferFrom` to transfer tokens back to the sender. However, some tokens may fail if the contract does not approve itself for the `redeemableBalance`. This could lead to transaction reverts and failed redemptions.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of `transferFrom` failing for certain tokens. It focuses on reentrancy and slippage but misses the specific problem with token allowances.

---

#### **[H-03] setYieldSource leads to temporary wrong results**

**Report Description**:  
The `setYieldSource` function changes the underlying yield source but does not immediately transfer the underlying balances. This leaves the contract in an inconsistent state, causing `balanceOfToken` and `supplyTokenTo` to return incorrect results. Users may receive more shares than appropriate, leading to potential fund draining.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Share Calculation or Reliance on Yield Source Balance""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of incorrect share calculations due to reliance on the yield source balance. However, it does not explicitly address the temporary inconsistency caused by `setYieldSource` or the potential for fund draining.

---

#### **[H-04] SwappableYieldSource: Missing same deposit token check in transferFunds()**

**Report Description**:  
The `transferFunds` function transfers funds between yield sources but does not check if the deposit tokens are the same. If the tokens differ in valuation, a malicious owner or Asset Manager could exploit this to pocket the difference.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of missing deposit token validation in `transferFunds`. It focuses on allowance management and reentrancy but misses this specific vulnerability.

---

#### **[M-01] Single-step process for critical ownership transfer/renounce is risky**

**Report Description**:  
The `SwappableYieldSource` contract uses `Ownable`'s `transferOwnership` and `renounceOwnership` methods, which are single-step and irrecoverable. This poses a risk if ownership is transferred or renounced mistakenly, as it cannot be undone.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of single-step ownership transfer/renouncement. It focuses on other vulnerabilities but misses this critical risk.

---

#### **[M-02] Use of safeApprove will always cause approveMax to revert**

**Report Description**:  
The `safeApprove` function in `mStableYieldSource` is deprecated and will revert if the current allowance is not zero. This prevents increasing the allowance unless it is reset to zero first, which is not handled in the contract.

**Match in Response List**:  
Matches with the issue titled **""Unsafe Maximum Approval and Allowance Management""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with `safeApprove` and the risks of maximum allowance management. It aligns with the reported problem.

---

#### **[M-03] Inconsistent balance when supplying transfer-on-fee or deflationary tokens**

**Report Description**:  
The `supplyTokenTo` function assumes the full `amount` of `_depositToken` is transferred, but this may not be true for transfer-on-fee or deflationary tokens. This could lead to inconsistencies in the contract's balance.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of inconsistent balances with transfer-on-fee or deflationary tokens. It focuses on other vulnerabilities but misses this specific problem.

---

#### **[M-04] Old yield source still has infinite approval**

**Report Description**:  
After swapping a yield source, the old yield source retains infinite approval. This could be exploited if the old yield source is compromised or malicious.

**Match in Response List**:  
Matches with the issue titled **""Unsafe Maximum Approval and Allowance Management""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of infinite approval for old yield sources. It aligns with the reported problem.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-02] Use of safeApprove will always cause approveMax to revert**
- **[M-04] Old yield source still has infinite approval**

**Partially Correct Matches**:

- **[H-03] setYieldSource leads to temporary wrong results**

**Missed Issues from Issue Report**:

- **[H-01] onlyOwnerOrAssetManager can swap Yield Source in SwappableYieldSource at any time, immediately rugging all funds from old yield source**
- **[H-02] redeemToken can fail for certain tokens**
- **[H-04] SwappableYieldSource: Missing same deposit token check in transferFunds()**
- **[M-01] Single-step process for critical ownership transfer/renounce is risky**
- **[M-03] Inconsistent balance when supplying transfer-on-fee or deflationary tokens**

--- 

The response list covers some issues but misses critical vulnerabilities related to rug-pulling, token allowances, deposit token validation, ownership management, and inconsistent balances. These gaps highlight the need for a more comprehensive review of the contract's security.","```
1. Unsafe Maximum Approval and Allowance Management
2. Unsafe Maximum Approval and Allowance Management
```","To calculate the **Average Precision (AP)**, we follow these steps:

1. **Identify the ranks of the true positives**:
   - The true positives are ""Unsafe Maximum Approval and Allowance Management"".
   - In the ranked list of predictions, this issue appears at rank 3.

2. **Calculate the precision at each rank**:
   - At rank 3, there is 1 true positive out of 3 predictions, so \( P@3 = \frac{1}{3} \).

3. **Average the precision values**:
   - Since there is only one true positive, the AP is simply \( P@3 = \frac{1}{3} \).

**Average Precision (AP)**: 0.3333"
