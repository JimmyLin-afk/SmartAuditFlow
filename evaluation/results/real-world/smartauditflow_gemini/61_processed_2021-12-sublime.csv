nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
CreditLine.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            ""Only Borrower or Lender who hasn't requested can accept""
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, ""CreditLine::_depositCollateral - value to transfer doesn't match argument"");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, ""CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount"");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}",10034,1061,"[H-01] In CreditLine#_borrowTokensToLiquidate, oracle is used wrong way

Submitted by 0x0x0x
Current implementation to get the price is as follows: 
(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset); 
https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1050
But it should not consult `borrowToken / collateralToken`, rather it should consult the invers
  [H-06] Anyone can liquidate credit line when autoLiquidation is false without supplying borrow tokens

Submitted by harleythedog
Impact

It is intended that if a credit line has autoLiquidation as false, then only the lender can be the liquidator (see docs here: https://docs.sublime.finance/sublime-docs/smart-contracts/creditlines). However, this is not correctly implemented, and anyone can liquidate a position that has autoLiquidation set to false.
Even worse, when autoLiquidation is set to false, the liquidator does not have to supply the initial amount of borrow tokens (determined by _borrowTokensToLiquidate) that normally have to be transferred when autoLiquidation is true. This means that the liquidator will be sent all of the collateral that is supposed to be sent to the lender, so this represents a huge loss to the lender. Since the lender will lose all of the collateral that they are owed, this is a high severity issue.
  [M-02] CreditLine.liquidate doesn't transfer borrowed ETH to a lender

Submitted by hyh, also found by 0x0x0x
Impact

Funds that are acquired from a liquidator and should be sent to a lender are left with the contract instead. The funds aren't lost, but after the fact mitigation will require manual accounting and fund transfer for each CreditLine.liquidate usage.
  [M-08] Missing approve(0)

There are 3 instances where the IERC20.approve() function is called only once without setting the allowance to zero. Some tokens, like USDT, require first reducing the address' allowance to zero by calling approve(_spender, 0). Transactions will revert when using an unsupported token like USDT (see the approve() function requirement at line 199).
",4,,"pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';



contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    
    address public savingsAccount;

    
    address public priceOracle;

    
    address public strategyRegistry;

    
    address public defaultStrategy;

    
    uint256 public protocolFeeFraction;

    
    address public protocolFeeCollector;

    
    uint256 public liquidatorRewardFraction;
    
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    
    event CreditLineAccepted(uint256 indexed id);

    
    event CreditLineReset(uint256 indexed id);

    
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    
    event CreditLineClosed(uint256 indexed id);

    
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    
    event PriceOracleUpdated(address indexed priceOracle);

    
    event SavingsAccountUpdated(address indexed savingsAccount);

    
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            ""Only Borrower or Lender who hasn't requested can accept""
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, ""CreditLine::_depositCollateral - value to transfer doesn't match argument"");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, ""CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount"");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}",7331,2,2,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control Vulnerabilities"",
      ""Tasks"": [
        ""Verify that only the owner can call the functions: updateDefaultStrategy, updatePriceOracle, updateSavingsAccount, updateProtocolFeeFraction, updateProtocolFeeCollector, updateStrategyRegistry, and updateLiquidatorRewardFraction."",
        ""Check for unintended access to sensitive functions or state variables."",
        ""Analyze the onlyOwner modifier and OwnableUpgradeable contract for potential vulnerabilities or misconfigurations."",
        ""Ensure the transferOwnership function is correctly implemented and used."",
        ""Verify that only the credit line borrower can call the functions marked with the `onlyCreditLineBorrower` modifier (withdrawCollateral, borrow)."",
        ""Verify that only the credit line lender can call the functions marked with the `onlyCreditLineLender` modifier."",
        ""In the 'accept' function, ensure that the check '(msg.sender == creditLineConstants[_id].borrower && _requestByLender) || (msg.sender == creditLineConstants[_id].lender && !_requestByLender)' correctly restricts access to either the lender or borrower based on who initiated the request."",
        ""In 'close' function, verify the credit line is closed only by borrower/lender""
      ]
    },
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Verify the proper usage of the `nonReentrant` modifier in depositCollateral, borrow, repay and liquidate functions."",
        ""Analyze the impact of external calls within the depositCollateral, borrow, repay and liquidate functions to identify potential reentrancy attack vectors."",
        ""Specifically, examine the interactions with the SavingsAccount, StrategyRegistry, and IYield contracts during deposit, withdraw, transfer, and liquidation operations for reentrancy risks."",
        ""Review the order of operations within functions to ensure that state changes are performed before external calls.""
      ]
    },
    {
      ""Area"": ""Arithmetic Overflow/Underflow"",
      ""Tasks"": [
        ""Verify that SafeMath is used for all arithmetic operations, especially in calculateInterest, calculateInterestAccrued, calculateCurrentDebt, calculateBorrowableAmount, depositCollateral, borrow, repay, withdrawCollateral, and liquidate."",
        ""Specifically, scrutinize the calculations involving principal, interest, collateral ratios, and price oracles for potential overflow/underflow issues."",
        ""Pay close attention to the division operations to ensure that divisors are not zero and that the results are handled correctly."",
        ""Check that the liquidatorRewardFraction is less than 1."",
        ""Examine the `msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate')` subtraction in `liquidate` function, ensuring that the `require` statement correctly prevents potential underflow despite the subtraction.""
      ]
    },
    {
      ""Area"": ""External Contract Interaction Vulnerabilities"",
      ""Tasks"": [
        ""Analyze the interactions with the IPriceOracle, ISavingsAccount, IStrategyRegistry, and IYield contracts for potential vulnerabilities, such as incorrect data, malicious responses, or unexpected behavior."",
        ""Verify that the addresses of these external contracts are properly validated and updated."",
        ""Assess the risk of price manipulation through the price oracle and its impact on the credit line's collateral ratio and liquidation process."",
        ""Investigate how the getTokensForShares function in IYield is implemented in different strategies and how this impacts collateral calculations."",
        ""Review the transfer and transferFrom functions in ISavingsAccount for potential vulnerabilities or unexpected behavior."",
        ""In `_depositCollateralFromSavingsAccount` and `_withdrawBorrowAmount`, analyze the behavior if a strategy reverts during the iteration process. Consider inconsistent states if this happens."",
        ""Check the return values of all external calls and ensure that errors are handled correctly."",
        ""Verify that the SavingsAccount address is a trusted address, given that the `receive()` function accepts ETH only from the SavingsAccount.""
      ]
    },
    {
      ""Area"": ""Logic Errors and Business Logic Vulnerabilities"",
      ""Tasks"": [
        ""Review the calculateInterest function to ensure that the interest calculation is accurate and aligned with the intended business logic."",
        ""Analyze the calculateBorrowableAmount function to ensure that the collateral ratio, borrow limit, and price oracle are correctly used to determine the maximum borrowable amount."",
        ""Examine the depositCollateral and withdrawCollateral functions to ensure that the collateral is properly managed and that the collateral ratio is maintained within the acceptable range."",
        ""Verify that the liquidation process is fair and efficient, and that the liquidator reward is properly calculated and distributed."",
        ""In the `request` function, verify that the check `_borrowAsset != _collateralAsset` correctly prevents borrowing and lending the same token."",
        ""Assess the impact of potential front-running attacks on the request and accept functions."",
        ""Check the edge cases in the functions calculating collateral, especially when collateral assets are minimal."",
        ""Review the close function to ensure the credit line has no principal and interest outstanding"",
        ""Check the `_resetCreditLine` to ensure that states variables are correctly reset.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify opportunities to reduce gas costs by optimizing data storage, function calls, and loop iterations."",
        ""Specifically, analyze the depositCollateral, borrow, repay, withdrawCollateral, and liquidate functions for potential gas optimizations."",
        ""Consider using more efficient data structures and algorithms to reduce gas consumption."",
        ""Reduce redundant sload operations by caching values in memory."",
        ""Review the usage of memory vs storage variables and optimize accordingly."",
        ""Minimize external calls where possible.""
      ]
    },
    {
      ""Area"": ""Denial of Service (DoS)"",
      ""Tasks"": [
        ""Examine the functions that iterate over a list of strategies (_depositCollateralFromSavingsAccount, _withdrawBorrowAmount, _transferCollateral) for potential DoS vulnerabilities if the number of strategies becomes very large."",
        ""Assess the gas costs of these functions and determine if they could exceed the block gas limit."",
        ""Consider implementing pagination or other techniques to limit the number of iterations in a single transaction."",
        ""Analyze the potential for DoS attacks on the request and accept functions by creating a large number of pending credit line requests."",
        ""Check that any state variable updates are bounded to prevent potential DoS.""
      ]
    },
    {
      ""Area"": ""Oracle Manipulation"",
      ""Tasks"": [
        ""Assess the reliance on the IPriceOracle for accurate price feeds."",
        ""Investigate the potential for manipulating the price feeds and the impact on the credit line's collateral ratio and liquidation process."",
        ""Determine if the price oracle is resistant to flash loan attacks or other manipulation techniques."",
        ""Verify that the price oracle provides sufficient historical data to mitigate the risk of temporary price spikes."",
        ""Determine the source of the price feed in the Oracle."",
        ""Analyze the potential impact if the price feed becomes unavailable. Is there a mechanism to handle CreditLines in a REQUESTED state when price feeds fail?""
      ]
    },
    {
      ""Area"": ""Unused Imports and Variables"",
      ""Tasks"": [
        ""Investigate the use of `SavingsAccountUtil.sol`. Is it being used appropriately or can it be removed?"",
        ""Remove any unused import statements to reduce contract size.""
      ]
    },
    {
      ""Area"": ""Error Handling and Reporting"",
      ""Tasks"": [
        ""Ensure that all require statements have informative error messages to aid in debugging and troubleshooting."",
        ""Check that all potential errors are handled gracefully and that the contract does not enter an inconsistent state in case of an error."",
        ""Review the events emitted by the contract and ensure that they provide sufficient information for off-chain monitoring and analysis."",
        ""In places where 'revert' is used, check if a custom error could save gas.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code implements a CreditLine contract that allows borrowers to take out loans using collateral. It interacts with external contracts such as SavingsAccount, PriceOracle, and StrategyRegistry. The contract includes functionalities for requesting, accepting, depositing collateral, borrowing, repaying, withdrawing collateral, and liquidating credit lines. It also incorporates access control mechanisms and reentrancy protection."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""CreditLine"",
    ""Purpose"": ""Provides functionality for creating and managing credit lines between lenders and borrowers, secured by collateral deposited in yield-bearing strategies via a SavingsAccount."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ReentrancyGuard"", ""OwnableUpgradeable""],
      ""Imports"": [
        ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"",
        ""@openzeppelin/contracts/math/SafeMath.sol"",
        ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"",
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""../interfaces/IPriceOracle.sol"",
        ""../interfaces/IYield.sol"",
        ""../interfaces/ISavingsAccount.sol"",
        ""../SavingsAccount/SavingsAccountUtil.sol"",
        ""../interfaces/IStrategyRegistry.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""creditLineCounter"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Counter for unique CreditLine IDs.""
      },
      {
        ""Name"": ""YEAR_IN_SECONDS"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Constant representing one year in seconds.""
      },
      {
        ""Name"": ""collateralShareInStrategy"",
        ""Type"": ""mapping(uint256 => mapping(address => uint256))"",
        ""Purpose"": ""Maps a credit line ID and a strategy address to the amount of collateral shares allocated to that strategy for that credit line.""
      },
      {
        ""Name"": ""creditLineVariables"",
        ""Type"": ""mapping(uint256 => CreditLineVariables)"",
        ""Purpose"": ""Stores dynamic credit line variables (status, principal, interest repaid, etc.) for each credit line ID.""
      },
      {
        ""Name"": ""creditLineConstants"",
        ""Type"": ""mapping(uint256 => CreditLineConstants)"",
        ""Purpose"": ""Stores immutable credit line constants (lender, borrower, borrow limit, borrow rate, assets, etc.) for each credit line ID.""
      },
      {
        ""Name"": ""savingsAccount"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the SavingsAccount contract.""
      },
      {
        ""Name"": ""priceOracle"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the PriceOracle contract.""
      },
      {
        ""Name"": ""strategyRegistry"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the StrategyRegistry contract.""
      },
      {
        ""Name"": ""defaultStrategy"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the default strategy contract.""
      },
      {
        ""Name"": ""protocolFeeFraction"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Fraction representing the protocol fee.""
      },
      {
        ""Name"": ""protocolFeeCollector"",
        ""Type"": ""address"",
        ""Purpose"": ""Address to which protocol fees are sent.""
      },
      {
        ""Name"": ""liquidatorRewardFraction"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Fraction representing the reward for liquidators.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract with addresses for external dependencies, ownership, and fee-related parameters."",
        ""Parameters"": [
          ""_defaultStrategy"",
          ""_priceOracle"",
          ""_savingsAccount"",
          ""_strategyRegistry"",
          ""_owner"",
          ""_protocolFeeFraction"",
          ""_protocolFeeCollector"",
          ""_liquidatorRewardFraction""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""updateDefaultStrategy"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the address of the default strategy. Only callable by the owner."",
        ""Parameters"": [""_defaultStrategy""],
        ""Returns"": []
      },
      {
        ""Name"": ""updatePriceOracle"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the address of the price oracle. Only callable by the owner."",
        ""Parameters"": [""_priceOracle""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateSavingsAccount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the address of the savings account. Only callable by the owner."",
        ""Parameters"": [""_savingsAccount""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateProtocolFeeFraction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the protocol fee fraction. Only callable by the owner."",
        ""Parameters"": [""_protocolFee""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateProtocolFeeCollector"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the address of the protocol fee collector. Only callable by the owner."",
        ""Parameters"": [""_protocolFeeCollector""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateStrategyRegistry"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the address of the strategy registry. Only callable by the owner."",
        ""Parameters"": [""_strategyRegistry""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateLiquidatorRewardFraction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the liquidator reward fraction. Only callable by the owner."",
        ""Parameters"": [""_rewardFraction""],
        ""Returns"": []
      },
      {
        ""Name"": ""calculateInterest"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the interest accrued on a principal amount given the borrow rate and time elapsed."",
        ""Parameters"": [""_principal"", ""_borrowRate"", ""_timeElapsed""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""calculateInterestAccrued"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the interest accrued for a specific credit line, based on the last principal update time."",
        ""Parameters"": [""_id""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""calculateCurrentDebt"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the current debt for a specific credit line, including principal and accrued interest."",
        ""Parameters"": [""_id""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""calculateBorrowableAmount"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the maximum amount that can be borrowed from a credit line based on collateral, price ratios, and borrow limit."",
        ""Parameters"": [""_id""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""request"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a lender or borrower to request a new credit line."",
        ""Parameters"": [
          ""_requestTo"",
          ""_borrowLimit"",
          ""_borrowRate"",
          ""_autoLiquidation"",
          ""_collateralRatio"",
          ""_borrowAsset"",
          ""_collateralAsset"",
          ""_requestAsLender""
        ],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""accept"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the lender or borrower to accept a credit line request."",
        ""Parameters"": [""_id""],
        ""Returns"": []
      },
      {
        ""Name"": ""depositCollateral"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the borrower to deposit collateral into a credit line."",
        ""Parameters"": [""_id"", ""_amount"", ""_strategy"", ""_fromSavingsAccount""],
        ""Returns"": []
      },
      {
        ""Name"": ""borrow"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the borrower to borrow from the credit line."",
        ""Parameters"": [""_id"", ""_amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""repay"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the borrower to repay the credit line."",
        ""Parameters"": [""_id"", ""_amount"", ""_fromSavingsAccount""],
        ""Returns"": []
      },
      {
        ""Name"": ""close"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the lender or borrower to close the credit line."",
        ""Parameters"": [""_id""],
        ""Returns"": []
      },
      {
        ""Name"": ""calculateCurrentCollateralRatio"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the current collateral ratio for a credit line."",
        ""Parameters"": [""_id""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""calculateTotalCollateralTokens"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the total number of collateral tokens deposited for a credit line across all strategies."",
        ""Parameters"": [""_id""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""withdrawCollateral"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the borrower to withdraw collateral from a credit line."",
        ""Parameters"": [""_id"", ""_amount"", ""_toSavingsAccount""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawableCollateral"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the amount of collateral that can be withdrawn from a credit line without violating the ideal collateral ratio."",
        ""Parameters"": [""_id""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""liquidate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows anyone to liquidate a credit line if the collateral ratio falls below the ideal value."",
        ""Parameters"": [""_id"", ""_toSavingsAccount""],
        ""Returns"": []
      },
      {
        ""Name"": ""borrowTokensToLiquidate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Calculates the amount of borrow tokens needed to liquidate a given credit line."",
        ""Parameters"": [""_id""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""ifCreditLineExists"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Modifier that checks if a credit line with the given ID exists."",
        ""Parameters"": [""_id""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyCreditLineBorrower"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Modifier that restricts function access to the credit line borrower."",
        ""Parameters"": [""_id""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyCreditLineLender"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Modifier that restricts function access to the credit line lender."",
        ""Parameters"": [""_id""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IPriceOracle (priceOracle)"",
    ""ISavingsAccount (savingsAccount)"",
    ""IStrategyRegistry (strategyRegistry)"",
    ""IYield (strategies listed in StrategyRegistry)"",
    ""IERC20 (borrowAsset and collateralAsset)"",
    ""OwnableUpgradeable"",
    ""ReentrancyGuard""
  ],
  ""SpecialMechanisms"": [
    ""Uses SafeERC20 library for safe ERC20 token operations."",
    ""Uses SafeMath library for safe arithmetic operations."",
    ""Implements ReentrancyGuard to prevent reentrancy attacks."",
    ""Implements OwnableUpgradeable for access control."",
    ""Calculates interest and collateral ratios based on external price feeds."",
    ""Integrates with SavingsAccount and StrategyRegistry for collateral management and yield generation.""
  ],
  ""Questions"": [
    ""How is the `SavingsAccountUtil` contract used, and why is it imported but not directly referenced in this code?"",
    ""What are the specific implementations of the `IYield` interfaces of the deployed Strategies and how do they affect collateral calculations?"",
    ""The `receive()` function requires the message sender to be the savings account. What security considerations are in place to ensure that the `savingsAccount` address isn't compromised, as this could allow arbitrary ETH transfers into the contract?"",
    ""In `_depositCollateralFromSavingsAccount` and `_withdrawBorrowAmount`, strategies are iterated through and tokens are transferred. What happens if a strategy reverts during the iteration? Does this leave the contract in an inconsistent state?"",
    ""In the `liquidate` function, the `msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate')` subtraction can underflow if `msg.value` is less than `_borrowTokens`. While the `require` statement would prevent this, what is the reason for performing this subtraction if it could potentially revert even though msg.value is ultimately checked for sufficiency?"",
    ""Is there a mechanism to prevent the same lender and borrower from creating multiple credit line requests with slightly different parameters to potentially game the system?"",
    ""Consider the scenario where a CreditLine is 'REQUESTED', but not yet 'ACTIVE', and the underlying price feeds become unavailable, causing `calculateBorrowableAmount` and similar functions to fail. Is there a process for handling or cancelling such a CreditLine to prevent it from being indefinitely stuck in this state?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions (`_depositCollateral`, `borrow`, `repay`, `_withdrawBorrowAmount`, `liquidate`, `_transferCollateral`) interact with external contracts (`SavingsAccount`, `Yield`, `ERC777`). A malicious contract could re-enter the `CreditLine` contract before state updates are complete, potentially manipulating balances, collateral ratios, or triggering unauthorized actions. The `nonReentrant` modifier might be bypassed via callbacks from the savings account or malicious strategy contracts."",
      ""Impact"": ""Attackers could manipulate state, potentially leading to unauthorized borrowing, theft of funds, incorrect calculations, double-spending of collateral, or manipulation of liquidation processes."",
      ""Location"": ""CreditLine.sol: `_depositCollateral`, `borrow`, `repay`, `_withdrawBorrowAmount`, `liquidate`, `_transferCollateral` functions; Specifically calls to `_savingsAccount.deposit`, `_savingsAccount.withdrawFrom`, `safeTransfer`, `_repayFromSavingsAccount`, `transfer`, and `withdraw` in `ISavingsAccount` and `IYield`.""
    },
    {
      ""Issue"": ""Incorrect Calculation of `_borrowTokens` during liquidation leading to insufficient collateral to cover debt"",
      ""Severity"": ""High"",
      ""Description"": ""The `_borrowTokensToLiquidate` function calculates the amount of tokens to return during liquidation by deducting `liquidatorRewardFraction` from the total collateral value, which may not fully cover the borrower's debt, leaving the lender with a loss."",
      ""Impact"": ""Lenders could be left with losses after a liquidation if the value of returned borrow tokens is insufficient to cover outstanding debt. Borrowers could get liquidated even when collateral would have been sufficient to prevent liquidation."",
      ""Location"": ""CreditLine.sol: `_borrowTokensToLiquidate`""
    },
    {
      ""Issue"": ""Missing Input Validation for Key Parameters"",
      ""Severity"": ""High"",
      ""Description"": ""Several functions, including `request`, `_createRequest`, `initializer`, and update functions lack adequate input validation for critical parameters like `_borrowLimit`, `_borrowRate`, `_collateralRatio`, and `_protocolFeeFraction`. This can lead to unrealistic or malicious values being set, disrupting the protocol's intended economic incentives."",
      ""Impact"": ""Unrealistic values can break economic incentives, lead to unsustainable debt, unfair loan terms, or expose lenders to excessive risk. Setting collateral ratio to zero opens up attack surface."",
      ""Location"": ""request, initializer, _createRequest functions, update functions for parameters.""
    },
    {
      ""Issue"": ""Unprotected `receive()` Function Can Be Exploited If `savingsAccount` is Malicious."",
      ""Severity"": ""High"",
      ""Description"": ""The `receive()` function simply checks if `msg.sender == savingsAccount`. If the SavingsAccount contract is compromised or controlled by a malicious actor, they could send ETH to the CreditLine contract at any time, potentially disrupting the intended functionality of the CreditLine contract."",
      ""Impact"": ""If the savingsAccount is malicious, it could send ETH to the CreditLine, potentially disrupting accounting or making it vulnerable to unexpected state changes."",
      ""Location"": ""CreditLine.sol:receive()""
    },
    {
      ""Issue"": ""Potential loss of funds in `liquidate` function when `autoLiquidation` is enabled and lender is not the liquidator"",
      ""Severity"": ""Medium"",
      ""Description"": ""If `creditLineConstants[_id].autoLiquidation` is true and the lender is not the liquidator, the liquidator may lose funds due to revert in `safeTransferFrom` if the transfer of borrow tokens to the lender fails, as the transfer of collateral to the liquidator will not happen."",
      ""Impact"": ""Liquidators can lose funds due to revert in safeTransferFrom."",
      ""Location"": ""CreditLine.sol: `liquidate`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Collateral and Liquidation Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Calculations in `_transferCollateral`, `_borrowTokensToLiquidate`, `_depositCollateralFromSavingsAccount`, and `calculateInterest` functions could lead to integer overflow or underflow, resulting in incorrect accounting of deposited collateral, inaccurate borrow token calculations during liquidation, or incorrect interest accrual. The calculations are: `liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)`, `_totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)`, `_liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)`, `_principal.mul(_borrowRate).mul(_timeElapsed)`"",
      ""Impact"": ""Loss of precision in collateral share calculations, incorrect liquidation amounts, or inaccurate interest accrual can lead to financial discrepancies and potential exploitation."",
      ""Location"": ""CreditLine.sol: `_transferCollateral`, `_borrowTokensToLiquidate`, `_depositCollateralFromSavingsAccount`, `calculateInterest`""
    },
    {
      ""Issue"": ""Lack of slippage control in collateral withdrawal and borrow functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `_transferCollateral` and `_withdrawBorrowAmount` rely on `IYield(_strategyList[index]).getTokensForShares` and `ISavingsAccount(savingsAccount).withdraw` without slippage control, and `liquidate` also lacks slippage protection. Significant slippage or price impact could result in users losing funds or unexpected transaction failures."",
      ""Impact"": ""Users could lose funds due to unexpected slippage when withdrawing collateral or borrowing assets."",
      ""Location"": ""CreditLine.sol: `_transferCollateral`, `_withdrawBorrowAmount`, `liquidate` functions, specifically the calls to `IYield(_strategyList[index]).getTokensForShares` and `ISavingsAccount(savingsAccount).withdraw`.""
    },
    {
      ""Issue"": ""Missing access control on `liquidate` and `_withdrawBorrowAmount` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `liquidate` function can be called by anyone, allowing potential front-running or manipulation. The internal function `_withdrawBorrowAmount` lacks explicit access control, creating a potential vulnerability if improperly reused."",
      ""Impact"": ""Malicious actors could exploit the liquidation process, or unauthorized access to `_withdrawBorrowAmount` could lead to fund withdrawals."",
      ""Location"": ""CreditLine.sol: `liquidate`, `_withdrawBorrowAmount` functions.""
    },
    {
      ""Issue"": ""Inconsistent handling of native ETH in depositCollateral function"",
      ""Severity"": ""Medium"",
      ""Description"": ""In `depositCollateral` function, when not depositing from the savings account and `_collateralAsset` is ETH (address(0)), the deposited ETH remains in the contract rather than being transferred to the specified `_strategy`."",
      ""Impact"": ""User can deposit ETH as collateral without it being used, and can get stuck in the CreditLine contract."",
      ""Location"": ""`depositCollateral` function""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerabilities"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract is vulnerable to front-running attacks in the `liquidate` and `request` functions. Attackers could front-run transactions to exploit price discrepancies or manipulate loan parameters, potentially leading to unfair liquidations or unfavorable loan terms."",
      ""Impact"": ""Loss of value for borrowers or lenders due to manipulation of loan terms or liquidation processes."",
      ""Location"": ""CreditLine.sol: `liquidate`, `request` functions.""
    },
    {
      ""Issue"": ""Lack of Sanity Check on Price Oracle Results"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions rely on the price oracle without ensuring that the returned price ratios are within reasonable bounds. A compromised oracle could return extreme prices, leading to incorrect calculations and potential exploits."",
      ""Impact"": ""A compromised or faulty price oracle can lead to incorrect collateral ratios, liquidations at incorrect prices, and the ability to borrow excessively."",
      ""Location"": ""CreditLine.sol:calculateBorrowableAmount, CreditLine.sol:calculateCurrentCollateralRatio, CreditLine.sol:_borrowTokensToLiquidate""
    },
    {
      ""Issue"": ""Inaccurate collateral share calculation in `_depositCollateralFromSavingsAccount`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_depositCollateralFromSavingsAccount` function the collateralShareInStrategy calculation is incorrect. The share should be updated by `_tokensToTransfer`."",
      ""Impact"": ""Incorrect tracking of collateral shares deposited from the savings account. It may lead to wrong calculation in liquidation or withdrawal."",
      ""Location"": ""_depositCollateralFromSavingsAccount function""
    },
    {
      ""Issue"": ""Missing Input Validation for Critical Parameters"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks sufficient input validation in key functions such as `request` and the `initializer` for critical parameters like `_borrowLimit`, `_borrowRate`, `_collateralRatio`.  A malicious actor can provide extremely high or low values that could lead to unexpected contract behavior."",
      ""Impact"": ""Unrealistic values in borrow rate, collateral ratio, or borrow limit can break the intended economic incentives of the lending platform.  Inconsistent values for decimal places could cause calculation errors. Setting collateral ratio as zero or very low value can open attack surface."",
      ""Location"": ""request, initializer, _createRequest functions""
    },
    {
      ""Issue"": ""Potential Division by Zero in `calculateCurrentCollateralRatio`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `calculateCurrentCollateralRatio` function calculates the ratio of collateral to debt. If `currentDebt` is zero, a division by zero error will occur, causing the transaction to revert."",
      ""Impact"": ""Transaction reverts and denial of service for collateral ratio calculation when `currentDebt` is zero."",
      ""Location"": ""Function `calculateCurrentCollateralRatio`""
    },
     {
      ""Issue"": ""Incorrect Fee Transfer Logic in `borrow` Function for Native Token (ETH)"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `borrow` function, when the `_borrowAsset` is ETH, the calculated protocol fee is based on the contract balance change rather than the actual borrowed amount, leading to potential errors in fee calculation and fund transfers."",
      ""Impact"": ""Incorrect fee calculation, potentially leading to a loss of funds for the borrower or the protocol. The intended amount might not be transferred to the borrower, or an incorrect fee might be taken."",
      ""Location"": ""Function `borrow`, specifically the section where `_borrowAsset == address(0)`""
    },
    {
      ""Issue"": ""Denial of Service (DoS) via Long Strategy List in Multiple Loops"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `_depositCollateralFromSavingsAccount`, `_withdrawBorrowAmount`, `_repayFromSavingsAccount`, `calculateTotalCollateralTokens`, `_transferCollateral` iterate through the strategies returned by the `strategyRegistry`. If the number of strategies becomes very large, these functions could consume excessive gas, potentially exceeding the block gas limit and causing a denial of service."",
      ""Impact"": ""The functions `_depositCollateralFromSavingsAccount`, `_withdrawBorrowAmount` and `_repayFromSavingsAccount` may become unusable if the number of registered strategies becomes too large."",
      ""Location"": ""CreditLine.sol: `_depositCollateralFromSavingsAccount`, `_withdrawBorrowAmount`, `_repayFromSavingsAccount`, `calculateTotalCollateralTokens`, `_transferCollateral`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `_borrowTokensToLiquidate`"",
      ""Severity"": ""Low"",
      ""Description"": ""In the function `_borrowTokensToLiquidate`, the calculation `_totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction))` could lead to an integer overflow if `_totalCollateralTokens` is large. Similarly, `uint256(10**30).sub(liquidatorRewardFraction)` can underflow if `liquidatorRewardFraction` is close to 10**30, although checks are present."",
      ""Impact"": ""Integer overflow/underflow causes incorrect calculation and transfer of borrow tokens to the liquidator."",
      ""Location"": ""CreditLine.sol: `_borrowTokensToLiquidate`""
    },
    {
      ""Issue"": ""Rounding Errors in Interest Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The `calculateInterest` function uses integer division, which can lead to rounding errors and slight underestimation of the accrued interest over time."",
      ""Impact"": ""Slightly inaccurate interest calculations. The lender receives less interest than they should."",
      ""Location"": ""CreditLine.sol: `calculateInterest`""
    },
    {
      ""Issue"": ""Unnecessary approval in `_depositCollateral` when `_collateralAsset` is ETH"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `_depositCollateral` function, when `_fromSavingsAccount` is false, the contract approves the `_strategy` to spend `_amount` of `_collateralAsset` for this contract. This is unnecessary if `_collateralAsset` is the zero address (ETH) because approve is an ERC20 function that can only be called on ERC20 tokens. The call will fail and revert the transaction."",
      ""Impact"": ""The `depositCollateral` function will revert if the user attempts to deposit ETH using the non-savings account deposit flow."",
      ""Location"": ""CreditLine.sol: `_depositCollateral` function, specifically `IERC20(_collateralAsset).approve(_strategy, _amount);`""
    },
     {
      ""Issue"": ""Griefing Vulnerabilities and Lack of Input Validation"",
      ""Severity"": ""Low"",
      ""Description"": ""Potential griefing in `repay` function if borrower front-runs lender, causing incorrect state updates in SavingsAccount/Yield contracts. Lack of input validation for `idealCollateralRatio` can lead to division by zero errors and DoS. Also missing check for zero amount in `depositCollateral` and `withdrawCollateral` can lead to gas wastage."",
      ""Impact"": ""Borrower can grief the system by front-running a lender's deposit and disrupting the SavingsAccount or Yield contracts. Zero `idealCollateralRatio` renders the credit line unusable. Slight gas wastage due to missing checks in deposit and withdraw collateral."",
      ""Location"": ""CreditLine.sol: `repay`, `request`, `depositCollateral`, `withdrawCollateral` functions.""
    },
    {
        ""Issue"": ""Unsafe subtraction in `_borrowTokensToLiquidate` function can revert transaction"",
        ""Severity"": ""Low"",
        ""Description"": ""The `_borrowTokensToLiquidate` function contains an unsafe subtraction `msg.value.sub(_borrowTokens, \'Insufficient ETH to liquidate\')`. If msg.value is less than _borrowTokens then it can revert transaction."",
        ""Impact"": ""The function can revert the transactions in some scenarios."",
        ""Location"": ""_borrowTokensToLiquidate function, line 615""
      },
      {
        ""Issue"": ""Inconsistent Access Control in `accept` function"",
        ""Severity"": ""Low"",
        ""Description"": ""The `accept` function has an access control logic where either the borrower or lender can accept the credit line based on who initiated the request. However, there is no `onlyCreditLineBorrower` or `onlyCreditLineLender` modifier being applied to this function. While the function has `require` statements to validate the correct party is calling `accept`, it is not as clear or maintainable as using the explicit modifiers defined in the contract. It could also lead to potential confusion in the future if the access control logic needs to be modified."",
        ""Impact"": ""Code maintainability issues, potential for errors when modifying the access control logic."",
        ""Location"": ""Function `accept`""
      },
      {
        ""Issue"": ""Missing Input Validation for Key Parameters"",
        ""Severity"": ""Medium"",
        ""Description"": ""Several crucial parameters, such as `_borrowRate`, `_collateralRatio`, and `_protocolFeeFraction`, lack explicit validation beyond the `_liquidatorRewardFraction` check. A large `_borrowRate` could be detrimental to borrowers, an extremely low or high `_collateralRatio` could be unfair to either borrower or lender, and a too high `_protocolFeeFraction` could disincentivize usage."",
        ""Impact"": ""Adverse financial consequences for users due to unreasonable or malicious parameter values. Could lead to borrowers accumulating unsustainable debt or lenders not receiving adequate collateral protection."",
        ""Location"": ""Functions `request`, `_createRequest`, `initialize`, and update functions for parameters.""
      },
      {
        ""Issue"": ""Lack of Sanity Check on `_rewardFraction` in `updateLiquidatorRewardFraction`"",
        ""Severity"": ""Low"",
        ""Description"": ""While the code checks that `_rewardFraction <= 10**30`, there is no check to ensure it is less than the price ratio or some other meaningful value. If the `liquidatorRewardFraction` is too high, it can lead to situations where liquidation is not profitable or even detrimental to the liquidator."",
        ""Impact"": ""Could discourage liquidators from participating, potentially destabilizing the system during times of high volatility or undercollateralization."",
        ""Location"": ""`updateLiquidatorRewardFraction` function.""
      },
       {
        ""Issue"": ""Missing check for zero address in critical update functions."",
        ""Severity"": ""Medium"",
        ""Description"": ""While `updateStrategyRegistry` and `updateProtocolFeeCollector` functions have checks to prevent updating with zero address, similar checks are missing in `updateDefaultStrategy`, `updatePriceOracle` and `updateSavingsAccount` functions. Setting these addresses to zero can break core functionalities."",
        ""Impact"": ""Setting a critical address to zero can halt core contract functionalities, requiring a costly and potentially complex contract migration."",
        ""Location"": ""updateDefaultStrategy, updatePriceOracle and updateSavingsAccount functions, line 252, 265 and 278""
      },
         {
        ""Issue"": ""Lack of check on borrow and collateral asset"",
        ""Severity"": ""Low"",
        ""Description"": ""The functions `_depositCollateral` and `_transferCollateral` should check that _collateralAsset and _strategy is not a borrow asset, otherwise a user can deposit/withdraw borrow asset as a collateral."",
        ""Impact"": ""Attacker can deposit/withdraw borrow asset as collateral and borrow more amount."",
        ""Location"": ""`_depositCollateral` and `_transferCollateral` function""
      },
      {
        ""Issue"": ""Lack of overflow/underflow checks on `liquidatorRewardFraction`."",
        ""Severity"": ""Informational"",
        ""Description"": ""While the code checks that `_rewardFraction <= 10**30`, it does not implement safe subtraction when using the value later, which can cause issues in the `_borrowTokensToLiquidate` function, where `uint256(10**30).sub(liquidatorRewardFraction)` is used."",
        ""Impact"": ""May lead to calculation errors during liquidation."",
        ""Location"": ""CreditLine.sol:_updateLiquidatorRewardFraction""
      }
  ],
  ""IssueNumber"": 74,
  ""OutputList"": 25
}",223.4189810752869,4787.0,32.0,"### **Comparison of Issues and Responses**

---

#### **[H-01] In CreditLine#_borrowTokensToLiquidate, oracle is used wrong way**

**Report Description**:  
The `_borrowTokensToLiquidate` function in `CreditLine.sol` incorrectly consults the price oracle for the ratio of `borrowToken / collateralToken` instead of the inverse (`collateralToken / borrowToken`). This could lead to incorrect calculations during liquidation, potentially resulting in unfair liquidations or incorrect collateral-to-debt ratios.

**Match in Response List**:  
No direct match found. However, the response titled **""Lack of Sanity Check on Price Oracle Results""** partially addresses the issue by highlighting the lack of validation on price oracle results, which could lead to incorrect calculations.

**Validation**:  
**Partially Correct**. The response identifies the broader issue of relying on the price oracle without proper validation, which is related to the incorrect usage of the oracle in `_borrowTokensToLiquidate`. However, it does not specifically address the inversion of the price ratio, which is the core issue in this case.

---

#### **[H-06] Anyone can liquidate credit line when autoLiquidation is false without supplying borrow tokens**

**Report Description**:  
When `autoLiquidation` is set to `false`, only the lender should be able to liquidate the credit line. However, the current implementation allows anyone to liquidate without supplying the required borrow tokens. This results in the liquidator receiving all the collateral, leading to significant losses for the lender.

**Match in Response List**:  
No direct match found. The response titled **""Missing access control on `liquidate` and `_withdrawBorrowAmount` function""** partially addresses the issue by highlighting the lack of access control on the `liquidate` function, but it does not address the specific issue of missing borrow token transfers when `autoLiquidation` is `false`.

**Validation**:  
**Partially Correct**. The response correctly identifies the lack of access control on the `liquidate` function, which is related to the issue. However, it does not address the critical detail of missing borrow token transfers when `autoLiquidation` is `false`, which is the core vulnerability.

---

#### **[M-02] CreditLine.liquidate doesn't transfer borrowed ETH to a lender**

**Report Description**:  
The `liquidate` function fails to transfer borrowed ETH to the lender, leaving the funds in the contract. While the funds are not lost, this oversight requires manual intervention to transfer the funds, leading to inefficiencies and potential accounting discrepancies.

**Match in Response List**:  
No direct match found. The response titled **""Potential loss of funds in `liquidate` function when `autoLiquidation` is enabled and lender is not the liquidator""** partially addresses the issue by highlighting potential fund loss during liquidation, but it does not specifically address the failure to transfer borrowed ETH to the lender.

**Validation**:  
**Partially Correct**. The response identifies a related issue of fund loss during liquidation, but it does not address the specific problem of borrowed ETH not being transferred to the lender, which is the core issue in this case.

---

#### **[M-08] Missing approve(0)**

**Report Description**:  
The contract calls `IERC20.approve()` without first setting the allowance to zero, which is required by some tokens like USDT. This could cause transactions to revert when using such tokens, leading to potential disruptions in the protocol's functionality.

**Match in Response List**:  
No direct match found. The response titled **""Unnecessary approval in `_depositCollateral` when `_collateralAsset` is ETH""** partially addresses the issue by highlighting unnecessary approvals, but it does not specifically address the need to set the allowance to zero before calling `approve`.

**Validation**:  
**Partially Correct**. The response identifies a related issue of unnecessary approvals, but it does not address the specific requirement of setting the allowance to zero before calling `approve`, which is the core issue in this case.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-01] In CreditLine#_borrowTokensToLiquidate, oracle is used wrong way**  
- **[H-06] Anyone can liquidate credit line when autoLiquidation is false without supplying borrow tokens**  
- **[M-02] CreditLine.liquidate doesn't transfer borrowed ETH to a lender**  
- **[M-08] Missing approve(0)**

**Missed Issues from Issue Report**:  
- *None* (All issues were partially addressed, but none were fully matched or correctly identified.)

--- 

### **Conclusion**  
The `response_list` partially addresses some of the issues in the `issue` report but fails to fully capture the core vulnerabilities or provide accurate solutions. Specifically, the responses often identify broader issues (e.g., lack of access control, reliance on price oracles) but miss the critical details that define the reported vulnerabilities (e.g., incorrect price ratio inversion, missing borrow token transfers). This indicates a need for more precise and detailed responses to fully address the reported issues.","```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the AP is calculated as 0."
SavingsAccountUtil.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '../interfaces/ISavingsAccount.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';

library SavingsAccountUtil {
    using SafeERC20 for IERC20;

    function depositFromSavingsAccount(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy,
        bool _withdrawShares,
        bool _toSavingsAccount
    ) internal returns (uint256) {
        if (_toSavingsAccount) {
            return savingsAccountTransfer(_savingsAccount, _from, _to, _amount, _token, _strategy);
        } else {
            return withdrawFromSavingsAccount(_savingsAccount, _from, _to, _amount, _token, _strategy, _withdrawShares);
        }
    }

    function directDeposit(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        bool _toSavingsAccount,
        address _strategy
    ) internal returns (uint256) {
        if (_toSavingsAccount) {
            return directSavingsAccountDeposit(_savingsAccount, _from, _to, _amount, _token, _strategy);
        } else {
            return transferTokens(_token, _amount, _from, _to);
        }
    }

    function directSavingsAccountDeposit(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        transferTokens(_token, _amount, _from, address(this));
        uint256 _ethValue;
        if (_token == address(0)) {
            _ethValue = _amount;
        } else {
            address _approveTo = _strategy;
            if (_strategy == address(0)) {
                _approveTo = address(_savingsAccount);
            }
            IERC20(_token).safeApprove(_approveTo, _amount);
        }
        _sharesReceived = _savingsAccount.deposit{value: _ethValue}(_amount, _token, _strategy, _to);
    }

    function savingsAccountTransfer(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256) {
        if (_from == address(this)) {
            _savingsAccount.transfer(_amount, _token, _strategy, _to);
        } else {
            _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);
        }
        return _amount;
    }

    function withdrawFromSavingsAccount(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy,
        bool _withdrawShares
    ) internal returns (uint256 _amountReceived) {
        if (_from == address(this)) {
            _amountReceived = _savingsAccount.withdraw(_amount, _token, _strategy, payable(_to), _withdrawShares);
        } else {
            _amountReceived = _savingsAccount.withdrawFrom(_amount, _token, _strategy, _from, payable(_to), _withdrawShares);
        }
    }

    function transferTokens(
        address _token,
        uint256 _amount,
        address _from,
        address _to
    ) internal returns (uint256) {
        if (_amount == 0) {
            return 0;
        }
        if (_token == address(0)) {
            require(msg.value >= _amount, 'ethers provided should be greater than _amount');

            if (_to != address(this)) {
                (bool success, ) = payable(_to).call{value: _amount}('');
                require(success, 'Transfer failed');
            }
            if (msg.value > _amount) {
                (bool success, ) = payable(address(msg.sender)).call{value: msg.value - _amount}('');
                require(success, 'Transfer failed');
            }
            return _amount;
        }
        if (_from == address(this)) {
            IERC20(_token).safeTransfer(_to, _amount);
        } else {
            //pool
            IERC20(_token).safeTransferFrom(_from, _to, _amount);
        }
        return _amount;
    }
}",989,128,"[H-02] Wrong returns of SavingsAccountUtil.depositFromSavingsAccount() can cause fund loss

Submitted by WatchPug
The function SavingsAccountUtil.depositFromSavingsAccount() is expected to return the number of equivalent shares for given _asset.
 However, since savingsAccountTransfer() does not return the result of _savingsAccount.transfer(), but returned _amount instead, which means that SavingsAccountUtil.depositFromSavingsAccount() may not return the actual shares (when pps is not 1).",1,,"pragma solidity 0.7.6;

import '../interfaces/ISavingsAccount.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';

library SavingsAccountUtil {
    using SafeERC20 for IERC20;

    function depositFromSavingsAccount(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy,
        bool _withdrawShares,
        bool _toSavingsAccount
    ) internal returns (uint256) {
        if (_toSavingsAccount) {
            return savingsAccountTransfer(_savingsAccount, _from, _to, _amount, _token, _strategy);
        } else {
            return withdrawFromSavingsAccount(_savingsAccount, _from, _to, _amount, _token, _strategy, _withdrawShares);
        }
    }

    function directDeposit(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        bool _toSavingsAccount,
        address _strategy
    ) internal returns (uint256) {
        if (_toSavingsAccount) {
            return directSavingsAccountDeposit(_savingsAccount, _from, _to, _amount, _token, _strategy);
        } else {
            return transferTokens(_token, _amount, _from, _to);
        }
    }

    function directSavingsAccountDeposit(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        transferTokens(_token, _amount, _from, address(this));
        uint256 _ethValue;
        if (_token == address(0)) {
            _ethValue = _amount;
        } else {
            address _approveTo = _strategy;
            if (_strategy == address(0)) {
                _approveTo = address(_savingsAccount);
            }
            IERC20(_token).safeApprove(_approveTo, _amount);
        }
        _sharesReceived = _savingsAccount.deposit{value: _ethValue}(_amount, _token, _strategy, _to);
    }

    function savingsAccountTransfer(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256) {
        if (_from == address(this)) {
            _savingsAccount.transfer(_amount, _token, _strategy, _to);
        } else {
            _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);
        }
        return _amount;
    }

    function withdrawFromSavingsAccount(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy,
        bool _withdrawShares
    ) internal returns (uint256 _amountReceived) {
        if (_from == address(this)) {
            _amountReceived = _savingsAccount.withdraw(_amount, _token, _strategy, payable(_to), _withdrawShares);
        } else {
            _amountReceived = _savingsAccount.withdrawFrom(_amount, _token, _strategy, _from, payable(_to), _withdrawShares);
        }
    }

    function transferTokens(
        address _token,
        uint256 _amount,
        address _from,
        address _to
    ) internal returns (uint256) {
        if (_amount == 0) {
            return 0;
        }
        if (_token == address(0)) {
            require(msg.value >= _amount, 'ethers provided should be greater than _amount');

            if (_to != address(this)) {
                (bool success, ) = payable(_to).call{value: _amount}('');
                require(success, 'Transfer failed');
            }
            if (msg.value > _amount) {
                (bool success, ) = payable(address(msg.sender)).call{value: msg.value - _amount}('');
                require(success, 'Transfer failed');
            }
            return _amount;
        }
        if (_from == address(this)) {
            IERC20(_token).safeTransfer(_to, _amount);
        } else {
            
            IERC20(_token).safeTransferFrom(_from, _to, _amount);
        }
        return _amount;
    }
}",979,1,0,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify that the imported `ReentrancyGuard` is used within the `ISavingsAccount` contract to prevent reentrancy attacks, particularly in the `deposit`, `transfer`, `withdraw`, `transferFrom`, and `withdrawFrom` functions. Analyze the potential impact if it's not implemented correctly."",
        ""Examine the `transferTokens` function for potential integer overflows/underflows, especially when handling ETH transfers with `msg.value`. Confirm that the `SafeERC20` library adequately protects against ERC20 vulnerabilities in token transfers."",
        ""Analyze the potential for front-running in the `directSavingsAccountDeposit` function between the `transferTokens` call and the `_savingsAccount.deposit` call. Propose mitigation strategies if a vulnerability exists (e.g., using a commit-reveal scheme or reducing the time window)."",
        ""Investigate the implications of transferring tokens to `address(this)` (the library's address) in `directSavingsAccountDeposit`. Ensure there are no scenarios where tokens could become unintentionally stuck in the library contract."",
        ""Analyze error handling in external calls (e.g., in `transferTokens` when transferring ETH using `payable(_to).call{value: _amount}('')`). Ensure proper revert behavior if the external call fails.  Specifically, confirm the 'Transfer failed' require statements are sufficient to revert the transaction and refund any ETH sent.""
      ]
    },
    {
      ""Area"": ""Compliance and Standards"",
      ""Tasks"": [
        ""Confirm that the `ISavingsAccount` interface adheres to relevant standards and best practices for savings account contracts. Check for any deviations that could lead to unexpected behavior or security issues."",
        ""Verify that the usage of the `SafeERC20` library is consistent with the ERC20 standard and that it correctly handles edge cases, such as tokens that do not return a boolean value on transfer.""
      ]
    },
    {
      ""Area"": ""Access Control and Authorization"",
      ""Tasks"": [
        ""Review the access control mechanisms within the `ISavingsAccount` contract to ensure that only authorized users can call the `transfer`, `transferFrom`, `withdraw`, and `withdrawFrom` functions.  Determine if there's a risk of unauthorized access or manipulation."",
        ""Analyze the `transferTokens` function and determine if there should be a check to ensure that `msg.sender` is equal to `_from` when handling ETH transfers. Evaluate the security implications if `msg.sender` is different from `_from`.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Examine the code for gas inefficiencies, such as redundant checks or unnecessary storage writes.  Specifically, analyze the conditional logic in `directSavingsAccountDeposit` regarding token approval, checking if any gas savings are possible."",
        ""Evaluate the impact of using a library versus inlining the functions within the calling contract, considering the gas costs associated with library calls."",
        ""In `transferTokens`, assess the gas cost of the `require(msg.value >= _amount, 'ethers provided should be greater than _amount');` statement and whether it's possible to reduce gas consumption (e.g., by using unchecked arithmetic if appropriate).""
      ]
    },
    {
      ""Area"": ""Logic and Parameter Handling"",
      ""Tasks"": [
        ""Clarify the intended use of the `_strategy` parameter in the different functions and how it relates to the approval logic in `directSavingsAccountDeposit`. Ensure that the logic is consistent and prevents unintended consequences."",
        ""Investigate the scenario where `_strategy` is zero address in `directSavingsAccountDeposit`. Verify that approving to savingsAccount is the correct handling in that case and doesn't introduce vulnerabilities."",
        ""Review the logic related to `_withdrawShares` in `withdrawFromSavingsAccount`. Understand how it affects the withdrawal process and confirm it functions as expected."",
        ""Analyze the edge case in `transferTokens` where `_amount` is 0. Ensure that the function returns correctly and doesn't introduce unexpected side effects.""
      ]
    },
     {
      ""Area"": ""Unhandled edge cases and assumptions"",
      ""Tasks"":[
          ""If `_from == address(this)` on transferToken, then is there any access control on the IERC20 contract to ensure that `address(this)` has enough tokens to send to `_to`?"",
          ""In `transferTokens`, When transferring ETH, why is `msg.sender` given back the difference between `msg.value` and `_amount`?  Under what circumstances would `msg.value` be greater than `_amount`? Is this assumption handled correctly to avoid unexpected refunds?""
        ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code snippet defines a library `SavingsAccountUtil` that provides utility functions for interacting with a SavingsAccount contract. It includes functionalities for depositing, transferring, and withdrawing tokens (including ETH) between different accounts and the SavingsAccount contract. It utilizes SafeERC20 for safe token transfers and includes checks for zero addresses and sufficient ETH balance. The code handles both direct deposits and transfers from savings accounts, distinguishing between transferring to an external account or another savings account."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""SavingsAccountUtil"",
    ""Purpose"": ""Provides utility functions for interacting with a SavingsAccount contract, including deposit, transfer, and withdraw functionalities."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [],
      ""Imports"": [
        ""../interfaces/ISavingsAccount.sol"",
        ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"",
        ""@openzeppelin/contracts/utils/ReentrancyGuard.sol""
      ]
    },
    ""StateVariables"": [],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""depositFromSavingsAccount"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Deposits tokens either directly or via savings account transfer based on the `_toSavingsAccount` flag."",
        ""Parameters"": [
          ""ISavingsAccount _savingsAccount"",
          ""address _from"",
          ""address _to"",
          ""uint256 _amount"",
          ""address _token"",
          ""address _strategy"",
          ""bool _withdrawShares"",
          ""bool _toSavingsAccount""
        ],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""directDeposit"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Deposits tokens either directly or by transferring them to the destination account based on `_toSavingsAccount`."",
        ""Parameters"": [
          ""ISavingsAccount _savingsAccount"",
          ""address _from"",
          ""address _to"",
          ""uint256 _amount"",
          ""address _token"",
          ""bool _toSavingsAccount"",
          ""address _strategy""
        ],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""directSavingsAccountDeposit"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers tokens to the contract, approves the savings account or strategy, and then deposits into the savings account."",
        ""Parameters"": [
          ""ISavingsAccount _savingsAccount"",
          ""address _from"",
          ""address _to"",
          ""uint256 _amount"",
          ""address _token"",
          ""address _strategy""
        ],
        ""Returns"": [""uint256 _sharesReceived""]
      },
      {
        ""Name"": ""savingsAccountTransfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers tokens within the SavingsAccount contract."",
        ""Parameters"": [
          ""ISavingsAccount _savingsAccount"",
          ""address _from"",
          ""address _to"",
          ""uint256 _amount"",
          ""address _token"",
          ""address _strategy""
        ],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""withdrawFromSavingsAccount"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Withdraws tokens from the SavingsAccount contract."",
        ""Parameters"": [
          ""ISavingsAccount _savingsAccount"",
          ""address _from"",
          ""address _to"",
          ""uint256 _amount"",
          ""address _token"",
          ""address _strategy"",
          ""bool _withdrawShares""
        ],
        ""Returns"": [""uint256 _amountReceived""]
      },
      {
        ""Name"": ""transferTokens"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers tokens between two addresses, handling both ERC20 tokens and ETH."",
        ""Parameters"": [
          ""address _token"",
          ""uint256 _amount"",
          ""address _from"",
          ""address _to""
        ],
        ""Returns"": [""uint256""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ISavingsAccount (interface for interacting with a SavingsAccount contract)"",
    ""IERC20 (interface for interacting with ERC20 tokens)""
  ],
  ""SpecialMechanisms"": [
    ""Uses SafeERC20 library for safe token transfers, preventing common ERC20 transfer errors."",
    ""Handles ETH transfers separately due to the need to check `msg.value` and use `payable.call{value: ...}`."",
    ""Conditional logic for approvals depending on the strategy address in the directSavingsAccountDeposit function.""
  ],
  ""Questions"": [
    ""Why is `ReentrancyGuard` imported but not used in this library?  Is its use expected in the SavingsAccount contract itself?"",
    ""In `transferTokens`, when transferring ETH, why is `msg.sender` given back the difference between `msg.value` and `_amount`?  Under what circumstances would `msg.value` be greater than `_amount`?"",
    ""Is there a risk of front-running in `directSavingsAccountDeposit` between the `transferTokens` and `_savingsAccount.deposit` calls?"",
    ""What is the intended use of `_strategy` parameter in different functions and how does it relate to approval logic?"",
    ""Should the msg.value >= _amount check in transferTokens also check that msg.sender is the _from address?"",
    ""Is there any access control on the SavingsAccount contract to limit who can call transfer/transferFrom/withdraw/withdrawFrom?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `directSavingsAccountDeposit`"",
      ""Severity"": ""High"",
      ""Description"": ""The `directSavingsAccountDeposit` function makes external calls to `_savingsAccount.deposit` after transferring tokens using `transferTokens`. If the `_savingsAccount.deposit` function (or any function it calls) re-enters this contract before the initial call completes, it could lead to unexpected state changes, token manipulations, or theft of funds. The library uses `ReentrancyGuard`, but it's not applied within the library's code itself, or within ISavingsAccount interface, rendering it ineffective."",
      ""Impact"": ""Potential for theft of funds or manipulation of contract state due to reentrancy."",
      ""Location"": ""SavingsAccountUtil.sol: directSavingsAccountDeposit function, multiple locations where ISavingsAccount functions are called""
    },
    {
      ""Issue"": ""Potential Reentrancy Risk with External Calls in `transferTokens`"",
      ""Severity"": ""High"",
      ""Description"": ""The `transferTokens` function contains external calls to the `_to` address and `msg.sender` when `_token` is the zero address (ETH).  These external calls are vulnerable to reentrancy attacks. A malicious contract at `_to` or `msg.sender` could call back into the calling contract during the transfer, potentially leading to unexpected state changes and loss of funds. Although the `ReentrancyGuard` modifier is used in other parts of the code, it is not present in the `SavingsAccountUtil` library, making it vulnerable."",
      ""Impact"": ""Critical. Could allow an attacker to drain funds from the contract through reentrancy."",
      ""Location"": ""SavingsAccountUtil.sol: transferTokens function""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `directSavingsAccountDeposit`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In `directSavingsAccountDeposit`, tokens are transferred and then the strategy is approved. A malicious actor could front-run the `deposit` transaction after the transfer and approval, but before the deposit is executed. This allows the attacker to manipulate the state of the `_savingsAccount` or `_strategy`, or spend the approved tokens before the savings account can deposit them, potentially leading to loss of funds for the depositor. Approval to `_strategy` or `_savingsAccount` could be frontrun."",
      ""Impact"": ""Potential for malicious actors to exploit the time delay between token transfer, approval and deposit, leading to loss of funds or unexpected behavior."",
      ""Location"": ""SavingsAccountUtil.sol: directSavingsAccountDeposit function""
    },
    {
      ""Issue"": ""Missing Input Validation for `_amount` in Multiple Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions, including `directSavingsAccountDeposit`, `savingsAccountTransfer`, `withdrawFromSavingsAccount`, and `transferTokens`, lack explicit input validation for the `_amount` parameter. There is no check to ensure `_amount` is greater than zero or prevent excessively large amounts that could cause downstream integer overflow/underflow issues or unexpected behavior in `ISavingsAccount` contract. Functions lack validation to ensure `_from` has sufficient balance before calling `transferTokens` which could cause inconsistencies in contract state."",
      ""Impact"": ""Potential for DoS or unexpected behavior due to zero-value or excessively large deposits, or failure if `_from` has insufficient balance."",
      ""Location"": ""SavingsAccountUtil.sol: `directSavingsAccountDeposit`, `savingsAccountTransfer`, `withdrawFromSavingsAccount`, `transferTokens`""
    },
    {
      ""Issue"": ""Potential Denial-of-Service (DoS) in `transferTokens` when transferring ETH"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `transferTokens` function, when transferring ETH, the code uses `payable(_to).call{value: _amount}(\'\')` to transfer the ETH. If the `_to` address is a contract that reverts, or consumes all gas, the ETH transfer will fail, and the entire transaction will be reverted, potentially causing a denial-of-service if this function is a critical part of a larger process. Sending remaining value back to `msg.sender` can also fail and cause DoS."",
      ""Impact"": ""The contract could be made unusable if an attacker can control the recipient of the ETH transfer."",
      ""Location"": ""SavingsAccountUtil.sol: transferTokens function, ETH transfer section""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `transferTokens` when handling ETH transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `transferTokens` function, when handling ETH transfers, the code calculates `msg.value - _amount` to return excess ETH to the sender. While Solidity 0.8.0+ has built-in overflow/underflow protection, this code is written for 0.7.6 which does not, potentially causing issues if `msg.value` is less than `_amount` or if `msg.value` is very large, close to the maximum `uint256` value, and `_amount` is also very large, then the check `msg.value > _amount` could lead to an integer overflow .Although the `require(msg.value >= _amount, \'ethers provided should be greater than _amount\');` mitigates this, the code does not perform explicit overflow checks to ensure its safety."",
      ""Impact"": ""Potential incorrect ETH transfer amounts or reverted transactions due to overflow/underflow if the initial `require` check fails."",
      ""Location"": ""SavingsAccountUtil.sol: transferTokens function, ETH transfer section""
    },
    {
      ""Issue"": ""Inconsistent or Incorrect `msg.value` Check and Handling in `transferTokens`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `transferTokens` function, being internal, uses `msg.value` to handle ETH transfers and refunds. This is unreliable, as `msg.value` reflects the value of the outermost call, not necessarily the specific `transferTokens` call. This can lead to incorrect `msg.value` checks, potentially reverting transactions or causing unexpected behavior. This includes the requirement that `msg.value` must be greater than or equal to `_amount`, which assumes that the sole purpose of calling the function is ETH transfer. "",
      ""Impact"": ""Potential unexpected behavior and incorrect ETH handling if the function is called with additional ETH that is not intended for transfer."",
      ""Location"": ""SavingsAccountUtil.sol: transferTokens function, ETH transfer section""
    },
    {
      ""Issue"": ""Unchecked Return Value of Low-Level Call for ETH transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `transferTokens` function uses a low-level `call` to transfer Ether and send back remaining eth to `msg.sender`. While the code checks `success`, there\'s no check to see if the target address is a contract. Furthermore, the call forwards all available gas. If the target is a contract it could consume all gas or revert for any reason.  Additionally, if the target address is not payable, this call will fail silently relying on the success of the low-level call without additional checks can be risky"",
      ""Impact"": ""The transaction might revert unexpectedly if the external call fails, leading to unpredictable behavior. Furthermore, the lack of gas limit specification can lead to gas exhaustion."",
      ""Location"": ""SavingsAccountUtil.sol: transferTokens function, lines involving `payable(_to).call{value: _amount}(\'\')` and `payable(address(msg.sender)).call{value: msg.value - _amount}(\'\')`""
    },
    {
      ""Issue"": ""Potential rounding errors in `_savingsAccount.deposit` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `directSavingsAccountDeposit` function uses the `_savingsAccount.deposit` function. If the `deposit` function calculates shares based on an exchange rate, there could be rounding errors, leading to a loss of precision, especially with large amounts or volatile exchange rates. While this issue resides in the `ISavingsAccount` contract, it\'s important to consider it during integration.  A specific implementation of ISavingsAccount could be vulnerable"",
      ""Impact"": ""Potential loss of precision in share calculation during deposit, leading to small discrepancies for users."",
      ""Location"": ""SavingsAccountUtil.sol: directSavingsAccountDeposit""
    },
    {
      ""Issue"": ""Unnecessary Approval in `directSavingsAccountDeposit` when `_strategy` is Zero Address."",
      ""Severity"": ""Low"",
      ""Description"": ""In the `directSavingsAccountDeposit` function, when `_strategy` is the zero address, the code approves the `_savingsAccount` contract to spend tokens.  If the _savingsAccount wants to deposit the token to some strategy, then approval to the strategy is expected. Otherwise, approving savingsAccount without depositing to any strategy introduces unnecessary risk. The contract approving itself doesn't make sense. This creates a redundant token transfer, which is inefficient and could potentially lead to unexpected behavior. Approve to address(0) effectively revokes any prior approvals"",
      ""Impact"": ""Gas inefficiency, potential for confusion, or redundant approval creates unnecessary attack surface."",
      ""Location"": ""SavingsAccountUtil.sol: directSavingsAccountDeposit function""
    },
    {
      ""Issue"": ""Missing Zero-Address Check for Function Arguments"",
      ""Severity"": ""Low"",
      ""Description"": ""Several functions take addresses as arguments (`_to`, `_from`, `_token`, `_strategy`). There are no explicit checks to ensure these addresses are not the zero address (address(0)). Passing the zero address could lead to unexpected behavior or vulnerabilities depending on how these addresses are used within the functions. It is good practice to explicitly check for transfers to the zero address to prevent potential issues."",
      ""Impact"": ""Unintended behavior or vulnerabilities depending on the context. Potential for loss of funds or unexpected behavior if tokens are sent to the zero address."",
      ""Location"": ""SavingsAccountUtil.sol: multiple functions""
    },
    {
      ""Issue"": ""Potential for Front-Running in `directSavingsAccountDeposit` when `_strategy` is zero address"",
      ""Severity"": ""Low"",
      ""Description"": ""If `_strategy` is the zero address in `directSavingsAccountDeposit`, the SavingsAccount contract is approved to spend tokens. A malicious actor could monitor the transaction pool and front-run the `deposit` call, potentially stealing tokens before the SavingsAccount contract can deposit them, requiring the user to have pre-approved the SavingsAccount."",
      ""Impact"": ""Potential theft of funds if the user has pre-approved the SavingsAccount."",
      ""Location"": ""SavingsAccountUtil.sol: directSavingsAccountDeposit function (approval logic)""
    },
    {
      ""Issue"": ""Unnecessary check for `_from == address(this)`"",
      ""Severity"": ""Low"",
      ""Description"": ""In functions like `savingsAccountTransfer` and `withdrawFromSavingsAccount`, there is a check for `_from == address(this)`. The behavior differs slightly depending on this check.  However, given the usage of `safeTransferFrom` in `transferTokens` and the expected behavior of SavingsAccount implementations, the `_from == address(this)` branch could potentially be simplified or removed."",
      ""Impact"": ""Slightly more complex code, potential for minor gas optimization if the `_from == address(this)` branch is unnecessary."",
      ""Location"": ""SavingsAccountUtil.sol:64, SavingsAccountUtil.sol:92""
    },
    {
      ""Issue"": ""Missing Error Message in `savingsAccountTransfer` function."",
      ""Severity"": ""Info"",
      ""Description"": ""In the `savingsAccountTransfer` function, it makes a call to either `_savingsAccount.transfer` or `_savingsAccount.transferFrom`. The contract assumes that these functions will revert upon error and bubble that error up. However, there should be an error message for better error handling and debugging."",
      ""Impact"": ""Error handling/debugging."",
      ""Location"": ""SavingsAccountUtil.sol:57-64""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 14
}",191.2739598751068,3332.0,33.0,"---

**[H-02] Wrong returns of SavingsAccountUtil.depositFromSavingsAccount() can cause fund loss**

**Report Description**:
The function `SavingsAccountUtil.depositFromSavingsAccount()` is expected to return the number of equivalent shares for a given `_asset`. However, `savingsAccountTransfer()` does not return the result of `_savingsAccount.transfer()`, but instead returns `_amount`. This means that `SavingsAccountUtil.depositFromSavingsAccount()` may not return the actual shares when the price per share (pps) is not 1. This discrepancy can lead to incorrect accounting of shares, potentially causing fund loss or misallocation of assets.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of incorrect returns in `SavingsAccountUtil.depositFromSavingsAccount()`. While the response list covers various vulnerabilities such as reentrancy, front-running, and input validation, it does not mention or address the issue of incorrect share calculations or return values in the context of `depositFromSavingsAccount()`. This is a critical oversight, as the issue directly impacts the accuracy of share calculations and could lead to fund loss.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-02] Wrong returns of SavingsAccountUtil.depositFromSavingsAccount() can cause fund loss**

---

The response list fails to address the specific issue of incorrect returns in `SavingsAccountUtil.depositFromSavingsAccount()`, which is a critical vulnerability that could lead to fund loss. This gap highlights the need for a more comprehensive review of the contract's return value handling and accounting mechanisms.","```
None.
```",0.0
Pool.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}",10152,1045,"[H-03] denial of service

Submitted by certora
https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/Pool/Pool.sol#L645 if the borrow token is address(0) (ether), and someone calls withdrawLiquidity, it calls SavingsAccountUtil.transferTokens which will transfer to msg.sender, msg.value (of withdrawLiquidity, because it's an internal function). In other words, the liquidity provided will pay to themselves and their liquidity tokens will still be burned. therefore they will never be able to get their funds back.
  [M-03] Collateral can be deposited in a finished pool

The `_depositCollateral` function doesn't check the status of the pool so collateral can be deposited in a finished loan. This can happen by mistake and all funds will be lost.
https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L207

",2,,"pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';


contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, 
        ACTIVE, 
        CLOSED, 
        CANCELLED, 
        DEFAULTED, 
        TERMINATED 
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; 
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    
    mapping(address => LendingDetails) public lenders;

    
    PoolConstants public poolConstants;

    
    PoolVariables public poolVariables;

    
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        

        
        
        
        
        
        
        
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            
            _withdrawRepayment(msg.sender);
        }
        
        _burn(msg.sender, _actualBalance);

        
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    
    receive() external payable {}

    
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}",7067,1,1,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities: Reentrancy"",
      ""Tasks"": [
        ""Verify that all external calls, especially those interacting with SavingsAccountUtil, are protected against reentrancy, even if the ReentrancyGuard is in place. Focus on calls within `_deposit`, `_withdraw`, `_withdrawAllCollateral`, `liquidatePool`, and `liquidateForLender`."",
        ""Analyze potential reentrancy scenarios where the SavingsAccount contract could call back into the Pool contract before a previous state update is complete. Special attention should be given to cases where collateral is transferred.""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities: Arithmetic Overflows/Underflows"",
      ""Tasks"": [
        ""Confirm that SafeMath is consistently used throughout the contract, especially in calculations involving shares, collateral ratios, and interest, to prevent overflows or underflows. Ensure no instances of unchecked arithmetic exist."",
        ""Specifically, check calculations within `calculateCollateralRatio`, `getCurrentCollateralRatio`, `_updateLenderSharesDuringLiquidation`, `correspondingBorrowTokens`, and `interestPerSecond` for potential overflows.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that the `onlyBorrower`, `isLender`, `onlyOwner`, and `onlyRepaymentImpl` modifiers correctly restrict access to sensitive functions. Confirm that the `poolFactory` address is correctly set and that the `PoolFactory` contract's ownership is properly managed."",
        ""Review the `terminatePool` function to ensure that only the intended owner can call it and that its functionality is appropriate and secure."",
        ""Examine the `closeLoan` function to ensure that only the `repaymentImpl` contract can call it, preventing unauthorized closure of loans.""
      ]
    },
    {
      ""Area"": ""External Interactions and Trust Assumptions"",
      ""Tasks"": [
        ""Carefully audit the interactions with the `IPoolFactory`, `IPriceOracle`, `IYield`, `IRepayment`, `ISavingsAccount`, `IVerification`, and `IExtension` contracts. Analyze potential risks associated with these external calls, such as incorrect data or malicious behavior."",
        ""Assess the trust assumptions made regarding the accuracy of the `IPriceOracle`'s price feeds and the potential impact of price manipulation on the pool's solvency and liquidation mechanisms. Consider the possibility of using TWAP or other price aggregation methods."",
        ""Analyze the impact of a malicious or compromised `SavingsAccount` contract on the `Pool` contract, especially in deposit and withdrawal operations. Evaluate the possibility of using a more robust and secure savings account implementation."",
        ""Examine the role of the `IVerification` contract and ensure that its user verification process is secure and reliable, preventing unauthorized access or manipulation of the pool."",
        ""Review the external call to `ERC20Upgradeable(_borrowAsset).decimals()` within `initialize` to confirm its safety and handle cases where the ERC20 token does not implement the `decimals()` function or returns an unexpected value.""
      ]
    },
    {
      ""Area"": ""Liquidation and Margin Calls"",
      ""Tasks"": [
        ""Thoroughly review the liquidation logic in `liquidatePool` and `liquidateForLender` to ensure that liquidations are performed correctly and that lenders are appropriately compensated. Check the calculations involving collateral ratios, liquidation penalties, and liquidator rewards."",
        ""Analyze potential vulnerabilities in the margin call mechanism, including the calculation of `marginCallEndTime` and the conditions under which margin calls are triggered. Ensure that the system is resistant to manipulation or denial-of-service attacks."",
        ""Evaluate the potential for griefing attacks where malicious actors could trigger unnecessary margin calls, causing inconvenience or financial harm to lenders."",
        ""Investigate the impact of rounding errors on the calculation of liquidation amounts and lender shares, and ensure that these errors do not disproportionately favor liquidators or harm lenders.""
      ]
    },
    {
      ""Area"": ""Tokenomics and Incentive Mechanisms"",
      ""Tasks"": [
        ""Analyze the tokenomics of the pool tokens and the potential for inflationary token models. Ensure that the supply and distribution of tokens are well-defined and that there are no unintended consequences."",
        ""Examine the incentive mechanisms for lenders and borrowers and ensure that they are aligned with the overall goals of the lending platform. Evaluate the potential for manipulation or abuse of these incentives."",
        ""Review the calculation of interest rates and fees to ensure that they are fair and transparent. Check for any hidden fees or charges that could harm lenders or borrowers.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify potential gas inefficiencies in the contract and explore opportunities for optimization. Focus on areas such as storage access, loop iterations, and complex calculations."",
        ""Consider using more efficient data structures or algorithms to reduce gas consumption."",
        ""Evaluate the potential benefits of using assembly code for gas-intensive operations.""
      ]
    },
    {
      ""Area"": ""Cancellation Penalties"",
      ""Tasks"": [
        ""Examine the logic for calculating and applying cancellation penalties in the `cancelPool` function. Verify that the penalty is calculated correctly and that it is fairly distributed among lenders."",
        ""Analyze the potential for manipulation of the cancellation penalty mechanism, such as intentionally triggering a cancellation to profit from the penalty fees."",
        ""Assess the impact of the cancellation penalty on lenders and borrowers, and ensure that it is not excessively punitive or unfair.""
      ]
    },
    {
      ""Area"": ""Repayment Logic"",
      ""Tasks"": [
        ""Carefully analyze the `_withdrawRepayment` and `calculateRepaymentWithdrawable` functions to ensure accurate calculation and distribution of repayment amounts to lenders."",
        ""Investigate whether there's a potential issue due to the `_beforeTokenTransfer` function calling both `_withdrawRepayment(_from)` and `_withdrawRepayment(_to)`. This could lead to unintended consequences, such as double withdrawals or incorrect interest calculations. Assess if this is the intended behavior, or if it needs adjustment to avoid any discrepancies.""
      ]
    },
    {
      ""Area"": ""Pool States and Transitions"",
      ""Tasks"": [
        ""Thoroughly examine the transitions between different `LoanStatus` states and ensure that these transitions are secure and follow the intended logic. Pay close attention to the conditions that trigger each state transition."",
        ""Verify that the contract behaves correctly and securely in each state, and that there are no unintended consequences when transitioning between states.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines a smart contract `Pool` for managing lending pools. It handles collateral deposits, loan disbursements, repayments, liquidations, and other pool-related operations. The contract leverages OpenZeppelin libraries for ERC20 token functionality, safe math operations, and reentrancy protection. It interacts with several external contracts via interfaces, including a PoolFactory, PriceOracle, Yield, Repayment, SavingsAccount, and Verification contracts. The contract implements a lending pool with functionalities for lenders and borrowers. It seems to be part of a larger DeFi lending platform."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""Pool"",
    ""Purpose"": ""Manages a lending pool, handling collateral, loans, repayments, and liquidations."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Initializable"",
        ""ERC20PausableUpgradeable"",
        ""IPool"",
        ""ReentrancyGuard""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"",
        ""@openzeppelin/contracts/math/SafeMath.sol"",
        ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"",
        ""@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol"",
        ""../interfaces/IPoolFactory.sol"",
        ""../interfaces/IPriceOracle.sol"",
        ""../interfaces/IYield.sol"",
        ""../interfaces/IRepayment.sol"",
        ""../interfaces/ISavingsAccount.sol"",
        ""../SavingsAccount/SavingsAccountUtil.sol"",
        ""../interfaces/IPool.sol"",
        ""../interfaces/IExtension.sol"",
        ""../interfaces/IVerification.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""poolFactory"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the PoolFactory contract.""
      },
      {
        ""Name"": ""lenders"",
        ""Type"": ""mapping(address => LendingDetails)"",
        ""Purpose"": ""Stores lending details for each lender.""
      },
      {
        ""Name"": ""poolConstants"",
        ""Type"": ""PoolConstants"",
        ""Purpose"": ""Stores constant pool parameters like borrower, loan amounts, rates, etc.""
      },
      {
        ""Name"": ""poolVariables"",
        ""Type"": ""PoolVariables"",
        ""Purpose"": ""Stores variable pool parameters like liquidity shares, loan status, penalty amounts, etc.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the pool with loan parameters and collateral."",
        ""Parameters"": [
          ""_borrowAmountRequested"",
          ""_borrowRate"",
          ""_borrower"",
          ""_borrowAsset"",
          ""_collateralAsset"",
          ""_idealCollateralRatio"",
          ""_repaymentInterval"",
          ""_noOfRepaymentIntervals"",
          ""_poolSavingsStrategy"",
          ""_collateralAmount"",
          ""_transferFromSavingsAccount"",
          ""_lenderVerifier"",
          ""_loanWithdrawalDuration"",
          ""_collectionPeriod""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""depositCollateral"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Deposits collateral into the pool."",
        ""Parameters"": [""_amount"", ""_transferFromSavingsAccount""],
        ""Returns"": []
      },
      {
        ""Name"": ""addCollateralInMarginCall"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds collateral during a margin call."",
        ""Parameters"": [""_lender"", ""_amount"", ""_transferFromSavingsAccount""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawBorrowedAmount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the borrower to withdraw the borrowed amount."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""lend"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows lenders to lend tokens to the pool."",
        ""Parameters"": [""_lender"", ""_amount"", ""_strategy""],
        ""Returns"": []
      },
      {
        ""Name"": ""cancelPool"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Cancels the pool and returns collateral."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""liquidateCancelPenalty"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Liquidates the pool cancellation penalty."",
        ""Parameters"": [""_toSavingsAccount"", ""_receiveLiquidityShare""],
        ""Returns"": []
      },
      {
        ""Name"": ""terminatePool"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Terminates the pool and withdraws all collateral."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""closeLoan"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Closes the loan and withdraws all collateral."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows lenders to withdraw liquidity from the pool."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""requestMarginCall"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows lenders to request a margin call."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""liquidatePool"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Liquidates the pool in case of borrower default."",
        ""Parameters"": [
          ""_fromSavingsAccount"",
          ""_toSavingsAccount"",
          ""_recieveLiquidityShare""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""liquidateForLender"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Liquidates specific lender position."",
        ""Parameters"": [
          ""_lender"",
          ""_fromSavingsAccount"",
          ""_toSavingsAccount"",
          ""_recieveLiquidityShare""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyBorrower"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts access to functions to the borrower."",
        ""Parameters"": [""_user""],
        ""Returns"": []
      },
      {
        ""Name"": ""isLender"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts access to functions to lenders."",
        ""Parameters"": [""_lender""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyOwner"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts access to functions to the PoolFactory owner."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyRepaymentImpl"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts access to functions to the Repayment contract."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IPoolFactory (poolFactory)"",
    ""IPriceOracle"",
    ""IYield"",
    ""IRepayment"",
    ""ISavingsAccount"",
    ""IVerification"",
    ""IExtension"",
    ""ERC20Upgradeable(_borrowAsset)""
  ],
  ""SpecialMechanisms"": [
    ""ReentrancyGuard is used to prevent reentrancy attacks."",
    ""Initializable from OpenZeppelin is used for upgradeable contracts."",
    ""Uses a LoanStatus enum to track the state of the loan."",
    ""SavingsAccountUtil library for deposit and withdrawal operations with SavingsAccount contract."",
    ""Margin call functionality to allow lenders to request additional collateral."",
    ""Liquidation mechanisms for both the entire pool and individual lenders.""
  ],
  ""Questions"": [
    ""What is the purpose of the `_strategy` parameter in the `lend` function, and how does it relate to `_fromSavingsAccount`?"",
    ""The `getMarginCallEndTime` function checks if block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2)). Why are we multiplying marginCallDuration by 2?"",
    ""The contract uses a `PoolFactory` to retrieve addresses of other contracts. What is the role of the `PoolFactory` contract in the overall architecture?"",
    ""How is the `_penalty` calculated in the `cancelPool` function, and what is its purpose?"",
    ""What is the noStrategyAddress() used for in liquidatePool()?"",
    ""The `_beforeTokenTransfer` function calls both `_withdrawRepayment(_from)` and `_withdrawRepayment(_to)`. Is this intended? Could there be unintended consequences, such as double withdrawals or incorrect interest calculations?"",
    ""The use of division in many calculations might lead to precision issues. Are there any considerations to mitigate these issues, especially in terms of rounding errors affecting lenders or borrowers?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in Liquidation Flows"",
      ""Severity"": ""High"",
      ""Description"": ""The `liquidatePool`, `liquidateForLender`, `_liquidateForLender`, `_deposit` and `_withdraw` functions involve external calls to `SavingsAccountUtil.depositFromSavingsAccount` and `SavingsAccountUtil.transferTokens`, which can potentially re-enter the pool contract if the SavingsAccount or the underlying Yield contract have vulnerabilities, potentially manipulating the pool's state, draining funds or causing other unexpected behavior."",
      ""Impact"": ""A malicious SavingsAccount or Yield contract could re-enter the Pool contract and manipulate its state, potentially draining funds or causing other unexpected behavior."",
      ""Location"": ""Functions: `liquidatePool`, `liquidateForLender`, `_liquidateForLender`, `_deposit`, `_withdraw`. Calls to `SavingsAccountUtil.depositFromSavingsAccount` and `SavingsAccountUtil.transferTokens`""
    },
    {
      ""Issue"": ""Incorrect Usage of `transferTokens` Function in `liquidateCancelPenalty`"",
      ""Severity"": ""High"",
      ""Description"": ""In the `liquidateCancelPenalty` function, the code attempts to transfer `_liquidationTokens` (borrow asset) from the `msg.sender` to the address(this). However, the `SavingsAccountUtil.transferTokens` function expects the tokens to be transferred *from* the contract to the specified address. In this scenario the function fails to consider that `msg.sender` should approve the contract before calling `transferTokens`. Therefore, it is highly likely this transfer will fail, bricking the liquidation process."",
      ""Impact"": ""Liquidation process being blocked due to failed token transfer, preventing recovery of funds for lenders."",
      ""Location"": ""Pool.sol:549""
    },
    {
      ""Issue"": ""Vulnerability Due to `depositFromSavingsAccount` Returning Incorrect Shares."",
      ""Severity"": ""High"",
      ""Description"": ""The core logic within the contract relies heavily on the `SavingsAccountUtil.depositFromSavingsAccount` function to return the correct number of shares that are generated upon a deposit. If the SavingsAccount implementation is compromised or has a bug where it returns the wrong number of shares, then the `baseLiquidityShares` and `extraLiquidityShares` state variables within the Pool contract would be incorrect. The state variables would then be used to determine the amount of collateral for lenders in the event of liquidations and withdrawals. This would cause a significant vulnerability where lenders could be short-changed and liquidators could profit."",
      ""Impact"": ""Loss of funds due to incorrect calculations of liquidity and shares. It could benefit liquidators at the expense of lenders or vice-versa. Total loss of funds of liquidity and/or bad debts."",
      ""Location"": ""`_deposit` and other functions that depend on `SavingsAccountUtil.depositFromSavingsAccount`'s returned shares.""
    },
    {
      ""Issue"": ""Missing Zero-Address Checks in `initialize()`"",
      ""Severity"": ""High"",
      ""Description"": ""The `initialize()` function does not validate that address parameters like `_borrowAsset`, `_collateralAsset`, `_poolSavingsStrategy`, and `_lenderVerifier` are not the zero address. Failing to check for the zero address could lead to unexpected behavior, as the contract would attempt to interact with an invalid address. This can lead to reverts or incorrect calculations."",
      ""Impact"": ""Contract reverts, incorrect calculations, denial of service, or potential exploits if interacting with external contracts via the zero address."",
      ""Location"": ""Pool.sol: `initialize()` function parameters `_borrowAsset`, `_collateralAsset`, `_poolSavingsStrategy`, `_lenderVerifier`.""
    },
    {
      ""Issue"": ""Lack of Access Control on `terminatePool` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `terminatePool` function can only be called by the owner (PoolFactory's owner), giving them complete control over the pool's termination and collateral withdrawal, potentially harming participants and creating a single point of failure. No checks ensure the pool has reached a certain state before termination."",
      ""Impact"": ""Potential for unauthorized or malicious pool termination by the PoolFactory owner, leading to loss of funds for lenders."",
      ""Location"": ""`terminatePool`""
    },
    {
      ""Issue"": ""Incorrect Calculation of Penalty in `cancelPool`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The penalty applied for cancelling a pool, especially when the loan has not started, depends on `block.timestamp`. The penalty time calculated, and thus the final penalty is dependent on `block.timestamp`. This could result in an incorrect penalty amount depending on when the function is called. In addition, there are rounding errors in the calculations."",
      ""Impact"": ""Incorrect penalty amount applied for cancelling a pool, especially when the loan has not started, or deadline has passed, potentially favoring either the borrower or lenders unfairly."",
      ""Location"": ""`cancelPool`, `_calculatePenaltyTime`""
    },
    {
      ""Issue"": ""Lack of Slippage Control during Liquidations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The liquidation functions (`liquidatePool`, `liquidateForLender`) and `correspondingBorrowTokens` depend on `IPriceOracle` for token values without slippage control. Price fluctuations could lead to liquidators receiving a significantly lower amount of borrow tokens, or the liquidation may fail."",
      ""Impact"": ""Liquidators could suffer losses due to unfavorable price slippage during the liquidation process. Also, the liquidation may fail if the price moves too much."",
      ""Location"": ""`liquidatePool`, `liquidateForLender`, `correspondingBorrowTokens`.""
    },
    {
      ""Issue"": ""Unbounded Loops possible during lender liquidation"",
      ""Severity"": ""Medium"",
      ""Description"": ""If `_withdrawRepayment` fails to transfer funds out, then calling this on an eligible lender could lead to an out of gas error, as state will be changed, however no tokens will be transferred. In the event that the savings account's `transferTokens` or underlying yield token transfer reverts, the caller will experience an unexpected out of gas condition if looping."",
      ""Impact"": ""If `_withdrawRepayment` fails, then any lender can get DoS\'d during lender liquidation with an out of gas error."",
      ""Location"": ""`_liquidateForLender`""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `lend` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""A malicious actor could monitor the mempool for `lend` transactions and front-run them, especially if the pool is nearing its borrow amount request. By front-running, the attacker could secure a disproportionate share of the pool tokens and subsequently manipulate the pool."",
      ""Impact"": ""Possibility of unfair allocation of pool tokens and potential manipulation of the pool by front-running."",
      ""Location"": ""Pool.sol:406, `lend`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Share Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions, particularly those dealing with share calculations (e.g., calculating lender's share of liquidity in `getCurrentCollateralRatio`, `_updateLenderSharesDuringLiquidation`, `_beforeTokenTransfer`), involve multiplication and division operations on `uint256` values. While SafeMath is used, a carefully crafted scenario with extremely large or small numbers could potentially lead to intermediate results that exceed the maximum or minimum value of `uint256`, causing unexpected behavior despite the SafeMath protections."",
      ""Impact"": ""Incorrect calculation of shares, potentially leading to inaccurate distribution of funds and potentially incorrect interest withdrawal amounts."",
      ""Location"": ""`getCurrentCollateralRatio`, `_updateLenderSharesDuringLiquidation`, `_beforeTokenTransfer`, other functions involving share calculations.""
    },
    {
      ""Issue"": ""Inconsistent Use of Transfer vs. Send/Call"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses `SavingsAccountUtil.transferTokens` for transferring ERC20 tokens but doesn't explicitly handle the success or failure of the transfer. While SafeERC20 is used, it reverts on failure, but if there are native ETH transfers, it can lead to stuck ETH or unexpected behavior if the recipient is a contract that doesn't accept ETH."",
      ""Impact"": ""Potential loss of funds if a transfer fails silently or if ETH is sent to a contract that cannot handle it."",
      ""Location"": ""Functions using `SavingsAccountUtil.transferTokens`, especially within `withdrawBorrowedAmount` when transferring to the protocol fee collector, and `withdrawLiquidity`.""
    },
    {
      ""Issue"": ""Lack of Input Validation for Critical Parameters in `initialize` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `initialize` function, which is crucial for setting up the pool, lacks sufficient input validation. For instance, there are no checks to ensure that `_borrowAmountRequested`, `_borrowRate`, `_idealCollateralRatio`, `_repaymentInterval`, and `_noOfRepaymentIntervals` are within reasonable bounds. A malicious or mistaken input for these parameters could render the pool unusable or lead to significant financial losses."",
      ""Impact"": ""Pool can be created with incorrect parameters, which could lead to unexpected behavior, financial losses for lenders or borrowers, or even a denial-of-service condition."",
      ""Location"": ""Function: `initialize`""
    },
    {
      ""Issue"": ""Reliance on Block Timestamp for Loan Start and End Times"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies heavily on `block.timestamp` for determining loan start and end times, margin call deadlines, and penalty calculations. While this is common, `block.timestamp` is manipulable by miners, although within certain constraints. This could potentially be exploited to slightly alter the timing of events to the advantage of a malicious actor."",
      ""Impact"": ""Potentially inaccurate timing of critical events, which could lead to unfair outcomes or manipulation of the loan terms."",
      ""Location"": ""Functions: `initialize`, `withdrawBorrowedAmount`, `cancelPool`, `requestMarginCall`, and any other function using `block.timestamp` for time-sensitive calculations.""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `cancelPool`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `cancelPool` function calculates a penalty based on `block.timestamp`. If a malicious actor can predict the state of the pool and the timing of a cancellation transaction, they could front-run the transaction to manipulate the penalty amount to their advantage, especially between `poolConstants.loanStartTime` and `poolConstants.loanWithdrawalDeadline`."",
      ""Impact"": ""A front-runner could manipulate the cancellation penalty, potentially reducing it to near zero or increasing it significantly to harm the borrower."",
      ""Location"": ""`cancelPool`, `_calculatePenaltyTime`""
    },
    {
      ""Issue"": ""Inconsistent Accounting in `_beforeTokenTransfer`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The logic in `_beforeTokenTransfer` aims to update `effectiveInterestWithdrawn` and `extraLiquidityShares` for both sender and receiver. However, the calculation of `effectiveInterestWithdrawn` is performed using the *current* balances of `_from` and `_to`, which include the amount being transferred. This can lead to incorrect accounting of accrued interest, especially when multiple transfers occur in a short period. Additionally, the `toTransfer` variable in the liquidity share update logic truncates when dividing, which could lose precision of liquidity shares."",
      ""Impact"": ""Inaccurate accounting of interest and liquidity shares, potentially leading to unfair distribution of rewards or collateral during liquidations or withdrawals."",
      ""Location"": ""`_beforeTokenTransfer`""
    },
    {
      ""Issue"": ""Possible Denial of Service (DoS) in `_withdrawAllCollateral`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_withdrawAllCollateral` function calculates `_collateralShares` by subtracting `_penalty` from `poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares)`. If `_penalty` is larger than the total number of shares then the substraction will revert and DoS the pool. This is also called in `cancelPool`, `terminatePool` and `closeLoan`."",
      ""Impact"": ""Prevents collateral withdrawal, effectively locking funds in the pool."",
      ""Location"": ""_withdrawAllCollateral""
    },
    {
      ""Issue"": ""Unbounded Loop Risk in `_beforeTokenTransfer` due to external call to Extension"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_beforeTokenTransfer` function has a call to the `IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);`.  If the `removeVotes` function in the extension contract is incorrectly implemented, it could potentially lead to an unbounded loop, causing a denial of service."",
      ""Impact"": ""Potential denial of service by causing a transaction to run out of gas."",
      ""Location"": ""_beforeTokenTransfer""
    },
    {
      ""Issue"": ""Incorrect Logic in checking Default status in `liquidatePool`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `liquidatePool` function checks if the borrower has defaulted using `IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this))`. However, the default status could change between this check and subsequent operations. If the borrower repays just before the liquidation transaction executes, the liquidation can still proceed because the loan status is already marked as `DEFAULTED`. The liquidatePool function also checks if loan status is ACTIVE, and that the borrower has defaulted."",
      ""Impact"": ""Can result in incorrect liquidation of the pool."",
      ""Location"": ""liquidatePool""
    },
    {
      ""Issue"": ""Potential Incorrect Reward Distribution in `liquidatePool` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `liquidatePool` function, the liquidator receives collateral tokens based on `correspondingBorrowTokens`. However, the pool's `extraLiquidityShares` and `baseLiquidityShares` are deleted *before* the liquidator receives their reward. This can lead to incorrect reward distribution because the liquidator is essentially liquidating the entire pool without accounting for individual lender shares."",
      ""Impact"": ""Liquidators might receive disproportionate rewards compared to lenders, leading to potential losses for lenders."",
      ""Location"": ""liquidatePool function""
    },
    {
      ""Issue"": ""Unprotected critical state update in `addCollateralInMarginCall`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `addCollateralInMarginCall` function, the `extraLiquidityShares` for both the pool and the lender are updated after the collateral is deposited. While the function has a check `getMarginCallEndTime(_lender) >= block.timestamp`, and updates `marginCallEndTime` based on `getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio`, a sophisticated attacker may find a way to manipulate collateral amounts, collateral ratios, and timing to exploit the lender's `extraLiquidityShares`. The `getMarginCallEndTime` check depends on `block.timestamp` and can be susceptible to block manipulation."",
      ""Impact"": ""An attacker might be able to manipulate the `extraLiquidityShares` and `marginCallEndTime` values, leading to unfair advantages or denial of service for other lenders."",
      ""Location"": ""addCollateralInMarginCall function""
    },
    {
      ""Issue"": ""Potential Division by Zero in _beforeTokenTransfer leading to denial of service"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_beforeTokenTransfer` function, there are division operations: `lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);` and `toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);`. If `_totalSupply` or `_fromBalance` is zero, these divisions will cause a revert, potentially blocking all token transfers and causing a denial of service. While some functions have checks that prevent some zero value situations, it\'s possible that the smart contract might reach such state during its lifecycle."",
      ""Impact"": ""Token transfers can be blocked, leading to a denial of service for lenders and potentially disrupting the loan lifecycle."",
      ""Location"": ""_beforeTokenTransfer function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `_calculatePenaltyTime()`"",
      ""Severity"": ""Low"",
      ""Description"": ""In the function `_calculatePenaltyTime`, the lines `_penaltyEndTime = _loanWithdrawalDeadline;` and `_penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));` could be vulnerable to integer underflow if `block.timestamp > _loanWithdrawalDeadline` and `_loanStartTime > _penaltyEndTime`.  Although SafeMath is used, this is more of a logical check. It is unlikely, but could occur in edge cases."",
      ""Impact"": ""Incorrect penalty calculation potentially leading to unexpected behavior when canceling the pool."",
      ""Location"": ""Pool.sol: `_calculatePenaltyTime()`""
    },
    {
      ""Issue"": ""Potential Rounding Errors in `correspondingBorrowTokens`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `correspondingBorrowTokens` function calculates the amount of borrow tokens based on collateral tokens and price ratios. Due to integer division, there might be rounding errors, which could lead to a slight discrepancy between the calculated borrow tokens and the actual value."",
      ""Impact"": ""Slight inaccuracies in borrow token calculations, potentially leading to minor losses for lenders or the liquidator."",
      ""Location"": ""`correspondingBorrowTokens` function.""
    },
    {
      ""Issue"": ""Potential Division by Zero Error in `calculateRepaymentWithdrawable`"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `calculateRepaymentWithdrawable` calculates the amount of repayment withdrawable by a lender. It includes a division by `totalSupply()`. If `totalSupply()` is zero, this will result in a division by zero error, causing the transaction to revert."",
      ""Impact"": ""If `totalSupply()` is zero, lenders will be unable to withdraw their repayments."",
      ""Location"": ""`calculateRepaymentWithdrawable`""
    },
    {
      ""Issue"": ""Unsafe use of `block.timestamp` for time-sensitive logic"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses `block.timestamp` in several places, including `initialize`, `withdrawBorrowedAmount`, `cancelPool`, `requestMarginCall`, etc. Block timestamps are not guaranteed to be perfectly accurate and can be influenced by miners, potentially leading to unexpected behavior in time-sensitive logic."",
      ""Impact"": ""Potential for subtle errors and unfair outcomes due to miner manipulation of block timestamps."",
      ""Location"": ""Multiple locations throughout the contract, wherever `block.timestamp` is used for critical logic.""
    },
    {
      ""Issue"": ""Missing input validation in `lend` function, `_amount` can become zero."",
      ""Severity"": ""Low"",
      ""Description"": ""In the `lend` function, if `_amount.add(_lentAmount) > _borrowAmountNeeded`, then `_amount` is set to `_borrowAmountNeeded.sub(_lentAmount)`. If `_lentAmount` is equal to `_borrowAmountNeeded`, then `_amount` will be zero. Zero amount transfers should be avoided as it wastes gas."",
      ""Impact"": ""Wasted gas, confusing operations"",
      ""Location"": ""`lend`""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `lend` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `lend` function determines the amount of tokens to lend based on the current `totalSupply` and `borrowAmountNeeded`. If multiple lenders attempt to lend concurrently, a front-running attack could occur where one lender's transaction is executed before another, resulting in the first lender lending more than intended (capped by `_borrowAmountNeeded.sub(_lentAmount)`), while subsequent lenders may be unable to lend at all."",
      ""Impact"": ""Potential for unfair allocation of lending opportunities if multiple lenders attempt to lend at the same time."",
      ""Location"": ""`lend`.""
    },
    {
      ""Issue"": ""Rounding Errors in Interest Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The `interestPerSecond` function calculates interest using integer division, which can lead to rounding errors. While the magnitude of these errors may be small, they can accumulate over time, especially with large principal amounts or long loan durations, causing a discrepancy between the intended and actual interest paid."",
      ""Impact"": ""Slight inaccuracies in interest calculation leading to minor financial discrepancies."",
      ""Location"": ""Pool.sol:714""
    },
    {
      ""Issue"": ""Potential Rounding Errors in Calculating Collateral Ratio"",
      ""Severity"": ""Low"",
      ""Description"": ""The `calculateCollateralRatio` function calculates the collateral ratio using division. Rounding errors can occur, potentially resulting in slightly inaccurate collateral ratio calculations."",
      ""Impact"": ""Slightly inaccurate collateral ratio calculations."",
      ""Location"": ""calculateCollateralRatio""
    },
        {
      ""Issue"": ""Lack of access control on `depositCollateral()`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `depositCollateral()` function has a `payable` modifier, but no check is performed to ensure that `msg.value` is zero. A user could accidentally or maliciously send ETH along with the collateral deposit, and this ETH would be stuck in the contract."",
      ""Impact"": ""ETH accidentally or maliciously sent to the contract would be stuck."",
      ""Location"": ""Pool.sol: `depositCollateral()`""
    },
    {
      ""Issue"": ""Lack of check on Strategy address in lend() function"",
      ""Severity"": ""Low"",
      ""Description"": ""In `lend()` function, if the `_strategy` address is passed as non-zero value, `_fromSavingsAccount` will be set to true. But, there is no check to see if a valid strategy contract address is passed. If an invalid contract address is passed, the `_deposit` function will be called with an invalid contract address and the transaction will revert."",
      ""Impact"": ""Transaction revert if an invalid strategy contract address is passed in lend() function."",
      ""Location"": ""Pool.sol: `lend()`""
    },
    {
        ""Issue"": ""Missing Input Validation for Addresses"",
        ""Severity"": ""Medium"",
        ""Description"": ""The `initialize` function accepts several address parameters (e.g., `_borrowAsset`, `_collateralAsset`, `_poolSavingsStrategy`). However, there are no checks to ensure that these addresses are not the zero address or the address of the contract itself. Passing invalid addresses could lead to unexpected behavior or vulnerabilities, particularly if these addresses are later used in external calls."",
        ""Impact"": ""Potential for the contract to become unusable or vulnerable if initialized with invalid addresses."",
        ""Location"": ""`initialize` function.""
    },
    {
      ""Issue"": ""Improper Penalty Calculation logic in `cancelPool` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The penalty applied for cancelling a pool, especially when the loan has not started, depends on `_calculatePenaltyTime`. The penalty time calculated, and thus the final penalty is dependent on `block.timestamp`. This could result in an incorrect penalty amount depending on when the function is called. If `block.timestamp > _loanWithdrawalDeadline` then penalty time could be smaller, resulting in a smaller penalty for the borrower."",
      ""Impact"": ""Incorrect penalty amount applied for cancelling a pool, especially when the loan has not started, or deadline has passed, potentially favoring either the borrower or lenders unfairly."",
      ""Location"": ""Pool.sol:466, Pool.sol:513""
    },
    {
      ""Issue"": ""Potential Reentrancy Risk in `_withdraw` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `_withdraw` function calls `SavingsAccountUtil.depositFromSavingsAccount`, which in turn interacts with an external `SavingsAccount` contract. This external call presents a reentrancy risk. A malicious SavingsAccount could call back into the Pool contract during the withdrawal process and potentially manipulate the state. While `nonReentrant` modifier is used in several functions, it does not cover every possible entry point to the `_withdraw` function."",
      ""Impact"": ""Potential for theft of funds or manipulation of pool state due to reentrancy."",
      ""Location"": ""Pool.sol:622, Pool.sol:669""
    },
        {
      ""Issue"": ""Missing input validation in initialize function can cause unexpected results."",
      ""Severity"": ""Medium"",
      ""Description"": ""The `initialize` function takes multiple input parameters, but does not perform sufficient validation on these parameters. For example, there are no checks to ensure `_borrowAmountRequested`, `_borrowRate`, `_collateralAmount`, `_repaymentInterval`, or `_noOfRepaymentIntervals` are within reasonable bounds. This lack of validation could lead to the Pool being initialized with invalid or nonsensical parameters, potentially causing unpredictable behavior or even financial losses."",
      ""Impact"": ""Pool initialized with wrong parameters."",
      ""Location"": ""initialize function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in collateral and liquidity calculations"",
      ""Severity"": ""Low"",
      ""Description"": ""While SafeMath is used, there are calculations related to collateral ratios, liquidity shares, and token conversions that could potentially lead to integer overflow or underflow if extremely large or small values are used."",
      ""Impact"": ""Inaccurate collateral ratios or liquidity share calculations could lead to incorrect loan conditions or unfair liquidation scenarios."",
      ""Location"": ""calculateCollateralRatio, getCurrentCollateralRatio, getCurrentCollateralRatio(address)""
    },
    {
      ""Issue"": ""Lack of Access Control on `interestToPay` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `interestToPay` function is declared as `public view`, meaning anyone can call this function to calculate the interest to pay."",
      ""Impact"": ""Exposure of sensitive internal calculations."",
      ""Location"": ""interestToPay function""
    },
    {
      ""Issue"": ""Potential Incorrect Reward Distribution in `liquidatePool` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `liquidatePool` function, the liquidator receives collateral tokens based on `correspondingBorrowTokens`. However, the pool's `extraLiquidityShares` and `baseLiquidityShares` are deleted *before* the liquidator receives their reward. This can lead to incorrect reward distribution because the liquidator is essentially liquidating the entire pool without accounting for individual lender shares."",
      ""Impact"": ""Liquidators might receive disproportionate rewards compared to lenders, leading to potential losses for lenders."",
      ""Location"": ""liquidatePool function""
    },
    {
      ""Issue"": ""Redundant Check in `_beforeTokenTransfer`"",
      ""Severity"": ""Low"",
      ""Description"": ""The check `if (_from == address(0) || _to == address(0))` seems redundant since the ERC20 implementation already handles minting and burning, which inherently involves transfers from/to address(0)."",
      ""Impact"": ""Minor gas inefficiency."",
      ""Location"": ""_beforeTokenTransfer""
    },
    {
      ""Issue"": ""Inconsistent use of transfer/deposit functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""There is an inconsistency in how the contract deposits and transfers tokens, specifically using `_deposit` and `SavingsAccountUtil.transferTokens`. It's unclear whether `_deposit` leverages `SavingsAccountUtil.transferTokens` internally. This can create confusion and makes auditing harder."",
      ""Impact"": ""Increased complexity, potential inconsistencies in token handling, and difficulty in auditing token flow, leading to possible bugs."",
      ""Location"": ""Pool.sol: Multiple functions including `lend`, `_deposit`, `liquidatePool`""
    },
        {
      ""Issue"": ""Missing Input Validation for Critical Parameters in `initialize`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `initialize` function lacks sufficient input validation for several critical parameters such as `_borrowAmountRequested`, `_borrowRate`, `_idealCollateralRatio`, `_repaymentInterval`, and `_noOfRepaymentIntervals`. Specifically, there are no checks to ensure these values are within reasonable bounds or to prevent potential division by zero errors (e.g., if `_repaymentInterval` is zero). Missing validation could lead to unexpected contract behavior and potential exploits."",
      ""Impact"": ""Invalid input parameters during contract initialization could render the pool unusable or create opportunities for attackers to manipulate the loan terms to their advantage."",
      ""Location"": ""initialize""
    },
    {
        ""Issue"": ""Inconsistent Use of `msg.value` and `payable`"",
        ""Severity"": ""Low"",
        ""Description"": ""Several external functions such as `depositCollateral`, `addCollateralInMarginCall`, and `lend` are marked as `payable` but do not use `msg.value`. While not directly a vulnerability, it's inconsistent and can be confusing."",
        ""Impact"": ""Code inconsistency and potential for unintended Ether transfer handling."",
        ""Location"": ""depositCollateral, addCollateralInMarginCall, lend""
    },
    {
        ""Issue"": ""Lack of Input Validation for `_amount` in `lend` function"",
        ""Severity"": ""Low"",
        ""Description"": ""In the `lend` function, the code checks if `_amount.add(_lentAmount) > _borrowAmountNeeded` and adjusts `_amount` accordingly. However, there's no explicit check to ensure `_amount` is not zero after this adjustment. A zero `_amount` could lead to wasted gas and potentially unexpected behavior down the line if other parts of the function assume `_amount` is always a positive value."",
        ""Impact"": ""Wasted gas and potential for unexpected behavior."",
        ""Location"": ""lend""
    },
    {
        ""Issue"": ""Improper Input Validation in `initialize()`"",
        ""Severity"": ""Medium"",
        ""Description"": ""The `initialize` function lacks sufficient input validation for several critical parameters such as `_borrowAmountRequested`, `_borrowRate`, `_collateralAmount`, `_loanWithdrawalDuration`, and `_collectionPeriod`. Specifically, there are no checks to prevent excessively large values or values that could lead to arithmetic overflows or unexpected behavior. For example, a very large `_loanWithdrawalDuration` could cause issues with timestamp calculations later in the contract.  Additionally, there's a `payable` keyword, but no `msg.value` is handled, meaning ETH sent along with the initialization call is essentially lost, which is unexpected. The lack of validation could potentially allow an attacker to manipulate these values to exploit vulnerabilities in the contract\'s logic, leading to financial loss or denial of service.  The reliance on the `_initialDeposit` function called within `initialize` also implicitly relies on the validation *within* that internal function, which isn\'t explicitly checked during initialization, meaning it\'s harder to audit at first glance."",
        ""Impact"": ""Potential arithmetic overflows, unexpected contract behavior, denial of service, or financial loss due to manipulated input values. Unhandled msg.value results in loss of funds sent during initialization."",
        ""Location"": ""Pool.sol: `initialize()` function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Share Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions, particularly those dealing with share calculations (e.g., calculating lender's share of liquidity in `getCurrentCollateralRatio`, `_updateLenderSharesDuringLiquidation`), involve multiplication and division operations on `uint256` values. While SafeMath is used, a carefully crafted scenario with extremely large or small numbers could potentially lead to intermediate results that exceed the maximum or minimum value of `uint256`, causing unexpected behavior despite the SafeMath protections."",
      ""Impact"": ""Incorrect calculation of shares, potentially leading to inaccurate distribution of funds."",
      ""Location"": ""`getCurrentCollateralRatio`, `_updateLenderSharesDuringLiquidation`, other functions involving share calculations.""
    },
    {
        ""Issue"": ""Potential Integer Overflow/Underflow in Share Calculations"",
        ""Severity"": ""Medium"",
        ""Description"": ""In the `_beforeTokenTransfer` function, the calculations of `lenders[_from].effectiveInterestWithdrawn` and `lenders[_to].effectiveInterestWithdrawn` involve multiplication and division. While SafeMath is used, there\'s a possibility of integer overflows if `_fromBalance`, `_amount`, or `_totalRepaidAmount` are sufficiently large.  Specifically, `(_fromBalance.sub(_amount)).mul(_totalRepaidAmount)` or `(_toBalance.add(_amount)).mul(_totalRepaidAmount)` could overflow before the division."",
        ""Impact"": ""Incorrect interest accounting for lenders, leading to unfair distribution of repaid amounts."",
        ""Location"": ""Function: `_beforeTokenTransfer`. Calculations of `lenders[_from].effectiveInterestWithdrawn` and `lenders[_to].effectiveInterestWithdrawn`.""
    },
    {
        ""Issue"": ""Incorrect Fee Calculation in `withdrawBorrowedAmount`"",
        ""Severity"": ""Low"",
        ""Description"": ""In the `withdrawBorrowedAmount` function, the protocol fee is calculated based on `_tokensLent`, which represents the total amount of Pool Tokens (PT) lent. However, the intention might be to calculate the fee based on `poolConstants.borrowAmountRequested`. If `_tokensLent` significantly differs from `poolConstants.borrowAmountRequested`, the protocol fee could be miscalculated."",
        ""Impact"": ""Slightly inaccurate protocol fee calculation, potentially disadvantaging either the borrower or the protocol."",
        ""Location"": ""Function: `withdrawBorrowedAmount`. Calculation of `_protocolFee`.""
    },
    {
        ""Issue"": ""Unbounded Loop Risk in `_withdrawRepayment` leading to Gas Exhaustion"",
        ""Severity"": ""Low"",
        ""Description"": ""The repeated calculations and transfers in the `_withdrawRepayment` have the potential to exhaust the gas limit. If the conditions are right and there are many lenders with non-zero amounts to withdraw, the total gas cost could exceed the block gas limit. Although SavingsAccountUtil\'s transferTokens may revert, other internal calls could exhaust the gas limit"",
        ""Impact"": ""Transaction reverts, temporary denial of service for lender\'s withdrawals."",
        ""Location"": ""Function: `_withdrawRepayment`""
    },
    {
        ""Issue"": ""Missing Check for Zero Address in Initialization"",
        ""Severity"": ""Medium"",
        ""Description"": ""The `initialize` function does not validate that the addresses passed in as parameters (`_borrowAsset`, `_collateralAsset`, `_poolSavingsStrategy`, `_lenderVerifier`, etc.) are not the zero address. Setting any of these addresses to zero could lead to unexpected behavior or make the contract unusable."",
        ""Impact"": ""Contract can be initialized with invalid configurations, leading to loss of funds or unusable pool."",
        ""Location"": ""Function: `initialize`""
    }
  ],
  ""IssueNumber"": 61,
  ""OutputList"": 41
}",222.58274674415588,4302.0,32.0,"### **[H-03] Denial of Service**

**Report Description**:
The issue arises in the `withdrawLiquidity` function when the borrow token is `address(0)` (Ether). In this case, the function calls `SavingsAccountUtil.transferTokens`, which transfers `msg.value` (the Ether sent with the transaction) to `msg.sender`. This results in the liquidity provider paying themselves, while their liquidity tokens are still burned. Consequently, they will never be able to recover their funds, leading to a denial of service.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this specific issue. The described vulnerability involves a logical flaw in the `withdrawLiquidity` function when handling Ether transfers, which is not covered in the provided responses.

---

### **[M-03] Collateral can be deposited in a finished pool**

**Report Description**:
The `_depositCollateral` function does not check the status of the pool, allowing collateral to be deposited even after the pool has finished. This can occur by mistake, leading to the loss of all deposited funds.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue. The vulnerability involves a lack of state validation in the `_depositCollateral` function, which is not covered in the provided responses.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-03] Denial of Service**
- **[M-03] Collateral can be deposited in a finished pool**

---

### **Conclusion**:
The provided `response_list` does not address the two issues from the `issue` report. Both issues involve specific vulnerabilities in the contract logic that are not covered in the responses. This indicates a gap in the security analysis, particularly concerning denial of service and improper state validation in the `_depositCollateral` function.","```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at every rank is 0, and thus the average precision is 0."
YearnYield.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/IyVault.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into YVault
 * @author Sublime
 **/
contract YearnYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice stores the address of savings account contract
     **/
    address payable public savingsAccount;

    /**
     * @notice stores the address of liquidity token for a given base token
     */
    mapping(address => address) public override liquidityToken;

    /**
     * @notice emitted when liquidity token address of an asset is updated
     * @param asset the address of asset
     * @param protocolToken address of the liquidity token for the asset
     **/
    event ProtocolAddressesUpdated(address indexed asset, address indexed protocolToken);

    /**
     * @notice checks if contract is invoked by savings account
     **/
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    /**
     * @notice used to initialize the variables in the contract
     * @dev can only be called once
     * @param _owner address of the owner
     * @param _savingsAccount address of the savings account contract
     **/
    function initialize(address _owner, address payable _savingsAccount) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
    }

    /**
     * @notice used to update savings account contract address
     * @dev can only be called by owner
     * @param _savingsAccount address of updated savings account contract
     **/
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update liquidity token for a asset
     * @dev can only be called by owner
     * @param _asset address of the token
     * @param _liquidityToken address of the liquidityToken for the given token
     **/
    function updateProtocolAddresses(address _asset, address _liquidityToken) external onlyOwner {
        liquidityToken[_asset] = _liquidityToken;
        emit ProtocolAddressesUpdated(_asset, _liquidityToken);
    }

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _wallet address to which tokens are withdrawn
     */
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner nonReentrant returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        address investedTo = liquidityToken[_asset];
        uint256 amount = IERC20(investedTo).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, investedTo, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    /**
     * @notice Used to lock tokens in available protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param user the address of user
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');

        address investedTo = liquidityToken[asset];
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            sharesReceived = _depositETH(investedTo, amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            sharesReceived = _depositERC20(asset, investedTo, amount);
        }

        emit LockedTokens(user, investedTo, sharesReceived);
    }

    /**
     * @notice Used to unlock tokens from available protocol
     * @param asset the address of underlying token
     * @param amount the amount of asset
     * @return received amount of tokens received
     **/
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');
        address investedTo = liquidityToken[asset];

        if (asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, investedTo, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    /**
     * @notice Used to unlock shares
     * @param asset the address of underlying token
     * @param amount the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    /**
     * @dev Used to get amount of underlying tokens for current number of shares
     * @param shares the amount of shares
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
        if (shares == 0) return 0;
        amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18);
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param amount the amount of tokens
     * @param asset the address of token
     * @return shares amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(address vault, uint256 amount) internal returns (uint256 sharesReceived) {
        uint256 initialTokenBalance = IERC20(vault).balanceOf(address(this));

        //mint vault
        IyVault(vault).depositETH{value: amount}();

        sharesReceived = IERC20(vault).balanceOf(address(this)).sub(initialTokenBalance);
    }

    function _depositERC20(
        address asset,
        address vault,
        uint256 amount
    ) internal returns (uint256 sharesReceived) {
        uint256 sharesBefore = IERC20(vault).balanceOf(address(this));

        //lock collateral in vault
        IERC20(asset).approve(vault, 0);
        IERC20(asset).approve(vault, amount);
        IyVault(vault).deposit(amount);

        sharesReceived = IERC20(vault).balanceOf(address(this)).sub(sharesBefore);
    }

    function _withdrawETH(address vault, uint256 amount) internal returns (uint256 received) {
        uint256 ethBalance = address(this).balance;

        IyVault(vault).withdrawETH(amount);

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(
        address asset,
        address vault,
        uint256 amount
    ) internal returns (uint256 tokensReceived) {
        uint256 initialAssetBalance = IERC20(asset).balanceOf(address(this));

        IyVault(vault).withdraw(amount);

        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(initialAssetBalance);
    }

    receive() external payable {}
}

",1949,240,"[H-04] Yearn token <> shares conversion decimal issue

Submitted by cmichel
The yearn strategy YearnYield converts shares to tokens by doing pricePerFullShare * shares / 1e18:
``` function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
    if (shares == 0) return 0;
    // @audit should divided by vaultDecimals 
    amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18);
}
```
But Yearn's getPricePerFullShare seems to be in vault.decimals() precision, i.e., it should convert it as pricePerFullShare * shares / (10 ** vault.decimals()). The vault decimals are the same as the underlying token decimals
",1,,"pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/IyVault.sol';


contract YearnYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    
    address payable public savingsAccount;

    
    mapping(address => address) public override liquidityToken;

    
    event ProtocolAddressesUpdated(address indexed asset, address indexed protocolToken);

    
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    
    function initialize(address _owner, address payable _savingsAccount) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
    }

    
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    
    function updateProtocolAddresses(address _asset, address _liquidityToken) external onlyOwner {
        liquidityToken[_asset] = _liquidityToken;
        emit ProtocolAddressesUpdated(_asset, _liquidityToken);
    }

    
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner nonReentrant returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        address investedTo = liquidityToken[_asset];
        uint256 amount = IERC20(investedTo).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, investedTo, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');

        address investedTo = liquidityToken[asset];
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            sharesReceived = _depositETH(investedTo, amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            sharesReceived = _depositERC20(asset, investedTo, amount);
        }

        emit LockedTokens(user, investedTo, sharesReceived);
    }

    
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');
        address investedTo = liquidityToken[asset];

        if (asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, investedTo, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    
    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
        if (shares == 0) return 0;
        amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18);
    }

    
    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(address vault, uint256 amount) internal returns (uint256 sharesReceived) {
        uint256 initialTokenBalance = IERC20(vault).balanceOf(address(this));

        
        IyVault(vault).depositETH{value: amount}();

        sharesReceived = IERC20(vault).balanceOf(address(this)).sub(initialTokenBalance);
    }

    function _depositERC20(
        address asset,
        address vault,
        uint256 amount
    ) internal returns (uint256 sharesReceived) {
        uint256 sharesBefore = IERC20(vault).balanceOf(address(this));

        
        IERC20(asset).approve(vault, 0);
        IERC20(asset).approve(vault, amount);
        IyVault(vault).deposit(amount);

        sharesReceived = IERC20(vault).balanceOf(address(this)).sub(sharesBefore);
    }

    function _withdrawETH(address vault, uint256 amount) internal returns (uint256 received) {
        uint256 ethBalance = address(this).balance;

        IyVault(vault).withdrawETH(amount);

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(
        address asset,
        address vault,
        uint256 amount
    ) internal returns (uint256 tokensReceived) {
        uint256 initialAssetBalance = IERC20(asset).balanceOf(address(this));

        IyVault(vault).withdraw(amount);

        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(initialAssetBalance);
    }

    receive() external payable {}
}",1345,1,0,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that the `onlyOwner` modifier is used appropriately to protect sensitive functions like `updateSavingsAccount` and `updateProtocolAddresses`."",
        ""Confirm that `_updateSavingsAccount` function correctly updates the `savingsAccount` address and emits the `SavingsAccountUpdated` event."",
        ""Verify that the `onlySavingsAccount` modifier is used correctly on `lockTokens`, `unlockTokens`, and `unlockShares` to restrict access to the intended actor."",
        ""Ensure that the `initialize` function can only be called once through proper implementation of the Initializable contract from OpenZeppelin."",
        ""Check that the owner is correctly set during initialization and that ownership can be transferred correctly.""
      ]
    },
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Analyze the `emergencyWithdraw`, `lockTokens`, `unlockTokens`, and `unlockShares` functions for potential reentrancy issues, despite the `nonReentrant` modifier. Focus on external calls to `IyVault` and token transfers."",
        ""Specifically, audit the ETH transfer in `emergencyWithdraw` using `call` to ensure the `nonReentrant` modifier effectively prevents reentrancy."",
        ""Verify that all state updates occur *before* external calls within functions protected by the `nonReentrant` modifier.""
      ]
    },
    {
      ""Area"": ""ERC20 Interaction Security"",
      ""Tasks"": [
        ""Investigate the potential front-running vulnerability in `_depositERC20` due to the `approve(0)` followed by `approve(amount)` pattern. Consider alternatives like increasing allowance or using a permit function if available."",
        ""Evaluate if approving the entire amount in `_depositERC20` is necessary and if approving only the deposited amount is a more secure approach."",
        ""Verify that the contract handles ERC20 tokens with different decimals correctly, especially in `getTokensForShares` and `getSharesForTokens` calculations."",
        ""Ensure that the `safeTransfer` and `safeTransferFrom` functions from SafeERC20 are used correctly to prevent issues with tokens that don't return a boolean on transfer."",
        ""In `unlockShares` function, ensure that the passed asset is indeed a valid share token and that transferring it directly to `savingsAccount` is the intended behavior, rather than withdrawing from vault first.""
      ]
    },
    {
      ""Area"": ""ETH Handling"",
      ""Tasks"": [
        ""Carefully review the ETH handling logic in `emergencyWithdraw`, `lockTokens`, `_depositETH`, and `_withdrawETH` to ensure correct value transfer and prevent loss of funds."",
        ""Verify that the `msg.value` check in `lockTokens` when depositing ETH is correct."",
        ""Analyze the `call` usage in `emergencyWithdraw` and `unlockTokens` for potential security risks and consider using `transfer` or `send` if appropriate and safe, understanding the gas limitations."",
        ""Verify that the contract's `receive()` function is implemented correctly and does not introduce any vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Arithmetic Overflow/Underflow"",
      ""Tasks"": [
        ""While SafeMath is used, double-check all arithmetic operations for potential overflow/underflow issues, particularly when dealing with large numbers of tokens or shares. Especially focus on calculations inside `getTokensForShares` and `getSharesForTokens` functions."",
        ""Verify that division by zero is prevented, especially in `getSharesForTokens` if `getTokensForShares(1e18, asset)` returns 0. Add a require statement to prevent this situation.""
      ]
    },
    {
      ""Area"": ""External Interactions and Yearn Vault Logic"",
      ""Tasks"": [
        ""Analyze the contract's interactions with the `IyVault` interface and ensure that the expected functions (`deposit`, `withdraw`, `getPricePerFullShare`) are correctly implemented in the target Yearn vaults."",
        ""Investigate potential issues if `getPricePerFullShare()` in the Yearn Vault returns 0. Add checks to handle this edge case in `getSharesForTokens`."",
        ""Document assumptions about the behavior of the Yearn vaults (e.g., deposit/withdrawal fees, slippage) and how they affect the contract's functionality."",
        ""Consider different Yearn vault implementations and ensure that the contract handles variations in deposit/withdrawal mechanisms or fee structures gracefully."",
        ""Review the interfaces used(IYield, IyVault) and ensure that its methods align with its definitions.""
      ]
    },
    {
      ""Area"": ""Error Handling and Input Validation"",
      ""Tasks"": [
        ""Ensure all require statements have informative error messages to aid in debugging."",
        ""Verify that all input parameters are validated to prevent unexpected behavior or vulnerabilities. Particularly addresses, and amounts"",
        ""Check for potential revert reasons from external calls and ensure they are handled appropriately.""
      ]
    },
    {
      ""Area"": ""Upgradeability"",
      ""Tasks"": [
        ""Verify that the upgradeability pattern is correctly implemented using OpenZeppelin's upgradeable contracts."",
        ""Analyze the storage layout for potential conflicts during upgrades."",
        ""Ensure that the `initialize` function is designed to be called only once after deployment and upgrades."",
         ""Confirm that there are no self-destruct instructions.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify opportunities to optimize gas consumption in frequently called functions like `lockTokens`, `unlockTokens`, `getTokensForShares`, and `getSharesForTokens`."",
        ""Consider using more efficient data structures or algorithms where possible."",
        ""Minimize unnecessary storage reads and writes.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines a YearnYield contract that acts as an intermediary between a savings account and Yearn vaults. It allows depositing and withdrawing both ETH and ERC20 tokens into Yearn vaults on behalf of users, as instructed by the savings account. The contract is upgradeable, uses Ownable for access control, and ReentrancyGuard to prevent reentrancy attacks. It interacts with the IYield and IyVault interfaces. The contract maintains a mapping of assets to their corresponding liquidity token (vault) addresses."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""YearnYield"",
    ""Purpose"": ""Acts as an intermediary for depositing and withdrawing assets into Yearn vaults on behalf of a savings account."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""IYield"",
        ""Initializable"",
        ""OwnableUpgradeable"",
        ""ReentrancyGuard""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"",
        ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"",
        ""@openzeppelin/contracts/math/SafeMath.sol"",
        ""../interfaces/IYield.sol"",
        ""../interfaces/Invest/IyVault.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""savingsAccount"",
        ""Type"": ""address payable"",
        ""Purpose"": ""Address of the savings account that can invoke certain functions.""
      },
      {
        ""Name"": ""liquidityToken"",
        ""Type"": ""mapping(address => address)"",
        ""Purpose"": ""Maps an asset address to the address of the corresponding Yearn vault.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract, setting the owner and savings account."",
        ""Parameters"": [
          ""_owner (address)"",
          ""_savingsAccount (address payable)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""updateSavingsAccount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the address of the savings account.  Only callable by the owner."",
        ""Parameters"": [
          ""_savingsAccount (address payable)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_updateSavingsAccount"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to update the savings account address."",
        ""Parameters"": [
          ""_savingsAccount (address payable)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""updateProtocolAddresses"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the mapping between an asset and its corresponding Yearn vault. Only callable by the owner."",
        ""Parameters"": [
          ""_asset (address)"",
          ""_liquidityToken (address)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws all tokens from a Yearn vault and sends them to a specified wallet.  Only callable by the owner. Includes handling for ETH."",
        ""Parameters"": [
          ""_asset (address)"",
          ""_wallet (address payable)""
        ],
        ""Returns"": [
          ""received (uint256)""
        ]
      },
      {
        ""Name"": ""lockTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Deposits tokens into a Yearn vault on behalf of a user, triggered by the savings account.  Handles both ETH and ERC20 tokens."",
        ""Parameters"": [
          ""user (address)"",
          ""asset (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [
          ""sharesReceived (uint256)""
        ]
      },
      {
        ""Name"": ""unlockTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws tokens from a Yearn vault and sends them to the savings account, triggered by the savings account.  Handles both ETH and ERC20 tokens."",
        ""Parameters"": [
          ""asset (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [
          ""received (uint256)""
        ]
      },
      {
        ""Name"": ""unlockShares"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers specific shares (ERC20) from contract to the savings account"",
        ""Parameters"": [
          ""asset (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""getTokensForShares"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the amount of underlying tokens corresponding to a given number of shares in a Yearn vault."",
        ""Parameters"": [
          ""shares (uint256)"",
          ""asset (address)""
        ],
        ""Returns"": [
          ""amount (uint256)""
        ]
      },
      {
        ""Name"": ""getSharesForTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Calculates the number of shares corresponding to a given amount of underlying tokens in a Yearn vault."",
        ""Parameters"": [
          ""amount (uint256)"",
          ""asset (address)""
        ],
        ""Returns"": [
          ""shares (uint256)""
        ]
      },
      {
        ""Name"": ""_depositETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Deposits ETH into a Yearn vault."",
        ""Parameters"": [
          ""vault (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [
          ""sharesReceived (uint256)""
        ]
      },
      {
        ""Name"": ""_depositERC20"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Deposits ERC20 tokens into a Yearn vault."",
        ""Parameters"": [
          ""asset (address)"",
          ""vault (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [
          ""sharesReceived (uint256)""
        ]
      },
      {
        ""Name"": ""_withdrawETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Withdraws ETH from a Yearn vault."",
        ""Parameters"": [
          ""vault (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [
          ""received (uint256)""
        ]
      },
      {
        ""Name"": ""_withdrawERC"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Withdraws ERC20 tokens from a Yearn vault."",
        ""Parameters"": [
          ""asset (address)"",
          ""vault (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [
          ""tokensReceived (uint256)""
        ]
      },
      {
        ""Name"": ""onlySavingsAccount"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts access to functions to only the savings account."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""nonReentrant"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Prevents reentrancy attacks."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20 (for token transfers and approvals)"",
    ""IyVault (for interacting with Yearn vaults: deposit, withdraw, getPricePerFullShare)""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable contract using OpenZeppelin's upgradeable contracts."",
    ""OwnableUpgradeable for access control."",
    ""ReentrancyGuard for preventing reentrancy attacks."",
    ""The contract acts as a middleman between a savings account and Yearn vaults.""
  ],
  ""Questions"": [
    ""Why is the `unlockShares` function transferring the `asset` (which should be shares?) directly to the savings account instead of withdrawing the underlying assets from the vault first?"",
    ""The `emergencyWithdraw` function transfers ETH using a low-level `call`. Is there a specific reason for not using `payable(wallet).transfer` or `payable(wallet).send`? The low-level call exposes the contract to re-entrancy attacks if the receiving wallet is a malicious contract. But `nonReentrant` modifier on function definition should prevent this case."",
    ""In `_depositERC20`, why are we approving 0 and then approving the actual amount? This could potentially lead to front-running issues."",
    ""Is it necessary to approve the vault for spending the entire amount in `_depositERC20`?  Approving only the `amount` being deposited would be sufficient and more secure."",
    ""Are there any limitations on the types of Yearn vaults supported? Does it handle vaults with different deposit/withdrawal mechanisms or fee structures?"",
     ""What happens if the `getPricePerFullShare()` function in the Yearn Vault returns 0? This will cause a divide by zero error in `getSharesForTokens()`.""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `_withdrawETH`, `_withdrawERC`, and `_depositERC20`"",
      ""Severity"": ""High"",
      ""Description"": ""The `_withdrawETH` and `_withdrawERC` functions call external contracts (`IyVault(vault).withdrawETH(amount)` and `IyVault(vault).withdraw(amount)` respectively) before updating the internal state, creating a reentrancy vulnerability. A malicious vault contract could call back into this contract's functions during the external call, potentially draining funds or manipulating balances before the original withdrawal completes. The `_depositERC20` function approves the vault before calling `IyVault(vault).deposit(amount)`, which could also lead to reentrancy issues if the vault is malicious."",
      ""Impact"": ""Malicious vault can re-enter the contract and potentially steal funds, or manipulate the approval."",
      ""Location"": ""_withdrawETH, _withdrawERC, and _depositERC20 functions""
    },
    {
      ""Issue"": ""Missing Zero Address Check for `_asset` in `emergencyWithdraw` function and potential loss of funds"",
      ""Severity"": ""High"",
      ""Description"": ""The `emergencyWithdraw` function transfers tokens using `IERC20(_asset).safeTransfer(_wallet, received)`. If `_asset` is the address of a vault, and not the underlying token, then this will transfer the vault tokens instead of the underlying tokens. Consider adding a check to ensure `_asset` isn't the same as `investedTo`."",
      ""Impact"": ""Potential loss of funds for the protocol or users depending on how emergencyWithdraw is used."",
      ""Location"": ""emergencyWithdraw function""
    },
    {
      ""Issue"": ""Potential Reentrancy Risk in `emergencyWithdraw` with ETH"",
      ""Severity"": ""High"",
      ""Description"": ""The `emergencyWithdraw` function's ETH withdrawal path using `_wallet.call{value: received}('')` introduces a potential reentrancy vulnerability. If the `_wallet` is a malicious contract, it can call back into this contract during the ETH transfer, potentially manipulating state variables or performing unauthorized actions before the transfer completes."",
      ""Impact"": ""Malicious contracts may exploit this reentrancy to drain funds or manipulate contract state."",
      ""Location"": ""YearnYield.sol:60""
    },
    {
      ""Issue"": ""Lack of slippage control in `lockTokens` and `unlockTokens` when dealing with ETH and ERC20, leading to front-running vulnerability and potential loss"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `lockTokens` and `unlockTokens` functions interact with external vaults (IyVault) without any slippage control. When dealing with ETH, the `lockTokens` and `unlockTokens` functions directly transfer ETH using `depositETH{value: amount}()` and `savingsAccount.call{value: received}('')`. When dealing with ERC20 tokens the return values from `_depositETH`, `_depositERC20`, `_withdrawETH` and `_withdrawERC` are not validated against any slippage parameters or user expectations. If the vault's exchange rate fluctuates significantly between the time the user initiates the transaction and when the transaction is executed, the user could receive fewer shares than expected (in `lockTokens`) or receive less ETH than expected (in `unlockTokens`). This can lead to significant losses if the exchange rate changes drastically."",
      ""Impact"": ""Users may receive fewer tokens or shares than expected due to price slippage, leading to financial loss and dissatisfaction. Users may receive fewer shares or tokens than expected due to front-running."",
      ""Location"": ""lockTokens (ETH path), unlockTokens (ETH path), _depositETH, _depositERC20, _withdrawETH, _withdrawERC""
    },
    {
      ""Issue"": ""Missing zero-address check for `_asset` in `unlockShares` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `unlockShares` function transfers shares to the `savingsAccount`. While there's a check to ensure that `amount` is not zero, there is no check to ensure that `asset` is not address(0). This can cause unexpected behavior because the `IERC20(address(0)).safeTransfer` will cause an error."",
      ""Impact"": ""The transfer can fail, and may cause contract malfunction, unexpected state changes, or denial of service if the `asset` address is accidentally or maliciously set to `address(0)`."",
      ""Location"": ""YearnYield.sol:99, YearnYield.sol:122""
    },
    {
      ""Issue"": ""Approval to Vault set to maximum even for small amount and Approve-Before-Transfer Vulnerability in `_depositERC20` function."",
      ""Severity"": ""Medium"",
      ""Description"": ""In function `_depositERC20` the approval for asset amount to vault is given by first setting it to zero and then to `amount`. This is unnecessary. The function `approve(vault, 0)` consumes gas which is avoidable. Also, setting approval amount to `amount` and not specific amount can lead to issues if the vault is malicious. The vault may drain the address if they get a chance.  Furthermore, the code calls `IERC20(asset).approve(vault, amount)` *before* calling `IyVault(vault).deposit(amount)`. This can potentially lead to a race condition known as the front-running attack or 'approve-before-transfer' vulnerability. "",
      ""Impact"": ""Unnecessary gas consumption and possible security issue if vault is compromised.  Unexpected behavior or failure of the `deposit` function, potential loss of funds in specific token/vault interactions."",
      ""Location"": ""_depositERC20 function""
    },
    {
      ""Issue"": ""Approval of 0 before approving amount in _depositERC20 can be front-run"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_depositERC20` function, the code first approves the vault with 0 and then with the actual amount. This two-step approval process can be front-run by a malicious actor or cause issue if the token reverts when approving zero amount. They could replace the first transaction (approve 0) with a transaction approving a different address or a higher amount. Some tokens, e.g., USDT, revert when approving zero amount."",
      ""Impact"": ""Users may experience failed deposits, loss of funds, or unintended allowance changes. Deposit ERC20 tokens can fail."",
      ""Location"": ""YearnYield.sol:144, YearnYield.sol:158""
    },
    {
      ""Issue"": ""Potential rounding errors and loss of precision in `getTokensForShares` and `getSharesForTokens`, also `getTokensForShares` might overflow"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `getTokensForShares` and `getSharesForTokens` functions perform calculations involving multiplication and division, and could be susceptible to rounding errors.  The `getTokensForShares` function calculates the amount of tokens for a given number of shares using `IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18)`. The multiplication `IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares)` might overflow when `getPricePerFullShare` and `shares` are both large, leading to incorrect calculation of tokens. `getSharesForTokens` suffers from similar problem. In `getSharesForTokens`, the shares are calculated as `(amount.mul(1e18)).div(getTokensForShares(1e18, asset))`. Depending on the values of `amount` and `getTokensForShares(1e18, asset)`, this calculation may result in rounding errors, leading to an inaccurate representation of the shares received for a given amount of tokens. The result of multiplication may be truncated significantly by the final division. This results in loss of precision that could lead to unexpected behavior or financial losses."",
      ""Impact"": ""Inaccurate calculations of token/share conversions can lead to users receiving slightly less than expected.  Incorrect calculation of token amount corresponding to shares."",
      ""Location"": ""getTokensForShares and getSharesForTokens functions""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in getSharesForTokens"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `getSharesForTokens` function calculates shares by multiplying `amount` by 1e18 and then dividing by `getTokensForShares(1e18, asset)`. If `getTokensForShares(1e18, asset)` returns a very small value, the division could lead to a very large number which may exceed uint256 limit or result in a division by zero."",
      ""Impact"": ""Incorrect share calculation, potential denial of service due to revert."",
      ""Location"": ""getSharesForTokens function""
    },
    {
      ""Issue"": ""Missing Error Handling for Vault Interactions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The code interacts with external `IyVault` contracts using `deposit`, `withdraw`, `depositETH`, and `withdrawETH`.  These interactions could fail for various reasons (e.g., insufficient allowance, vault being paused, etc.). The contract doesn't check the return values of these calls (if any are returned) and doesn't have explicit error handling."",
      ""Impact"": ""Contract can get into an inconsistent state if vault interactions fail unexpectedly, potentially leading to loss of funds or DoS."",
      ""Location"": ""YearnYield.sol:_depositETH, YearnYield.sol:_depositERC20, YearnYield.sol:_withdrawETH, YearnYield.sol:_withdrawERC""
    },
    {
      ""Issue"": ""Missing Input Validation in `updateProtocolAddresses`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `updateProtocolAddresses` function allows the owner to update the mapping between assets and liquidity tokens. However, it does not include a check to ensure that `_liquidityToken` is not the zero address or a valid contract address or implements the `IyVault` interface. Setting a liquidity token to the zero address or invalid contract could lead to unexpected behavior or prevent certain functions from working correctly."",
      ""Impact"": ""Can cause the contract to become unusable if the admin accidentally sets address to zero. Setting the liquidityToken to address(0) will cause later call of `getPricePerFullShare` function will revert."",
      ""Location"": ""updateProtocolAddresses function""
    },
    {
      ""Issue"": ""Use of `transferOwnership` directly in `initialize` function."",
      ""Severity"": ""Low"",
      ""Description"": ""The `transferOwnership` function is used in `initialize` rather than `_transferOwnership`. Since `transferOwnership` emits an event `OwnershipTransferred`, the listener watching for admin changes may be triggered before the contract initialization completes. While this does not create any logical bugs, the emitted event is not useful and can confuse the listener."",
      ""Impact"": ""Event emitted before initialization completed."",
      ""Location"": ""initialize function""
    },
    {
      ""Issue"": ""Unbounded Amount in `unlockShares` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The unlockShares function takes an `amount` and directly transfers from the contract to the savingsAccount. There's no explicit check to ensure that this amount is a valid amount of shares or tokens and that it is less than or equal to the balance of the contract."",
      ""Impact"": ""Potential for accidental or malicious transfer of an invalid share amount."",
      ""Location"": ""unlockShares function""
    },
    {
      ""Issue"": ""Potential Loss of Precision in `getTokensForShares`"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `getTokensForShares` fetches the price per full share from an external contract `IyVault` using `IyVault(liquidityToken[asset]).getPricePerFullShare()`.  If `getPricePerFullShare()` returns a small value or `shares` is relatively small, the result of the multiplication may be truncated significantly by the final division. This results in loss of precision that could lead to unexpected behavior or financial losses."",
      ""Impact"": ""Inaccurate conversions between shares and tokens, potentially affecting user balances or contract logic."",
      ""Location"": ""YearnYield.sol:132""
    },
     {
      ""Issue"": ""Potential rounding error in `getSharesForTokens` calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `getSharesForTokens` function, the shares are calculated as `(amount.mul(1e18)).div(getTokensForShares(1e18, asset))`. Depending on the values of `amount` and `getTokensForShares(1e18, asset)`, this calculation may result in rounding errors, leading to an inaccurate representation of the shares received for a given amount of tokens."",
      ""Impact"": ""Slightly inaccurate share calculations could lead to minor discrepancies in accounting."",
      ""Location"": ""YearnYield.sol:136""
    },
    {
      ""Issue"": ""Missing Input Validation on `shares` in `getTokensForShares`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `getTokensForShares` function calculates the amount based on `shares`.  While unlikely to cause a critical failure, extremely large values of `shares` could potentially lead to integer overflow in the multiplication `getPricePerFullShare().mul(shares)`."",
      ""Impact"": ""Potential for inaccurate calculations or unexpected behavior with extremely large input values of shares."",
      ""Location"": ""YearnYield.sol:132""
    },
    {
      ""Issue"": ""Double Approval risk in depositERC20"",
      ""Severity"": ""Low"",
      ""Description"": ""The code uses approve(0) before approve(amount). While seemingly defensive, it can be problematic in practice, as it spends gas and opens up potential issues if the underlying token has non-standard ERC20 behavior. Most ERC20 implementations don't require or even correctly handle the approve(0) pattern."",
      ""Impact"": ""Increased gas costs, potential issues with non-standard ERC20 tokens"",
      ""Location"": ""_depositERC20 function""
    },
    {
      ""Issue"": ""Unnecessary Approval with Zero Value in _depositERC20"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_depositERC20` function calls `IERC20(asset).approve(vault, 0)` before approving the actual amount. While this might seem like a security measure, it's generally redundant and consumes unnecessary gas. If the current allowance is already sufficient, this zero approval has no effect. If it's insufficient, the subsequent approval will overwrite it anyway."",
      ""Impact"": ""Slightly higher gas costs for each deposit operation."",
      ""Location"": ""_depositERC20 function""
    },
    {
      ""Issue"": ""Potential DoS in `emergencyWithdraw` due to unlimited loop possibility if `_asset == address(0)`"",
      ""Severity"": ""Low"",
      ""Description"": ""In function `emergencyWithdraw`, when `_asset == address(0)`, it calls function `_withdrawETH`. When ETH is transferred to the `_wallet` using `call`, the recipient contract might revert the transaction if it has some malicious code."",
      ""Impact"": ""DoS for `emergencyWithdraw` function when trying to withdraw ETH from a malicious contract, blocking the possibility of further withdraws."",
      ""Location"": ""YearnYield.sol:emergencyWithdraw""
    },
    {
      ""Issue"": ""Unprotected `receive()` function"",
      ""Severity"": ""Info"",
      ""Description"": ""The contract has a `receive()` function that allows it to receive ETH. However, there is no logic within the function beyond the implicit acceptance of ETH."",
      ""Impact"": ""Accidental or malicious ETH transfers could get stuck in the contract."",
      ""Location"": ""receive() function.""
    },
    {
      ""Issue"": ""Redundant `require` statement in `unlockShares`."",
      ""Severity"": ""Info"",
      ""Description"": ""In the `unlockShares` function, a `require(asset != address(0), \'Asset address cannot be address(0)\')` statement is present, but this function is intended to transfer the native `asset`, and the `liquidityToken` associated with an `asset` cannot be `address(0)`, so this `require` statement is not neccessary."",
      ""Impact"": ""Unnecessary gas consumption."",
      ""Location"": ""unlockShares function""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 20
}",190.8102369308472,3891.0,32.0,"### **[H-04] Yearn token <> shares conversion decimal issue**

**Report Description**:  
The `YearnYield` strategy converts shares to tokens using the formula `pricePerFullShare * shares / 1e18`. However, Yearn's `getPricePerFullShare` returns a value in `vault.decimals()` precision, meaning the correct conversion should be `pricePerFullShare * shares / (10 ** vault.decimals())`. This discrepancy can lead to incorrect token calculations, especially when the underlying token's decimals differ from `1e18`. This issue could result in financial losses or incorrect accounting for users interacting with the contract.

**Match in Response List**:  
Matches with the issue titled **""Potential rounding errors and loss of precision in `getTokensForShares` and `getSharesForTokens`, also `getTokensForShares` might overflow""**.

**Validation**:  
**Partially Correct**. The response identifies the potential for rounding errors and loss of precision in the `getTokensForShares` function, which aligns with the issue. However, it does not explicitly address the core problem of using `1e18` instead of `vault.decimals()` for the division. This omission means the response misses the critical detail that could lead to significant miscalculations. While the response correctly highlights the risk of overflow and precision loss, it does not fully address the specific decimal precision issue described in the report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-04] Yearn token <> shares conversion decimal issue**

**Missed Issues from Issue Report**:  
- *None*

---

### **Analysis**  
The response list partially addresses the issue by identifying the potential for rounding errors and overflow in the `getTokensForShares` function. However, it fails to fully capture the specific decimal precision issue, which is a critical aspect of the vulnerability. This gap highlights the need for more detailed analysis of the underlying logic in the response list.","```
None.
```",0.0
AaveYield.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/IWETHGateway.sol';
import '../interfaces/Invest/AaveLendingPool.sol';
import '../interfaces/Invest/IScaledBalanceToken.sol';
import '../interfaces/Invest/IProtocolDataProvider.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into Aave protocol
 * @author Sublime
 **/
contract AaveYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice address of wethGateway used to deposit ETH to aave
     */
    address public wethGateway;

    /**
     * @notice address of protocolDataProvider which provides info about aTokens related to any token
     */
    address public protocolDataProvider;

    /**
     * @notice address of lendingPoolAddressesProvider used to get the pool related to any token
     */
    address public lendingPoolAddressesProvider;

    /**
     * @notice address of savings account contract
     */
    address payable public savingsAccount;

    /**
     * @notice aave referral code to represent sublime
     */
    uint16 public referralCode;

    /**
     * @notice emitted when aave protocol related addresses are updated
     * @param wethGateway address of wethGateway
     * @param protocolDataProvider address of protocol data provider
     * @param lendingPoolAddressesProvider address of lending pool addresses provider
     */
    event AaveAddressesUpdated(
        address indexed wethGateway,
        address indexed protocolDataProvider,
        address indexed lendingPoolAddressesProvider
    );

    /**
     * @notice emitted when aave referral code is updated
     * @param referralCode updated referral code
     */
    event ReferralCodeUpdated(uint16 referralCode);

    /**
     * @notice verifies if savings account invoked the contract
     */
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    /**
     * @notice To initialize the contract addresses interacting with this contract
     * @dev can only be initialized once
     * @param _owner address of owner
     * @param _savingsAccount address of the savings account contract
     * @param _wethGateway address of wethGateway
     * @param _protocolDataProvider the address of ProtocolDataProvider
     * @param _lendingPoolAddressesProvider the address of LendingPoolAddressesProvider
     **/
    function initialize(
        address _owner,
        address payable _savingsAccount,
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    /**
     * @notice Used to get liquidity token address from asset address
     * @param asset the address of underlying token
     * @return aToken address of liquidity token
     **/
    function liquidityToken(address asset) public view override returns (address aToken) {
        if (asset == address(0)) {
            aToken = IWETHGateway(wethGateway).getAWETHAddress();
        } else {
            (aToken, , ) = IProtocolDataProvider(protocolDataProvider).getReserveTokensAddresses(asset);
        }
    }

    /**
     * @notice used to update savings account address
     * @dev only owner can update
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update aave protocol related addresses
     * @dev only owner can update
     * @param _wethGateway address of wethGateway
     * @param _protocolDataProvider address of protocol data provider
     * @param _lendingPoolAddressesProvider address of lending pool addresses provider
     */
    function updateAaveAddresses(
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) external onlyOwner {
        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    function _updateAaveAddresses(
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) internal {
        require(_wethGateway != address(0), 'Invest: WETHGateway:: zero address');
        require(_protocolDataProvider != address(0), 'Invest: protocolDataProvider:: zero address');
        require(_lendingPoolAddressesProvider != address(0), 'Invest: lendingPoolAddressesProvider:: zero address');
        wethGateway = _wethGateway;
        protocolDataProvider = _protocolDataProvider;
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        emit AaveAddressesUpdated(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    /**
     * @notice used to update referral code
     * @dev only owner can update
     * @param _referralCode updated referral code
     */
    function updateReferralCode(uint16 _referralCode) external onlyOwner {
        referralCode = _referralCode;
        emit ReferralCodeUpdated(_referralCode);
    }

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _wallet address to which tokens are withdrawn
     */
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        uint256 amount = IERC20(liquidityToken(_asset)).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    /**
     * @notice Used to lock tokens in protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');

        address investedTo;
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            (investedTo, sharesReceived) = _depositETH(amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            (investedTo, sharesReceived) = _depositERC20(asset, amount);
        }

        emit LockedTokens(user, investedTo, sharesReceived);
    }

    /**
     * @notice Used to unlock tokens from available protocol
     * @param asset the address of underlying token
     * @param amount the amount of asset
     * @return received amount of tokens received
     **/
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');

        if (asset == address(0)) {
            received = _withdrawETH(amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    /**
     * @notice Used to unlock shares
     * @param asset the address of underlying token
     * @param amount the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    /**
     * @notice Used to get amount of underlying tokens for current number of shares
     * @param shares the amount of shares
     * @param asset the address of token locked
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
        if (shares == 0) return 0;
        address aToken = liquidityToken(asset);

        (, , , , , , , uint256 liquidityIndex, , ) = IProtocolDataProvider(protocolDataProvider).getReserveData(asset);

        amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(
            IERC20(aToken).balanceOf(address(this))
        );
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param amount the amount of tokens
     * @param asset the address of token
     * @return shares amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(uint256 amount) internal returns (address aToken, uint256 sharesReceived) {
        aToken = IWETHGateway(wethGateway).getAWETHAddress();

        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        //lock collateral
        IWETHGateway(wethGateway).depositETH{value: amount}(lendingPool, address(this), referralCode);

        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);
    }

    function _depositERC20(address asset, uint256 amount) internal returns (address aToken, uint256 sharesReceived) {
        aToken = liquidityToken(asset);
        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        //approve collateral to vault
        IERC20(asset).approve(lendingPool, 0);
        IERC20(asset).approve(lendingPool, amount);

        //lock collateral in vault
        AaveLendingPool(lendingPool).deposit(asset, amount, address(this), referralCode);

        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);
    }

    function _withdrawETH(uint256 amount) internal returns (uint256 received) {
        IERC20(IWETHGateway(wethGateway).getAWETHAddress()).approve(wethGateway, amount);

        uint256 ethBalance = address(this).balance;

        //lock collateral
        IWETHGateway(wethGateway).withdrawETH(amount, address(this));

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(address asset, uint256 amount) internal returns (uint256 tokensReceived) {
        address aToken = liquidityToken(asset);

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        uint256 tokensBefore = IERC20(asset).balanceOf(address(this));

        IERC20(aToken).approve(lendingPool, amount);

        //withdraw collateral from vault
        AaveLendingPool(lendingPool).withdraw(asset, amount, address(this));

        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(tokensBefore);
    }

    receive() external payable {}
}

",2772,335,"[H-05] Aave's share tokens are rebasing breaking current strategy code

When depositing into Aave through the `AaveYield.lockTokens` contract strategy, one receives the sharesReceived amount corresponding to the diff of aToken balance, which is just always the deposited amount as aave is a rebasing token and 1.0 aToken = 1.0 underlying at each deposit / withdrawal.
Note that this sharesReceived (the underlying deposit amount) is cached in a balanceInShares map in SavingsAccount.deposit which makes this share static and not dynamically rebasing anymore:
  [M-07] AaveYield: Misspelled external function name making functions fail

In AaveYield.sol the functions:
liquidityToken
_withdrawETH
_depositETH
Make a conditional call to `IWETHGateway(wethGateway).getAWETHAddress()`
This function does not exist in the wethGateway contract, causing these function to fail with the error ""Fallback not allowed"".
The function they should be calling is getWethAddress() without the ""A"".
Small yet dangerous typo.
",2,,"pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/IWETHGateway.sol';
import '../interfaces/Invest/AaveLendingPool.sol';
import '../interfaces/Invest/IScaledBalanceToken.sol';
import '../interfaces/Invest/IProtocolDataProvider.sol';


contract AaveYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    
    address public wethGateway;

    
    address public protocolDataProvider;

    
    address public lendingPoolAddressesProvider;

    
    address payable public savingsAccount;

    
    uint16 public referralCode;

    
    event AaveAddressesUpdated(
        address indexed wethGateway,
        address indexed protocolDataProvider,
        address indexed lendingPoolAddressesProvider
    );

    
    event ReferralCodeUpdated(uint16 referralCode);

    
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    
    function initialize(
        address _owner,
        address payable _savingsAccount,
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    
    function liquidityToken(address asset) public view override returns (address aToken) {
        if (asset == address(0)) {
            aToken = IWETHGateway(wethGateway).getAWETHAddress();
        } else {
            (aToken, , ) = IProtocolDataProvider(protocolDataProvider).getReserveTokensAddresses(asset);
        }
    }

    
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    
    function updateAaveAddresses(
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) external onlyOwner {
        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    function _updateAaveAddresses(
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) internal {
        require(_wethGateway != address(0), 'Invest: WETHGateway:: zero address');
        require(_protocolDataProvider != address(0), 'Invest: protocolDataProvider:: zero address');
        require(_lendingPoolAddressesProvider != address(0), 'Invest: lendingPoolAddressesProvider:: zero address');
        wethGateway = _wethGateway;
        protocolDataProvider = _protocolDataProvider;
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        emit AaveAddressesUpdated(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    
    function updateReferralCode(uint16 _referralCode) external onlyOwner {
        referralCode = _referralCode;
        emit ReferralCodeUpdated(_referralCode);
    }

    
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        uint256 amount = IERC20(liquidityToken(_asset)).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');

        address investedTo;
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            (investedTo, sharesReceived) = _depositETH(amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            (investedTo, sharesReceived) = _depositERC20(asset, amount);
        }

        emit LockedTokens(user, investedTo, sharesReceived);
    }

    
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');

        if (asset == address(0)) {
            received = _withdrawETH(amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    
    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
        if (shares == 0) return 0;
        address aToken = liquidityToken(asset);

        (, , , , , , , uint256 liquidityIndex, , ) = IProtocolDataProvider(protocolDataProvider).getReserveData(asset);

        amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(
            IERC20(aToken).balanceOf(address(this))
        );
    }

    
    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(uint256 amount) internal returns (address aToken, uint256 sharesReceived) {
        aToken = IWETHGateway(wethGateway).getAWETHAddress();

        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        
        IWETHGateway(wethGateway).depositETH{value: amount}(lendingPool, address(this), referralCode);

        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);
    }

    function _depositERC20(address asset, uint256 amount) internal returns (address aToken, uint256 sharesReceived) {
        aToken = liquidityToken(asset);
        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        
        IERC20(asset).approve(lendingPool, 0);
        IERC20(asset).approve(lendingPool, amount);

        
        AaveLendingPool(lendingPool).deposit(asset, amount, address(this), referralCode);

        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);
    }

    function _withdrawETH(uint256 amount) internal returns (uint256 received) {
        IERC20(IWETHGateway(wethGateway).getAWETHAddress()).approve(wethGateway, amount);

        uint256 ethBalance = address(this).balance;

        
        IWETHGateway(wethGateway).withdrawETH(amount, address(this));

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(address asset, uint256 amount) internal returns (uint256 tokensReceived) {
        address aToken = liquidityToken(asset);

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        uint256 tokensBefore = IERC20(asset).balanceOf(address(this));

        IERC20(aToken).approve(lendingPool, amount);

        
        AaveLendingPool(lendingPool).withdraw(asset, amount, address(this));

        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(tokensBefore);
    }

    receive() external payable {}
}",1924,1,1,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control and Upgradeability"",
      ""Tasks"": [
        ""Verify the correct implementation of OwnableUpgradeable and the initialization process."",
        ""Confirm that only the owner can call `updateSavingsAccount`, `updateAaveAddresses`, `updateReferralCode`, and `emergencyWithdraw` functions."",
        ""Analyze the upgrade process and potential security implications of upgrading the contract."",
        ""Check for any potential vulnerabilities related to ownership transfer or privileged roles.""
      ]
    },
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Verify that the `nonReentrant` modifier is correctly applied to all external functions that modify state (e.g., `lockTokens`, `unlockTokens`, `unlockShares`)."",
        ""Analyze potential reentrancy attack vectors, especially when interacting with external contracts like AaveLendingPool and IWETHGateway."",
        ""Specifically analyze reentrancy possibilities in `_depositETH`, `_depositERC20`, `_withdrawETH`, and `_withdrawERC`.""
      ]
    },
    {
      ""Area"": ""Arithmetic Overflows/Underflows"",
      ""Tasks"": [
        ""Review all arithmetic operations to ensure they are protected against overflows and underflows using SafeMath or Solidity 0.8+ features."",
        ""Pay close attention to calculations in `getTokensForShares`, `getSharesForTokens`, `_depositETH`, `_depositERC20`, `_withdrawETH`, and `_withdrawERC`.""
      ]
    },
    {
      ""Area"": ""Interaction with Aave Protocol"",
      ""Tasks"": [
        ""Verify the correctness of the addresses used for Aave-related contracts (WETHGateway, ProtocolDataProvider, LendingPoolAddressesProvider)."",
        ""Analyze the logic for depositing and withdrawing both ETH and ERC20 tokens to ensure it aligns with Aave's intended usage."",
        ""Check for potential issues related to slippage, liquidation, or other Aave-specific risks."",
        ""Ensure that approvals are handled correctly when interacting with the Aave LendingPool (especially the zero approval before setting approval to amount in `_depositERC20`).""
      ]
    },
    {
      ""Area"": ""Token and ETH Handling"",
      ""Tasks"": [
        ""Verify that ETH is handled correctly in `lockTokens`, `unlockTokens`, `_depositETH`, and `_withdrawETH`."",
        ""Ensure that the contract has sufficient ETH balance before attempting to send ETH in `_withdrawETH`."",
        ""Check that ERC20 tokens are transferred correctly using `safeTransfer` and `safeTransferFrom`."",
        ""Verify that the contract handles different ERC20 token implementations correctly, including those with non-standard return values."",
        ""Review the `emergencyWithdraw` function and ensure that it cannot be abused to drain funds from the contract.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify potential areas for gas optimization, such as reducing the number of storage reads/writes or using more efficient arithmetic operations."",
        ""Consider using calldata instead of memory for function arguments where appropriate."",
        ""Evaluate the gas cost of external calls to Aave contracts and explore ways to reduce them.""
      ]
    },
    {
      ""Area"": ""Precision and Calculation Errors"",
      ""Tasks"": [
        ""Analyze the `getTokensForShares` and `getSharesForTokens` functions for potential precision loss issues due to integer division."",
        ""Verify that the calculations involving `liquidityIndex` and `scaledBalanceOf` are correct and do not lead to unexpected results."",
        ""Consider using more precise calculations (e.g., using a higher number of decimals) if necessary.""
      ]
    },
    {
      ""Area"": ""Authorization and Role Management"",
      ""Tasks"": [
        ""Confirm that the `onlySavingsAccount` modifier is working as intended and only allows the savings account to call restricted functions."",
        ""Evaluate the security implications of allowing the savings account to control the deposit and withdrawal of funds."",
        ""Consider adding additional access control mechanisms if necessary.""
      ]
    },
    {
      ""Area"": ""Unlocked Shares Functionality"",
      ""Tasks"": [
        ""Analyze the `unlockShares` function's logic, particularly the direct transfer of aTokens. Ensure there are no unintended consequences or security risks associated with this transfer."",
        ""Determine if additional checks are needed before transferring aTokens to the savings account.""
      ]
    },
    {
      ""Area"": ""Denial of Service"",
      ""Tasks"": [
          ""Check if the contract's functionalities can be halted due to external calls failing."",
          ""Check gas limits on external calls that may lead to transaction revertion.""
      ]
    },
    {
      ""Area"": ""Unused Approval Amounts"",
      ""Tasks"":[
        ""Analyse the potential risks related to setting approvals, particularly the potential for front-running if the approved amount is significantly larger than the intended deposit amount. Determine if alternative approval strategies should be considered.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code implements a yield aggregator strategy that interacts with Aave to deposit and withdraw funds. It allows a 'savingsAccount' contract to lock and unlock tokens into Aave, effectively earning yield on deposited assets. The contract uses OpenZeppelin's upgradeable contracts, access control (Ownable), reentrancy guard, ERC20 safe operations, and math library for safe arithmetic. It handles both ETH and ERC20 tokens."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""AaveYield"",
    ""Purpose"": ""Allows a designated savings account to deposit and withdraw tokens into Aave protocol for yield farming."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""IYield"",
        ""Initializable"",
        ""OwnableUpgradeable"",
        ""ReentrancyGuard""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"",
        ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"",
        ""@openzeppelin/contracts/math/SafeMath.sol"",
        ""../interfaces/IYield.sol"",
        ""../interfaces/Invest/IWETHGateway.sol"",
        ""../interfaces/Invest/AaveLendingPool.sol"",
        ""../interfaces/Invest/IScaledBalanceToken.sol"",
        ""../interfaces/Invest/IProtocolDataProvider.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""wethGateway"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the WETH Gateway contract.""
      },
      {
        ""Name"": ""protocolDataProvider"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the Protocol Data Provider contract.""
      },
      {
        ""Name"": ""lendingPoolAddressesProvider"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the Lending Pool Addresses Provider contract.""
      },
      {
        ""Name"": ""savingsAccount"",
        ""Type"": ""address payable"",
        ""Purpose"": ""Address of the savings account contract which is allowed to call lock/unlock functions.""
      },
      {
        ""Name"": ""referralCode"",
        ""Type"": ""uint16"",
        ""Purpose"": ""Referral code used when interacting with Aave.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract, setting the owner and Aave addresses."",
        ""Parameters"": [
          ""_owner"",
          ""_savingsAccount"",
          ""_wethGateway"",
          ""_protocolDataProvider"",
          ""_lendingPoolAddressesProvider""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""liquidityToken"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the address of the Aave token (aToken) for a given asset."",
        ""Parameters"": [""asset""],
        ""Returns"": [""aToken""]
      },
      {
        ""Name"": ""updateSavingsAccount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the address of the savings account."",
        ""Parameters"": [""_savingsAccount""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateAaveAddresses"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the addresses of the Aave-related contracts."",
        ""Parameters"": [
          ""_wethGateway"",
          ""_protocolDataProvider"",
          ""_lendingPoolAddressesProvider""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""updateReferralCode"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the referral code."",
        ""Parameters"": [""_referralCode""],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to withdraw any accidentally sent tokens or ETH from the contract."",
        ""Parameters"": [""_asset"", ""_wallet""],
        ""Returns"": [""received""]
      },
      {
        ""Name"": ""lockTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the savings account to lock tokens into Aave, depositing either ETH or ERC20 tokens."",
        ""Parameters"": [""user"", ""asset"", ""amount""],
        ""Returns"": [""sharesReceived""]
      },
      {
        ""Name"": ""unlockTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the savings account to unlock tokens from Aave, withdrawing either ETH or ERC20 tokens."",
        ""Parameters"": [""asset"", ""amount""],
        ""Returns"": [""received""]
      },
      {
        ""Name"": ""unlockShares"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the savings account to transfer aTokens to the savings account"",
        ""Parameters"": [""asset"", ""amount""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getTokensForShares"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the amount of underlying tokens represented by a given number of shares (aTokens)."",
        ""Parameters"": [""shares"", ""asset""],
        ""Returns"": [""amount""]
      },
      {
        ""Name"": ""getSharesForTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Calculates the number of shares (aTokens) needed to represent a given amount of underlying tokens."",
        ""Parameters"": [""amount"", ""asset""],
        ""Returns"": [""shares""]
      },
      {
        ""Name"": ""_depositETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Deposits ETH into Aave via the WETH Gateway."",
        ""Parameters"": [""amount""],
        ""Returns"": [""aToken"", ""sharesReceived""]
      },
      {
        ""Name"": ""_depositERC20"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Deposits ERC20 tokens into Aave via the LendingPool contract."",
        ""Parameters"": [""asset"", ""amount""],
        ""Returns"": [""aToken"", ""sharesReceived""]
      },
      {
        ""Name"": ""_withdrawETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Withdraws ETH from Aave via the WETH Gateway."",
        ""Parameters"": [""amount""],
        ""Returns"": [""received""]
      },
      {
        ""Name"": ""_withdrawERC"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Withdraws ERC20 tokens from Aave via the LendingPool contract."",
        ""Parameters"": [""asset"", ""amount""],
        ""Returns"": [""tokensReceived""]
      },
      {
        ""Name"": ""onlySavingsAccount"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function calls to only the savings account."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""nonReentrant"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Prevents reentrancy attacks."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IWETHGateway"",
    ""IProtocolDataProvider"",
    ""ILendingPoolAddressesProvider"",
    ""AaveLendingPool"",
    ""IERC20"",
    ""IScaledBalanceToken""
  ],
  ""SpecialMechanisms"": [
    ""Uses Aave protocol for lending and borrowing."",
    ""Uses OpenZeppelin's OwnableUpgradeable pattern for access control."",
    ""Uses OpenZeppelin's ReentrancyGuard to prevent reentrancy attacks."",
    ""Handles both ETH and ERC20 deposits/withdrawals."",
    ""Uses a savings account to interact with the contract, separating concerns.""
  ],
  ""Questions"": [
    ""The calculation of `getTokensForShares` seems complex and potentially error-prone.  It relies on `scaledBalanceOf` and `liquidityIndex`. Are there any potential issues with precision or unexpected values that could lead to incorrect calculations?"",
    ""The `unlockShares` function simply transfers the aTokens and returns the amount. Is it safe to transfer aTokens directly in this scenario? Should the contract ensure the user has enough underlying assets?"",
    ""In the `_depositERC20` function, the approval is first set to 0 and then to `amount`. Is this necessary and safe, or could it potentially lead to issues if the token has a different approval mechanism?"",
    ""Why is `liquidityIndex` multiplied with `shares` and `scaledBalanceOf`? Is it right to multiply it with `shares`?"",
    ""The contract uses `OwnableUpgradeable`. Is the upgrade process well-defined and secure?"",
    ""Should the `emergencyWithdraw` function have a more granular control over the amount that can be withdrawn?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Missing Access Control on `emergencyWithdraw` can lead to fund draining."",
      ""Severity"": ""High"",
      ""Description"": ""The `emergencyWithdraw` function allows the owner to withdraw any ERC20 or ETH balance held by the contract without sufficient safeguards. If the owner's account is compromised, an attacker could drain all assets. The function lacks reentrancy protection and additional validation checks, increasing the risk."",
      ""Impact"": ""Complete loss of funds held by the contract, potential for malicious fund draining if the owner's account is compromised. Vulnerable to reentrancy attacks."",
      ""Location"": ""AaveYield.sol:100, emergencyWithdraw function""
    },
    {
      ""Issue"": ""Potential Reentrancy in `emergencyWithdraw`"",
      ""Severity"": ""High"",
      ""Description"": ""The `emergencyWithdraw` function allows the owner to withdraw tokens/ETH. The `_wallet.call{value: received}(\'\')` in ETH withdrawals and `IERC20(_asset).safeTransfer(_wallet, received)` in ERC20 withdrawals can potentially lead to a reentrancy attack if the recipient is a malicious contract that calls back into the `AaveYield` contract. While `lockTokens` and `unlockTokens` are guarded by `nonReentrant`, `emergencyWithdraw` isn't."",
      ""Impact"": ""A malicious contract could potentially drain the AaveYield contract's ETH/ERC20 balance through a reentrancy attack."",
      ""Location"": ""AaveYield.sol:123, emergencyWithdraw function, ETH withdrawal path, AaveYield.sol:114-122, AaveYield.sol:95-104""
    },
    {
      ""Issue"": ""Lack of Access Control on Aave Addresses Update"",
      ""Severity"": ""High"",
      ""Description"": ""The `updateAaveAddresses` function, while protected by the `onlyOwner` modifier, is crucial for the correct functioning of the contract. If the owner mistakenly sets these addresses to incorrect or malicious contracts, it could completely break the contract's functionality or allow for malicious actions. There is a missing zero-address check for `lendingPoolAddressesProvider` within the `_updateAaveAddresses` function."",
      ""Impact"": ""Complete failure of contract functionality or potential malicious actions if Aave addresses are set incorrectly."",
      ""Location"": ""updateAaveAddresses function, _updateAaveAddresses function, AaveYield.sol:78-90""
    },
    {
      ""Issue"": ""Potential Reentrancy in `_withdrawETH` and `_withdrawERC`"",
      ""Severity"": ""High"",
      ""Description"": ""The `_withdrawETH` and `_withdrawERC` functions involve calling external contracts (WETHGateway for ETH withdrawals, the asset token for ERC20 withdrawals and Aave lending pool).  If the `savingsAccount` is a malicious contract, it could potentially re-enter the `unlockTokens` function after receiving the funds but before the function completes its execution. There is also a reentrancy risk in the `IWETHGateway(wethGateway).withdrawETH` and `AaveLendingPool(lendingPool).withdraw` calls in `_withdrawETH` and `_withdrawERC`."",
      ""Impact"": ""Potential for malicious contracts to exploit the withdrawal process and drain funds."",
      ""Location"": ""_withdrawETH function, _withdrawERC function, unlockTokens function, AaveYield.sol:228, AaveYield.sol:242, AaveYield.sol:131""
    },
    {
      ""Issue"": ""Potential Reentrancy risk in `_withdrawETH` and `_withdrawERC` functions during Aave withdrawal."",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_withdrawETH` and `_withdrawERC` functions interact with Aave to withdraw funds. The `ReentrancyGuard` is used on the `lockTokens` and `unlockTokens` functions but is not placed on the withdrawal functions directly. Aave might call back the contract during the withdrawal process, potentially leading to a reentrancy attack if not handled carefully.  Specifically the savingsAccount.call{value: received}('')` call can also introduce reentrancy risks."",
      ""Impact"": ""Potential for reentrancy attacks, allowing attackers to drain funds or manipulate the contract state during Aave interactions."",
      ""Location"": ""AaveYield.sol:228, AaveYield.sol:242, AaveYield.sol:131""
    },
    {
      ""Issue"": ""Lack of slippage control in `_withdrawETH` and `_withdrawERC`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_withdrawETH` and `_withdrawERC` functions withdraw assets from Aave without slippage control. Market fluctuations or changes in Aave's state between the time the withdrawal is initiated and when it is completed may result in receiving less than expected ETH or ERC20 tokens, which leads to a loss of funds."",
      ""Impact"": ""Financial loss for the savings account due to unfavorable price slippage during withdrawals. The received token amount can be different than expected."",
      ""Location"": ""AaveYield.sol:263, AaveYield.sol:279, `_withdrawETH` function, `_withdrawERC` function""
    },
    {
      ""Issue"": ""Approve-before-deposit pattern in `_depositERC20` function is vulnerable to front-running attacks."",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_depositERC20` function uses `IERC20(asset).approve(lendingPool, 0); IERC20(asset).approve(lendingPool, amount);` before depositing into Aave. This approve-then-deposit pattern is vulnerable to front-running attacks. An attacker could observe the `approve` transaction and then execute their own transaction to transfer tokens from this contract before the Aave deposit happens, causing the deposit to fail or be less than intended. A missing check on LendingPool.deposit could potentially lock user's funds or cause the transaction to revert unexpectedly."",
      ""Impact"": ""Potential loss of funds or unexpected deposit amounts due to front-running."",
      ""Location"": ""AaveYield.sol:213-214, _depositERC20 function""
    },
    {
      ""Issue"": ""Lack of Slippage Control During `_depositETH` and `_depositERC20` can lead to loss of funds."",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_depositETH` and `_depositERC20` functions deposit funds into Aave without considering slippage. This means that if the market conditions change between the time the transaction is submitted and the time it is mined, the user may receive fewer aTokens than expected. In extreme cases, the transaction could revert, or the user could lose a significant portion of their deposited funds."",
      ""Impact"": ""Potential loss of funds for users during deposits due to unfavorable market conditions."",
      ""Location"": ""AaveYield.sol:196, AaveYield.sol:208""
    },
    {
      ""Issue"": ""Missing check for sufficient allowance before depositing ERC20 tokens"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_depositERC20` function lacks a check to ensure that the contract has sufficient allowance from the user to transfer tokens. A malicious user can still frontrun this by revoking the allowance after the `lockTokens` function call but before `_depositERC20`'s `deposit` function call."",
      ""Impact"": ""The deposit can fail if the user revokes the allowance right after the `lockTokens` function is called, potentially leading to unexpected behavior."",
      ""Location"": ""_depositERC20 function, AaveYield.sol:237-249""
    },
    {
      ""Issue"": ""Incorrect Calculation of `getTokensForShares`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `getTokensForShares` function calculates the amount of underlying tokens corresponding to a given number of shares. However, the calculation `IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(IERC20(aToken).balanceOf(address(this)))` is flawed and leads to inaccurate results."",
      ""Impact"": ""Inaccurate calculation of token amounts for shares, leading to discrepancies during withdrawals or redemptions. Users might receive an incorrect amount of underlying tokens, leading to financial loss."",
      ""Location"": ""AaveYield.sol:202, `getTokensForShares` function, AaveYield.sol:157, AaveYield.sol:195-201""
    },
    {
      ""Issue"": ""Unbounded Allowance Setting in `_depositERC20` and `_withdrawERC`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_depositERC20` and `_withdrawERC` function, the contract approves the lendingPool for the entire amount being deposited/withdrawn using `IERC20(asset).approve(lendingPool, amount);` and `IERC20(aToken).approve(lendingPool, amount);`. Also in the `_withdrawERC` function, this approval can potentially be front-run and abused."",
      ""Impact"": ""This can potentially be front-run or exploited if the LendingPool contract has vulnerabilities. A malicious actor might be able to drain the contract\'s allowance if the LendingPool is compromised or controlled by an attacker. It's advisable to either approve a smaller amount or use increaseAllowance/decreaseAllowance patterns."",
      ""Location"": ""_depositERC20, _withdrawERC""
    },
    {
      ""Issue"": ""Inconsistent Use of `transferOwnership`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `initialize` function uses `super.transferOwnership(_owner);` instead of `_transferOwnership(_owner);`.  Using the internal function `_transferOwnership` directly would avoid emitting the `OwnershipTransferred` event during initialization, which is generally preferred since the event typically signals a change of ownership after the contract has been set up."",
      ""Impact"": ""Cosmetic, but inconsistent with best practices."",
      ""Location"": ""AaveYield.sol:46""
    },
    {
      ""Issue"": ""Unnecessary Approval to Zero Before Approval"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `_depositERC20` function, the code includes `IERC20(asset).approve(lendingPool, 0);` before approving the actual amount. While not inherently harmful, this extra transaction costs gas and is generally considered bad practice as more gas is consumed overall."",
      ""Impact"": ""Slightly increased gas costs for users."",
      ""Location"": ""AaveYield.sol:241, _depositERC20 function""
    },
    {
      ""Issue"": ""Potential precision loss in `getSharesForTokens`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `getSharesForTokens` function calculates the number of shares corresponding to a given amount of tokens using `shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));`.  Since `getTokensForShares` might return a small value, the result of the division could be truncated, resulting in a loss of precision."",
      ""Impact"": ""The shares given may be rounded down and less than what they should be."",
      ""Location"": ""AaveYield.sol:207""
    },
    {
      ""Issue"": ""Unprotected `receive()` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract implements a `receive()` function without any access control. While it doesn't directly expose any vulnerabilities in this specific contract implementation, it can be a point of concern since anyone can send ETH to the contract, potentially affecting accounting or requiring additional logic to handle unexpected ETH deposits."",
      ""Impact"": ""Potentially unexpected ETH balance in the contract. It may need to be handled separately for accounting or reporting purposes."",
      ""Location"": ""receive() function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `getSharesForTokens` Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The `getSharesForTokens` function calculates shares based on the number of tokens provided. If the returned value of `getTokensForShares(1e18, asset)` is very small, the division `(amount.mul(1e18)).div(getTokensForShares(1e18, asset))` could result in a very large `shares` value approaching the maximum uint256 value. This could cause unexpected behavior in downstream functions that use the result."",
      ""Impact"": ""Downstream functions relying on shares can be affected if this function calculates a high value."",
      ""Location"": ""AaveYield.sol:163-165""
    },
    {
      ""Issue"": ""Potential precision loss in `getTokensForShares` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The calculation in `getTokensForShares` involves multiple multiplications and divisions.  The order of operations `scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(IERC20(aToken).balanceOf(address(this)))` could lead to precision loss if `scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares)` becomes very large before the division, especially if IERC20(aToken).balanceOf(address(this)) is also large."",
      ""Impact"": ""Inaccurate calculations of the equivalent tokens for shares, potentially leading to users receiving less tokens than expected."",
      ""Location"": ""getTokensForShares function""
    },
    {
      ""Issue"": ""Lack of input validation for `shares` parameter in `getTokensForShares`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `getTokensForShares` function multiplies `shares` with other values. If the `shares` input is excessively large, this multiplication could lead to an overflow, causing incorrect results. While `SafeMath` prevents arithmetic overflows that revert, it's still good practice to prevent excessively large inputs."",
      ""Impact"": ""Incorrect calculation of the amount of tokens for given shares due to potential overflow, although SafeMath should prevent reverts."",
      ""Location"": ""getTokensForShares""
    },
    {
      ""Issue"": ""Missing checks for aToken address in `getTokensForShares` and `getSharesForTokens` can lead to incorrect calculations."",
      ""Severity"": ""Low"",
      ""Description"": ""The `getTokensForShares` and `getSharesForTokens` functions rely on the `liquidityToken` function to determine the aToken address. However, there are no explicit checks to ensure the returned `aToken` address is valid and non-zero. If `liquidityToken` were to return an invalid address (e.g., address(0)) due to an error or unexpected condition, these functions could produce incorrect calculations, leading to inaccurate share/token conversions."",
      ""Impact"": ""Inaccurate calculations of share/token conversions, potential for unexpected behavior or errors in other functions that rely on these calculations."",
      ""Location"": ""AaveYield.sol:153, AaveYield.sol:159""
    },
    {
      ""Issue"": ""Possible integer overflow in `getTokensForShares` function."",
      ""Severity"": ""Low"",
      ""Description"": ""The `getTokensForShares` function calculates the amount of tokens corresponding to a given number of shares using multiplication and division. Specifically: `amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(IERC20(aToken).balanceOf(address(this)));`. If the intermediate multiplication results (`IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares)`) are large enough, they could potentially overflow, leading to an inaccurate `amount` calculation."",
      ""Impact"": ""Inaccurate token amount calculation, potentially leading to incorrect share/token conversions."",
      ""Location"": ""AaveYield.sol:157""
    },
    {
      ""Issue"": ""Lack of input validation in `getSharesForTokens` function can lead to division by zero."",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `getSharesForTokens` function, the number of shares is calculated as `shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));`.  If `getTokensForShares(1e18, asset)` returns 0, this will result in a division by zero error, causing the transaction to revert. This could happen if the contract has very few or no tokens of the specified asset."",
      ""Impact"": ""Transaction reverts due to division by zero, preventing users from calculating the correct number of shares for a given token amount."",
      ""Location"": ""AaveYield.sol:161""
    },
    {
      ""Issue"": ""Approve to zero then amount for ERC20 in deposit"",
      ""Severity"": ""Info"",
      ""Description"": ""In `_depositERC20`, the code calls `IERC20(asset).approve(lendingPool, 0);` followed by `IERC20(asset).approve(lendingPool, amount);`. This is the recommended pattern for ERC20 approvals. However, the gas cost could be reduced if the current allowance is checked before calling approve to zero. If allowance is already zero then the first approve call can be skipped."",
      ""Impact"": ""Slightly higher gas costs, but does not cause any issues functionally."",
      ""Location"": ""_depositERC20""
    },
     {
      ""Issue"": ""Lack of input validation for address parameters"",
      ""Severity"": ""Low"",
      ""Description"": ""While the `_updateAaveAddresses` and `_updateSavingsAccount` functions include checks for zero addresses, the `lockTokens` function directly accepts user and asset addresses without validation. Although `safeTransferFrom` will revert if the user is the zero address, providing the zero address as the asset in the `lockTokens` function where ERC20 is used leads to unexpected behavior, as address(0) is a special case, and using `IERC20(address(0))` might have unexpected consequences. A require statement checking `asset != address(0)` in the else branch would provide consistency."",
      ""Impact"": ""Potential for unexpected behavior or errors if invalid addresses are used as inputs."",
      ""Location"": ""`lockTokens` function""
    },
    {
      ""Issue"": ""Approvals to lendingPool are unbounded"",
      ""Severity"": ""Medium"",
      ""Description"": ""In `_depositERC20`, the contract approves the `lendingPool` to spend tokens on behalf of this contract. In `_withdrawERC`, the contract approves the lendingPool to spend tokens on behalf of this contract. This approval remains active until explicitly revoked or overwritten. If the lendingPool contract is compromised or has vulnerabilities, it could potentially drain the approved tokens, exceeding the intended amount and causing loss to the contract's balance for that specific token. Using `increaseAllowance` and `decreaseAllowance` could reduce this risk."",
      ""Impact"": ""Potential for lendingPool to drain more tokens than intended if the lendingPool is compromised or contains vulnerabilities. Unnecessary gas usage."",
      ""Location"": ""`_depositERC20` function""
    },
        {
      ""Issue"": ""Inconsistent use of msg.value and amount when depositing ETH."",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `lockTokens` function, when `asset` is the zero address (ETH), the contract requires that `msg.value` equals `amount`. However, the function also uses `amount` in the `_depositETH` function. This can be confusing and potentially lead to errors if `amount` is not properly validated to be the correct ETH value. A malicious or mistaken caller could send the correct ETH in `msg.value` but pass a different value for the `amount` parameter, leading to unexpected behavior."",
      ""Impact"": ""Potential for confusion and errors, leading to unexpected behavior or loss of funds."",
      ""Location"": ""lockTokens and _depositETH functions""
    },
    {
      ""Issue"": ""Inconsistent use of `SafeERC20.safeTransfer` and `IERC20.safeTransfer`"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract utilizes both `SafeERC20.safeTransfer` and `IERC20.safeTransfer` methods. `SafeERC20` provides additional checks for non-standard ERC20 implementations. While the contract has `using SafeERC20 for IERC20;`, the function `unlockShares` directly uses `IERC20(asset).safeTransfer(savingsAccount, amount);` this inconsistency can lead to unexpected behavior if a non-standard ERC20 token is used."",
      ""Impact"": ""Potential issues with non-standard ERC20 tokens, leading to failed transfers or unexpected behavior. Inconsistency in code style."",
      ""Location"": ""`unlockShares` function""
    },
    {
      ""Issue"": ""Missing event for `SavingsAccountUpdated`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_updateSavingsAccount` function emits a `SavingsAccountUpdated` event, which is good. However, this event is not defined in the contract."",
      ""Impact"": ""External systems relying on this event will not function correctly, but the contract itself will."",
      ""Location"": ""AaveYield.sol:62, AaveYield.sol:90""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 26
}",198.97917199134827,3506.0,32.0,"### **[H-05] Aave's share tokens are rebasing breaking current strategy code**

**Report Description**:
When depositing into Aave through the `AaveYield.lockTokens` contract strategy, one receives the `sharesReceived` amount corresponding to the diff of `aToken` balance, which is just always the deposited amount as Aave is a rebasing token and `1.0 aToken = 1.0 underlying` at each deposit/withdrawal. Note that this `sharesReceived` (the underlying deposit amount) is cached in a `balanceInShares` map in `SavingsAccount.deposit`, which makes this share static and not dynamically rebasing anymore. This could lead to discrepancies in token balances and incorrect accounting of shares over time.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The issue describes a critical flaw in the handling of rebasing tokens (Aave's aTokens) and the static caching of shares, which could lead to incorrect accounting and potential financial discrepancies. However, the `response_list` does not address this issue at all. This is a significant oversight, as the problem directly impacts the core functionality of the contract.

---

### **[M-07] AaveYield: Misspelled external function name making functions fail**

**Report Description**:
In `AaveYield.sol`, the functions `liquidityToken`, `_withdrawETH`, and `_depositETH` make a conditional call to `IWETHGateway(wethGateway).getAWETHAddress()`. This function does not exist in the `wethGateway` contract, causing these functions to fail with the error ""Fallback not allowed"". The function they should be calling is `getWethAddress()` without the ""A"". This typo is small but dangerous, as it breaks the functionality of these critical functions.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The issue highlights a critical typo in the function name that causes the contract to fail when interacting with the `wethGateway` contract. This is a significant functional bug, but the `response_list` does not address it. This omission is a major gap in the response coverage.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-05] Aave's share tokens are rebasing breaking current strategy code**
- **[M-07] AaveYield: Misspelled external function name making functions fail**

---

### **Conclusion**:
The `response_list` fails to address two critical issues from the `issue` report. Both issues are significant and directly impact the functionality and security of the contract. The lack of coverage for these issues indicates a gap in the response's comprehensiveness and accuracy. It is essential to address these vulnerabilities to ensure the contract's robustness and security.","```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at every rank is 0, and the average of these values is also 0."
SavingsAccount.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/IYield.sol';

/**
 * @title Savings account contract with Methods related to savings account
 * @notice Implements the functions related to savings account
 * @author Sublime
 **/
contract SavingsAccount is ISavingsAccount, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice address of the strategy registry used to whitelist strategies
     */
    address public strategyRegistry;

    /**
     * @notice address of the credit lines contract
     */
    address public creditLine;

    /**
     * @notice mapping from user to token to strategy to balance of shares
     * @dev user -> token -> strategy (underlying address) -> amount (shares)
     */
    mapping(address => mapping(address => mapping(address => uint256))) public override balanceInShares;

    /**
     * @notice mapping from user to token to toAddress for approval to amount approved
     * @dev user => token => to => amount
     */
    mapping(address => mapping(address => mapping(address => uint256))) public allowance;

    /**
     * @notice modifier to check if address is the credit line
     * @param _caller address to check if credit line
     */
    modifier onlyCreditLine(address _caller) {
        require(_caller == creditLine, 'Invalid caller');
        _;
    }

    /**
     * @dev initialize the contract
     * @param _owner address of the owner of the savings account contract
     * @param _strategyRegistry address of the strategy registry
     * @param _creditLine address of the credit line contract
     **/
    function initialize(
        address _owner,
        address _strategyRegistry,
        address _creditLine
    ) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateCreditLine(_creditLine);
        _updateStrategyRegistry(_strategyRegistry);
    }

    /**
     * @notice used to update credit line contract address
     * @dev only owner can update
     * @param _creditLine updated address of credit lines
     */
    function updateCreditLine(address _creditLine) external onlyOwner {
        _updateCreditLine(_creditLine);
    }

    function _updateCreditLine(address _creditLine) internal {
        require(_creditLine != address(0), 'SavingsAccount::initialize zero address');
        creditLine = _creditLine;
        emit CreditLineUpdated(_creditLine);
    }

    /**
     * @notice used to update strategy registry address
     * @dev only owner can update
     * @param _strategyRegistry updated address of strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'SavingsAccount::updateStrategyRegistry zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to deposit tokens into strategy via savings account
     * @dev if token is address(0), then it is Ether
     * @param _amount amount of tokens deposited
     * @param _token address of token contract
     * @param _strategy address of the strategy into which tokens are to be deposited
     * @param _to address to deposit to
     */
    function deposit(
        uint256 _amount,
        address _token,
        address _strategy,
        address _to
    ) external payable override nonReentrant returns (uint256) {
        require(_to != address(0), 'SavingsAccount::deposit receiver address should not be zero address');
        uint256 _sharesReceived = _deposit(_amount, _token, _strategy);
        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_sharesReceived);
        emit Deposited(_to, _sharesReceived, _token, _strategy);
        return _sharesReceived;
    }

    function _deposit(
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        require(_amount != 0, 'SavingsAccount::_deposit Amount must be greater than zero');
        _sharesReceived = _depositToYield(_amount, _token, _strategy);
    }

    function _depositToYield(
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        require(IStrategyRegistry(strategyRegistry).registry(_strategy), 'SavingsAccount::deposit strategy do not exist');
        uint256 _ethValue;

        if (_token == address(0)) {
            _ethValue = _amount;
            require(msg.value == _amount, 'SavingsAccount::deposit ETH sent must be equal to amount');
        }
        _sharesReceived = IYield(_strategy).lockTokens{value: _ethValue}(msg.sender, _token, _amount);
    }

    /**
     * @dev Used to switch saving strategy of an _token
     * @param _currentStrategy initial strategy of token
     * @param _newStrategy new strategy to invest
     * @param _token address of the token
     * @param _amount amount of tokens to be reinvested
     */
    function switchStrategy(
        uint256 _amount,
        address _token,
        address _currentStrategy,
        address _newStrategy
    ) external override nonReentrant {
        require(_currentStrategy != _newStrategy, 'SavingsAccount::switchStrategy Same strategy');
        require(IStrategyRegistry(strategyRegistry).registry(_newStrategy), 'SavingsAccount::_newStrategy do not exist');
        require(_amount != 0, 'SavingsAccount::switchStrategy Amount must be greater than zero');

        _amount = IYield(_currentStrategy).getSharesForTokens(_amount, _token);

        balanceInShares[msg.sender][_token][_currentStrategy] = balanceInShares[msg.sender][_token][_currentStrategy].sub(
            _amount,
            'SavingsAccount::switchStrategy Insufficient balance'
        );

        uint256 _tokensReceived = IYield(_currentStrategy).unlockTokens(_token, _amount);

        uint256 _ethValue;
        if (_token != address(0)) {
            IERC20(_token).safeApprove(_newStrategy, _tokensReceived);
        } else {
            _ethValue = _tokensReceived;
        }
        _amount = _tokensReceived;
        
        uint256 _sharesReceived = IYield(_newStrategy).lockTokens{value: _ethValue}(address(this), _token, _tokensReceived);

        balanceInShares[msg.sender][_token][_newStrategy] = balanceInShares[msg.sender][_token][_newStrategy].add(_sharesReceived);
        emit StrategySwitched(msg.sender, _token, _amount, _sharesReceived, _currentStrategy, _newStrategy);
    }

    /**
     * @dev Used to withdraw token from Saving Account
     * @param _to address to which token should be sent
     * @param _amount amount of tokens to withdraw
     * @param _token address of the token to be withdrawn
     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)
     * @param _withdrawShares boolean indicating to withdraw in liquidity share or underlying token
     */
    function withdraw(
        uint256 _amount,
        address _token,
        address _strategy,
        address payable _to,
        bool _withdrawShares
    ) external override nonReentrant returns (uint256) {
        require(_amount != 0, 'SavingsAccount::withdraw Amount must be greater than zero');

        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);

        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(
            _amount,
            'SavingsAccount::withdraw Insufficient amount'
        );

        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);

        emit Withdrawn(msg.sender, _to, _amount, _token, _strategy, _withdrawShares);
        return _amountReceived;
    }

    /**
     * @dev Used to withdraw token from allowance of Saving Account
     * @param _from address from which tokens will be withdrawn
     * @param _to address to which token should be withdrawn
     * @param _amount amount of tokens to withdraw
     * @param _token address of the token to be withdrawn
     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)
     * @param _withdrawShares boolean indicating to withdraw in liquidity share or underlying token
     */

    function withdrawFrom(
        uint256 _amount,
        address _token,
        address _strategy,
        address _from,
        address payable _to,
        bool _withdrawShares
    ) external override nonReentrant returns (uint256) {
        require(_amount != 0, 'SavingsAccount::withdrawFrom Amount must be greater than zero');

        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(
            _amount,
            'SavingsAccount::withdrawFrom allowance limit exceeding'
        );

        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);

        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(
            _amount,
            'SavingsAccount::withdrawFrom insufficient balance'
        );
        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);
        emit Withdrawn(_from, msg.sender, _amount, _token, _strategy, _withdrawShares);
        return _amountReceived;
    }

    function _withdraw(
        uint256 _amount,
        address _token,
        address _strategy,
        address payable _to,
        bool _withdrawShares
    ) internal returns (address _tokenReceived, uint256 _amountReceived) {
        if (_withdrawShares) {
            _tokenReceived = IYield(_strategy).liquidityToken(_token);
            require(_tokenReceived != address(0), 'Liquidity Tokens address cannot be address(0)');
            _amountReceived = IYield(_strategy).unlockShares(_tokenReceived, _amount);
        } else {
            _tokenReceived = _token;
            _amountReceived = IYield(_strategy).unlockTokens(_token, _amount);
        }
        _transfer(_amountReceived, _tokenReceived, _to);
    }

    function _transfer(
        uint256 _amount,
        address _token,
        address payable _to
    ) internal {
        if (_token == address(0)) {
            (bool _success, ) = _to.call{value: _amount}('');
            require(_success, 'Transfer failed');
        } else {
            IERC20(_token).safeTransfer(_to, _amount);
        }
    }

    /**
     * @notice used to withdraw a token from all strategies
     * @param _token address of token which is to be withdrawn
     */
    function withdrawAll(address _token) external override nonReentrant returns (uint256 _tokenReceived) {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();

        for (uint256 i = 0; i < _strategyList.length; i++) {
            if (balanceInShares[msg.sender][_token][_strategyList[i]] != 0 && _strategyList[i] != address(0)) {
                uint256 _amount = balanceInShares[msg.sender][_token][_strategyList[i]];
                _amount = IYield(_strategyList[i]).unlockTokens(_token, balanceInShares[msg.sender][_token][_strategyList[i]]);
                _tokenReceived = _tokenReceived.add(_amount);
                delete balanceInShares[msg.sender][_token][_strategyList[i]];
            }
        }

        if (_tokenReceived == 0) return 0;

        _transfer(_tokenReceived, _token, payable(msg.sender));

        emit WithdrawnAll(msg.sender, _tokenReceived, _token);
    }

    function withdrawAll(address _token, address _strategy) external override nonReentrant returns (uint256 _tokenReceived) {
        uint256 _sharesBalance = balanceInShares[msg.sender][_token][_strategy];

        if(_sharesBalance == 0) return 0;

        uint256 _amount = IYield(_strategy).unlockTokens(_token, _sharesBalance);

        delete balanceInShares[msg.sender][_token][_strategy];

        _transfer(_amount, _token, payable(msg.sender));

        emit Withdrawn(msg.sender, msg.sender, _amount, _token, _strategy, false);
    }

    /**
     * @notice used to approve allowance to an address
     * @dev this is prone to race condition, hence increaseAllowance is recommended
     * @param _amount amount of tokens approved
     * @param _token address of token approved
     * @param _to address of the user approved to
     */
    function approve(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        allowance[msg.sender][_token][_to] = _amount;

        emit Approved(_token, msg.sender, _to, _amount);
    }

    /**
     * @notice used to increase allowance to an address
     * @param _amount amount of tokens allowance is increased by
     * @param _token address of token approved
     * @param _to address of the address approved to
     */
    function increaseAllowance(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].add(_amount);
        allowance[msg.sender][_token][_to] = _updatedAllowance;

        emit Approved(_token, msg.sender, _to, _updatedAllowance);
    }

    /**
     * @notice used to decrease allowance to an address
     * @param _amount amount of tokens allowance is decreased by
     * @param _token address of token approved
     * @param _to address of the user approved to
     */
    function decreaseAllowance(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].sub(_amount);
        allowance[msg.sender][_token][_to] = _updatedAllowance;

        emit Approved(_token, msg.sender, _to, _updatedAllowance);
    }

    /**
     * @notice used by credit lines to replenish the allowance once the credit line pricinpal is repaid
     * @param _amount amount of tokens allowance is increased by
     * @param _token address of token approved
     * @param _from address of the lender of the credit line which is being replenished
     */
    function increaseAllowanceToCreditLine(
        uint256 _amount,
        address _token,
        address _from
    ) external override onlyCreditLine(msg.sender) {
        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].add(_amount);

        emit CreditLineAllowanceRefreshed(_token, _from, msg.sender, _amount);
    }

    /**
     * @notice used to transfer tokens
     * @param _amount amount of tokens transferred
     * @param _token address of token transferred
     * @param _strategy address of the strategy from which tokens are transferred
     * @param _to address of the user tokens are transferred to
     */
    function transfer(
        uint256 _amount,
        address _token,
        address _strategy,
        address _to
    ) external override returns (uint256) {
        require(_amount != 0, 'SavingsAccount::transfer zero amount');

        if (_strategy != address(0)) {
            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);
        }

        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(
            _amount,
            'SavingsAccount::transfer insufficient funds'
        );

        //update receiver's balance
        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_amount);

        emit Transfer(_token, _strategy, msg.sender, _to, _amount);

        return _amount;
    }

    /**
     * @notice used to transfer tokens from allowance by another address
     * @param _amount amount of tokens transferred
     * @param _token address of token transferred
     * @param _strategy address of the strategy from which tokens are transferred
     * @param _from address from whose allowance tokens are transferred
     * @param _to address of the user tokens are transferred to
     */
    function transferFrom(
        uint256 _amount,
        address _token,
        address _strategy,
        address _from,
        address _to
    ) external override returns (uint256) {
        require(_amount != 0, 'SavingsAccount::transferFrom zero amount');
        //update allowance
        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(
            _amount,
            'SavingsAccount::transferFrom allowance limit exceeding'
        );

        if (_strategy != address(0)) {
            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);
        }

        //reduce sender's balance
        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(
            _amount,
            'SavingsAccount::transferFrom insufficient allowance'
        );

        //update receiver's balance
        balanceInShares[_to][_token][_strategy] = (balanceInShares[_to][_token][_strategy]).add(_amount);

        emit Transfer(_token, _strategy, _from, _to, _amount);

        return _amount;
    }

    /**
     * @notice used to query total tokens of a token with a user
     * @param _user address of the user
     * @param _token address of token
     * @return _totalTokens total number of tokens of the token with the user
     */
    function getTotalTokens(address _user, address _token) external override returns (uint256 _totalTokens) {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();

        for (uint256 i = 0; i < _strategyList.length; i++) {
            uint256 _liquidityShares = balanceInShares[_user][_token][_strategyList[i]];

            if (_liquidityShares != 0) {
                uint256 _tokenInStrategy = _liquidityShares;
                if (_strategyList[i] != address(0)) {
                    _tokenInStrategy = IYield(_strategyList[i]).getTokensForShares(_liquidityShares, _token);
                }

                _totalTokens = _totalTokens.add(_tokenInStrategy);
            }
        }
    }

    receive() external payable {}
}",4178,482,"[H-07] SavingsAccount withdrawAll and switchStrategy can freeze user funds by ignoring possible strategy liquidity issues

Function `withdrawAll()` `switchStrategy()`

Full withdrawal and moving funds between strategies can lead to wrong accounting if the corresponding market has tight liquidity, which can be the case at least for AaveYield. That is, as the whole amount is required to be moved at once from Aave, both withdrawAll and switchStrategy will incorrectly account for partial withdrawal as if it was full whenever the corresponding underlying yield pool had liquidity issues.
 `withdrawAll` will delete user entry, locking the user funds in the strategy: user will get partial withdrawal and have the corresponding accounting entry removed, while the remaining actual funds will be frozen within the system.
 `switchStrategy` will subtract full number of shares for the _amount requested from the old strategy, while adding lesser partial number of shares for _tokensReceived to the new one with the same effect of freezing user's funds within the system.
  [H-08] Possibility to drain SavingsAccount contract assets

A malicious actor can manipulate `switchStrategy()` function in a way to withdraw tokens that are locked in SavingsAccount contract (the risk severity should be reviewed)

",2,,"pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/IYield.sol';


contract SavingsAccount is ISavingsAccount, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    
    address public strategyRegistry;

    
    address public creditLine;

    
    mapping(address => mapping(address => mapping(address => uint256))) public override balanceInShares;

    
    mapping(address => mapping(address => mapping(address => uint256))) public allowance;

    
    modifier onlyCreditLine(address _caller) {
        require(_caller == creditLine, 'Invalid caller');
        _;
    }

    
    function initialize(
        address _owner,
        address _strategyRegistry,
        address _creditLine
    ) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateCreditLine(_creditLine);
        _updateStrategyRegistry(_strategyRegistry);
    }

    
    function updateCreditLine(address _creditLine) external onlyOwner {
        _updateCreditLine(_creditLine);
    }

    function _updateCreditLine(address _creditLine) internal {
        require(_creditLine != address(0), 'SavingsAccount::initialize zero address');
        creditLine = _creditLine;
        emit CreditLineUpdated(_creditLine);
    }

    
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'SavingsAccount::updateStrategyRegistry zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    
    function deposit(
        uint256 _amount,
        address _token,
        address _strategy,
        address _to
    ) external payable override nonReentrant returns (uint256) {
        require(_to != address(0), 'SavingsAccount::deposit receiver address should not be zero address');
        uint256 _sharesReceived = _deposit(_amount, _token, _strategy);
        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_sharesReceived);
        emit Deposited(_to, _sharesReceived, _token, _strategy);
        return _sharesReceived;
    }

    function _deposit(
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        require(_amount != 0, 'SavingsAccount::_deposit Amount must be greater than zero');
        _sharesReceived = _depositToYield(_amount, _token, _strategy);
    }

    function _depositToYield(
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        require(IStrategyRegistry(strategyRegistry).registry(_strategy), 'SavingsAccount::deposit strategy do not exist');
        uint256 _ethValue;

        if (_token == address(0)) {
            _ethValue = _amount;
            require(msg.value == _amount, 'SavingsAccount::deposit ETH sent must be equal to amount');
        }
        _sharesReceived = IYield(_strategy).lockTokens{value: _ethValue}(msg.sender, _token, _amount);
    }

    
    function switchStrategy(
        uint256 _amount,
        address _token,
        address _currentStrategy,
        address _newStrategy
    ) external override nonReentrant {
        require(_currentStrategy != _newStrategy, 'SavingsAccount::switchStrategy Same strategy');
        require(IStrategyRegistry(strategyRegistry).registry(_newStrategy), 'SavingsAccount::_newStrategy do not exist');
        require(_amount != 0, 'SavingsAccount::switchStrategy Amount must be greater than zero');

        _amount = IYield(_currentStrategy).getSharesForTokens(_amount, _token);

        balanceInShares[msg.sender][_token][_currentStrategy] = balanceInShares[msg.sender][_token][_currentStrategy].sub(
            _amount,
            'SavingsAccount::switchStrategy Insufficient balance'
        );

        uint256 _tokensReceived = IYield(_currentStrategy).unlockTokens(_token, _amount);

        uint256 _ethValue;
        if (_token != address(0)) {
            IERC20(_token).safeApprove(_newStrategy, _tokensReceived);
        } else {
            _ethValue = _tokensReceived;
        }
        _amount = _tokensReceived;
        
        uint256 _sharesReceived = IYield(_newStrategy).lockTokens{value: _ethValue}(address(this), _token, _tokensReceived);

        balanceInShares[msg.sender][_token][_newStrategy] = balanceInShares[msg.sender][_token][_newStrategy].add(_sharesReceived);
        emit StrategySwitched(msg.sender, _token, _amount, _sharesReceived, _currentStrategy, _newStrategy);
    }

    
    function withdraw(
        uint256 _amount,
        address _token,
        address _strategy,
        address payable _to,
        bool _withdrawShares
    ) external override nonReentrant returns (uint256) {
        require(_amount != 0, 'SavingsAccount::withdraw Amount must be greater than zero');

        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);

        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(
            _amount,
            'SavingsAccount::withdraw Insufficient amount'
        );

        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);

        emit Withdrawn(msg.sender, _to, _amount, _token, _strategy, _withdrawShares);
        return _amountReceived;
    }

    

    function withdrawFrom(
        uint256 _amount,
        address _token,
        address _strategy,
        address _from,
        address payable _to,
        bool _withdrawShares
    ) external override nonReentrant returns (uint256) {
        require(_amount != 0, 'SavingsAccount::withdrawFrom Amount must be greater than zero');

        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(
            _amount,
            'SavingsAccount::withdrawFrom allowance limit exceeding'
        );

        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);

        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(
            _amount,
            'SavingsAccount::withdrawFrom insufficient balance'
        );
        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);
        emit Withdrawn(_from, msg.sender, _amount, _token, _strategy, _withdrawShares);
        return _amountReceived;
    }

    function _withdraw(
        uint256 _amount,
        address _token,
        address _strategy,
        address payable _to,
        bool _withdrawShares
    ) internal returns (address _tokenReceived, uint256 _amountReceived) {
        if (_withdrawShares) {
            _tokenReceived = IYield(_strategy).liquidityToken(_token);
            require(_tokenReceived != address(0), 'Liquidity Tokens address cannot be address(0)');
            _amountReceived = IYield(_strategy).unlockShares(_tokenReceived, _amount);
        } else {
            _tokenReceived = _token;
            _amountReceived = IYield(_strategy).unlockTokens(_token, _amount);
        }
        _transfer(_amountReceived, _tokenReceived, _to);
    }

    function _transfer(
        uint256 _amount,
        address _token,
        address payable _to
    ) internal {
        if (_token == address(0)) {
            (bool _success, ) = _to.call{value: _amount}('');
            require(_success, 'Transfer failed');
        } else {
            IERC20(_token).safeTransfer(_to, _amount);
        }
    }

    
    function withdrawAll(address _token) external override nonReentrant returns (uint256 _tokenReceived) {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();

        for (uint256 i = 0; i < _strategyList.length; i++) {
            if (balanceInShares[msg.sender][_token][_strategyList[i]] != 0 && _strategyList[i] != address(0)) {
                uint256 _amount = balanceInShares[msg.sender][_token][_strategyList[i]];
                _amount = IYield(_strategyList[i]).unlockTokens(_token, balanceInShares[msg.sender][_token][_strategyList[i]]);
                _tokenReceived = _tokenReceived.add(_amount);
                delete balanceInShares[msg.sender][_token][_strategyList[i]];
            }
        }

        if (_tokenReceived == 0) return 0;

        _transfer(_tokenReceived, _token, payable(msg.sender));

        emit WithdrawnAll(msg.sender, _tokenReceived, _token);
    }

    function withdrawAll(address _token, address _strategy) external override nonReentrant returns (uint256 _tokenReceived) {
        uint256 _sharesBalance = balanceInShares[msg.sender][_token][_strategy];

        if(_sharesBalance == 0) return 0;

        uint256 _amount = IYield(_strategy).unlockTokens(_token, _sharesBalance);

        delete balanceInShares[msg.sender][_token][_strategy];

        _transfer(_amount, _token, payable(msg.sender));

        emit Withdrawn(msg.sender, msg.sender, _amount, _token, _strategy, false);
    }

    
    function approve(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        allowance[msg.sender][_token][_to] = _amount;

        emit Approved(_token, msg.sender, _to, _amount);
    }

    
    function increaseAllowance(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].add(_amount);
        allowance[msg.sender][_token][_to] = _updatedAllowance;

        emit Approved(_token, msg.sender, _to, _updatedAllowance);
    }

    
    function decreaseAllowance(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].sub(_amount);
        allowance[msg.sender][_token][_to] = _updatedAllowance;

        emit Approved(_token, msg.sender, _to, _updatedAllowance);
    }

    
    function increaseAllowanceToCreditLine(
        uint256 _amount,
        address _token,
        address _from
    ) external override onlyCreditLine(msg.sender) {
        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].add(_amount);

        emit CreditLineAllowanceRefreshed(_token, _from, msg.sender, _amount);
    }

    
    function transfer(
        uint256 _amount,
        address _token,
        address _strategy,
        address _to
    ) external override returns (uint256) {
        require(_amount != 0, 'SavingsAccount::transfer zero amount');

        if (_strategy != address(0)) {
            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);
        }

        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(
            _amount,
            'SavingsAccount::transfer insufficient funds'
        );

        
        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_amount);

        emit Transfer(_token, _strategy, msg.sender, _to, _amount);

        return _amount;
    }

    
    function transferFrom(
        uint256 _amount,
        address _token,
        address _strategy,
        address _from,
        address _to
    ) external override returns (uint256) {
        require(_amount != 0, 'SavingsAccount::transferFrom zero amount');
        
        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(
            _amount,
            'SavingsAccount::transferFrom allowance limit exceeding'
        );

        if (_strategy != address(0)) {
            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);
        }

        
        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(
            _amount,
            'SavingsAccount::transferFrom insufficient allowance'
        );

        
        balanceInShares[_to][_token][_strategy] = (balanceInShares[_to][_token][_strategy]).add(_amount);

        emit Transfer(_token, _strategy, _from, _to, _amount);

        return _amount;
    }

    
    function getTotalTokens(address _user, address _token) external override returns (uint256 _totalTokens) {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();

        for (uint256 i = 0; i < _strategyList.length; i++) {
            uint256 _liquidityShares = balanceInShares[_user][_token][_strategyList[i]];

            if (_liquidityShares != 0) {
                uint256 _tokenInStrategy = _liquidityShares;
                if (_strategyList[i] != address(0)) {
                    _tokenInStrategy = IYield(_strategyList[i]).getTokensForShares(_liquidityShares, _token);
                }

                _totalTokens = _totalTokens.add(_tokenInStrategy);
            }
        }
    }

    receive() external payable {}
}",3020,2,0,"{
  ""task_list"": [
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Verify that the `nonReentrant` modifier is correctly applied to all external functions that modify state variables, especially those interacting with external contracts (Yield contracts)."",
        ""Analyze the control flow in `deposit`, `switchStrategy`, `withdraw`, `withdrawFrom`, `withdrawAll` functions and related internal functions to ensure reentrancy is not possible through any call path to external contracts."",
        ""Specifically, analyze if a malicious Yield contract could call back into the SavingsAccount during `lockTokens` or `unlockTokens` calls, potentially manipulating balances or allowances."",
        ""Check for reentrancy vulnerabilities when transferring ETH, especially in the `_transfer` function.  Consider the possibility of the recipient contract triggering a callback."",
        ""Review the interactions with the StrategyRegistry to ensure that a malicious StrategyRegistry cannot trigger a reentrancy attack.""
      ]
    },
    {
      ""Area"": ""Rounding Errors and Precision Loss"",
      ""Tasks"": [
        ""Examine the `getSharesForTokens` and `getTokensForShares` functions in the Yield contracts (external calls) for potential rounding errors. Determine how these errors might impact user balances and overall system integrity."",
        ""Simulate scenarios with various token amounts and share prices to assess the magnitude of potential rounding errors and their cumulative effects."",
        ""Analyze how the SavingsAccount contract handles discrepancies between expected and actual token/share amounts due to rounding."",
        ""Investigate if rounding errors can be exploited to steal tokens or shares from other users."",
        ""Verify how the yield strategies calculate shares to tokens, especially regarding precision.""
      ]
    },
    {
      ""Area"": ""Approval Handling and Potential Stuck Funds"",
      ""Tasks"": [
        ""In `switchStrategy`, investigate the scenario where the `safeApprove` call to the `_newStrategy` fails. Determine if the user's funds are stuck and if there is a mechanism to recover them. Suggest a solution (e.g., refunding the user or retrying the approval)."",
        ""Verify that there's no possibility to get stuck funds in the contract due to failed `safeTransfer` calls, due to a wrong implementation of the `transfer` function in ERC20 tokens."",
        ""Analyze the potential for front-running attacks on the `safeApprove` call in `switchStrategy` and implement mitigations if necessary."",
        ""Consider implementing a function to allow the owner to rescue stuck tokens in case of failed approvals or other unforeseen circumstances.""
      ]
    },
    {
      ""Area"": ""WithdrawAll Function Analysis"",
      ""Tasks"": [
        ""In `withdrawAll(address _token)`, confirm that the function correctly iterates through all strategies and withdraws the appropriate amounts. Pay special attention to error handling during the withdrawal process for each strategy."",
        ""Address the question: Why does `withdrawAll(address _token)` only return the token address and not the actual amount withdrawn?  The return should be the `_tokenReceived` which is an amount.  However, the code iterates through multiple strategies. It accumulates `_amount` but does not reset it.  Thus, the return `_tokenReceived` might not be accurate"",
        ""Verify that withdrawing from one strategy does not affect the withdrawal process from other strategies in the loop."",
        ""Assess gas costs of the `withdrawAll` function. The need to iterate through `_strategyList` might create issues with high number of strategies."",
        ""Analyze the case where there are not tokens available in the SavingsAccount for a `withdrawAll` operation. Make sure it's correctly handled and no funds are locked.""
      ]
    },
    {
      ""Area"": ""Access Control and Authorization"",
      ""Tasks"": [
        ""Verify that the `onlyOwner` modifier is correctly applied to all sensitive functions, such as `updateCreditLine` and `updateStrategyRegistry`."",
        ""Ensure the `onlyCreditLine` modifier correctly restricts access to the `increaseAllowanceToCreditLine` function."",
        ""Analyze the logic for `withdrawFrom` and `transferFrom` to ensure that allowances are correctly checked and decremented. Prevent potential overspending."",
        ""Examine the potential for privilege escalation vulnerabilities. Ensure that no user or contract can gain unauthorized access to sensitive functions or data."",
        ""Review the `initialize` function and verify that the contract is initialized correctly and that the ownership is properly set. Ensure it can only be called once.""
      ]
    },
    {
      ""Area"": ""Token Transfer and Value Handling"",
      ""Tasks"": [
        ""Review the `_transfer` function to ensure that ETH transfers are handled correctly, especially regarding potential failures.  Consider using the 'pull-over-push' pattern for enhanced security."",
        ""Analyze the impact of deflationary or fee-on-transfer tokens on the contract's logic. How do these tokens affect share calculations and withdrawal amounts?"",
        ""Assess the potential for front-running attacks in the `transfer` and `transferFrom` functions, where malicious actors could manipulate the value of shares before a transfer occurs. Add mitigations if needed."",
        ""Verify that the contract correctly handles tokens with different decimals."",
        ""Consider what would happen if an attempt to transfer a token to address(0) is made.""
      ]
    },
    {
      ""Area"": ""Strategy Registry Interactions"",
      ""Tasks"": [
        ""Assess the security implications of trusting the `StrategyRegistry` contract. A malicious or compromised `StrategyRegistry` could potentially allow unauthorized strategies to be used, leading to fund losses."",
        ""Verify that the `IStrategyRegistry(strategyRegistry).registry(_strategy)` call in `_depositToYield` correctly validates the strategy address."",
        ""Ensure that the `StrategyRegistry` contract prevents duplicate or malicious strategy addresses from being registered."",
        ""Analyze the impact of adding or removing strategies on existing user balances and pending withdrawals."",
        ""Check the `getStrategies` function and the way it returns strategies, to avoid edge cases where the loop could be affected, and funds lost.""
      ]
    },
    {
      ""Area"": ""Event Emission and Logging"",
      ""Tasks"": [
        ""Review all event emissions to ensure they provide sufficient information for debugging and auditing purposes. Consider adding more relevant parameters to events, such as amounts, addresses, and strategy details."",
        ""Ensure that all state-changing operations are accompanied by appropriate event emissions."",
        ""Verify the correct arguments are used when an event is emitted."",
        ""Check if events conform with standards from EIP to ease off-chain processing and integration with other tools.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code represents a SavingsAccount contract that allows users to deposit, withdraw, and switch between different yield strategies. It interacts with a StrategyRegistry contract to manage available strategies and Yield contracts for each strategy to manage deposits and withdrawals. The contract uses shares to track user balances within each strategy. It also includes functionality for transferring balances and managing allowances for other contracts to withdraw on behalf of users."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""SavingsAccount"",
    ""Purpose"": ""Allows users to deposit funds into different yield strategies, withdraw funds, and switch between strategies. Acts as an interface between users and various yield-generating strategies."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""ISavingsAccount"",
        ""Initializable"",
        ""OwnableUpgradeable"",
        ""ReentrancyGuard""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"",
        ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"",
        ""@openzeppelin/contracts/math/SafeMath.sol"",
        ""../interfaces/ISavingsAccount.sol"",
        ""../interfaces/IStrategyRegistry.sol"",
        ""../interfaces/IYield.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""strategyRegistry"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the StrategyRegistry contract.""
      },
      {
        ""Name"": ""creditLine"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the CreditLine contract.""
      },
      {
        ""Name"": ""balanceInShares"",
        ""Type"": ""mapping(address => mapping(address => mapping(address => uint256)))"",
        ""Purpose"": ""Maps user address to token address to strategy address to balance in shares.""
      },
      {
        ""Name"": ""allowance"",
        ""Type"": ""mapping(address => mapping(address => mapping(address => uint256)))"",
        ""Purpose"": ""Maps owner address to token address to spender address to allowance amount. Used for `withdrawFrom` and `transferFrom` functions.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyCreditLine"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts access to a function to only the CreditLine contract."",
        ""Parameters"": [""address _caller""],
        ""Returns"": []
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract, setting the owner, strategy registry, and credit line."",
        ""Parameters"": [""address _owner"", ""address _strategyRegistry"", ""address _creditLine""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateCreditLine"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the address of the creditLine contract. Only callable by the owner."",
        ""Parameters"": [""address _creditLine""],
        ""Returns"": []
      },
      {
        ""Name"": ""_updateCreditLine"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to update the creditLine address."",
        ""Parameters"": [""address _creditLine""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateStrategyRegistry"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the address of the strategyRegistry contract. Only callable by the owner."",
        ""Parameters"": [""address _strategyRegistry""],
        ""Returns"": []
      },
      {
        ""Name"": ""_updateStrategyRegistry"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to update the strategyRegistry address."",
        ""Parameters"": [""address _strategyRegistry""],
        ""Returns"": []
      },
      {
        ""Name"": ""deposit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Deposits tokens into a specified yield strategy. Payable if the token is ETH."",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _strategy"", ""address _to""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_deposit"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to deposit tokens into a specified yield strategy."",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _strategy""],
        ""Returns"": [""uint256 _sharesReceived""]
      },
      {
        ""Name"": ""_depositToYield"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Deposits the tokens into the yield strategy by calling `lockTokens` function of the strategy contract."",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _strategy""],
        ""Returns"": [""uint256 _sharesReceived""]
      },
      {
        ""Name"": ""switchStrategy"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Switches tokens from one strategy to another."",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _currentStrategy"", ""address _newStrategy""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws tokens from a specified yield strategy."",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _strategy"", ""address payable _to"", ""bool _withdrawShares""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""withdrawFrom"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws tokens from a specified yield strategy on behalf of another user, given sufficient allowance."",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _strategy"", ""address _from"", ""address payable _to"", ""bool _withdrawShares""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_withdraw"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to withdraw tokens from a yield strategy."",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _strategy"", ""address payable _to"", ""bool _withdrawShares""],
        ""Returns"": [""address _tokenReceived"", ""uint256 _amountReceived""]
      },
      {
        ""Name"": ""_transfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to transfer tokens to a specified address. Handles ETH transfers."",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address payable _to""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawAll"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws all tokens of a specified type from all strategies for the caller."",
        ""Parameters"": [""address _token""],
        ""Returns"": [""uint256 _tokenReceived""]
      },
      {
        ""Name"": ""withdrawAll"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws all tokens of a specified type from specified strategy for the caller."",
        ""Parameters"": [""address _token"", ""address _strategy""],
        ""Returns"": [""uint256 _tokenReceived""]
      },
      {
        ""Name"": ""approve"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Approves an address to spend tokens on behalf of the caller."",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _to""],
        ""Returns"": []
      },
      {
        ""Name"": ""increaseAllowance"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Increases the allowance for a spender."",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _to""],
        ""Returns"": []
      },
      {
        ""Name"": ""decreaseAllowance"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Decreases the allowance for a spender."",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _to""],
        ""Returns"": []
      },
      {
        ""Name"": ""increaseAllowanceToCreditLine"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the CreditLine contract to increase allowance on behalf of another user."",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _from""],
        ""Returns"": []
      },
      {
        ""Name"": ""transfer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers shares from the caller to another user."",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _strategy"", ""address _to""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""transferFrom"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers shares from one user to another user, given sufficient allowance."",
        ""Parameters"": [""uint256 _amount"", ""address _token"", ""address _strategy"", ""address _from"", ""address _to""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getTotalTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Calculates the total amount of tokens a user has across all strategies for a specific token."",
        ""Parameters"": [""address _user"", ""address _token""],
        ""Returns"": [""uint256 _totalTokens""]
      },
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the contract to receive ETH."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IStrategyRegistry(strategyRegistry).registry(_strategy)"",
    ""IYield(_strategy).lockTokens{value: _ethValue}(msg.sender, _token, _amount)"",
    ""IYield(_currentStrategy).getSharesForTokens(_amount, _token)"",
    ""IYield(_currentStrategy).unlockTokens(_token, _amount)"",
    ""IERC20(_token).safeApprove(_newStrategy, _tokensReceived)"",
    ""IYield(_newStrategy).lockTokens{value: _ethValue}(address(this), _token, _tokensReceived)"",
    ""IYield(_strategy).getSharesForTokens(_amount, _token)"",
    ""IYield(_strategy).unlockTokens(_token, _amount)"",
    ""IERC20(_token).safeTransfer(_to, _amount)"",
    ""IStrategyRegistry(strategyRegistry).getStrategies()"",
    ""IYield(_strategyList[i]).unlockTokens(_token, balanceInShares[msg.sender][_token][_strategyList[i]])"",
    ""IYield(_strategy).liquidityToken(_token)"",
    ""IYield(_strategy).unlockShares(_tokenReceived, _amount)"",
    ""IYield(_strategy).getTokensForShares(_liquidityShares, _token)""

  ],
  ""SpecialMechanisms"": [
    ""Uses shares to represent user balances within each strategy."",
    ""Implements a reentrancy guard to prevent reentrancy attacks."",
    ""Uses OpenZeppelin's SafeERC20 library for safe ERC20 token interactions."",
    ""Uses OpenZeppelin's OwnableUpgradeable contract for ownership management and contract upgrades."",
    ""Uses Initializable to prevent multiple initializations after deployment.""
  ],
  ""Questions"": [
    ""In `switchStrategy`, why is the contract approving `_newStrategy` for `_tokensReceived` from `_currentStrategy` instead of `_amount`?"",
    ""Are there any potential rounding errors when converting between tokens and shares using `getSharesForTokens` and `getTokensForShares` in the Yield contracts? How are these errors handled?"",
    ""Is there a mechanism to handle failed token approvals in `switchStrategy`?  If the approval fails, the funds will be stuck in the SavingsAccount contract and user's shares have already been debited from their balances on `_currentStrategy`."",
    ""In `withdrawAll(address _token)`, why the token address is only returned but not the actual amount withdrawn?"",
    ""What is the purpose of tracking both shares and tokens? Does this introduce complexity that could be avoided by only tracking shares, and making calculations on the fly?"",
    ""Consider using a pull-over-push pattern for token transfers to mitigate potential issues with malicious tokens. Is there a risk that the `transfer` and `transferFrom` functions could be frontrun to manipulate the value of shares?"",
    ""The events emitted do not include all the function arguments which makes debugging harder. Consider adding more arguments for better debugging and transparency.""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Risk in `withdrawAll` function"",
      ""Severity"": ""High"",
      ""Description"": ""The `withdrawAll` function iterates through a list of strategies and calls `IYield(_strategyList[i]).unlockTokens` within a loop, which can potentially call back into the SavingsAccount contract, leading to a reentrancy vulnerability. A malicious Yield contract could manipulate the `balanceInShares` mapping or execute unintended state changes before the loop completes, potentially draining funds. The `nonReentrant` modifier only protects against reentrancy directly back into the `withdrawAll` function itself, not from reentrancy from within the `unlockTokens` calls."",
      ""Impact"": ""Users could potentially withdraw more tokens than they own, leading to a loss of funds for the contract or other users. Possible theft of funds due to manipulation of balances via reentrancy."",
      ""Location"": ""SavingsAccount.sol:240, SavingsAccount.sol: withdrawAll, SavingsAccount.sol: Lines 258-274, SavingsAccount.sol:250-263""
    },
    {
      ""Issue"": ""Lack of access control on `increaseAllowanceToCreditLine` function"",
      ""Severity"": ""High"",
      ""Description"": ""The `increaseAllowanceToCreditLine` function allows the credit line to increase the allowance of any user. Although there is `onlyCreditLine` modifier, a compromised `creditLine` address could arbitrarily increase allowances, enabling it to withdraw funds from user accounts without their explicit approval. This is a severe security risk."",
      ""Impact"": ""Unauthorized withdrawal of funds from user accounts by a compromised credit line."",
      ""Location"": ""SavingsAccount.sol: Lines 326-330""
    },
    {
      ""Issue"": ""Missing Input Validation for _strategy Address in Multiple Functions and Potential Vulnerability with `_depositToYield`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract frequently interacts with external `IYield` contracts via the `_strategy` address, with insufficient validation to ensure it's not malicious or an EOA. Functions like `deposit`, `switchStrategy`, `withdraw`, `withdrawFrom`, `transfer`, and `transferFrom` are affected. A malicious strategy could execute arbitrary code within the SavingsAccount's context. Also the `_strategy` should be validated against `strategyRegistry` before any operations on `balanceInShares`. Further, in `_depositToYield`, if `_token` is the zero address, the code uses `msg.sender` in the call to `lockTokens`, potentially leading to unexpected behaviour in the Yield contract."",
      ""Impact"": ""Potential for malicious strategies to be used, leading to loss of funds or unexpected contract behavior. An attacker could register a malicious strategy, and users interacting with that strategy through this contract would be vulnerable. The strategy could behave unexpectedly or allow unintended access when ETH is deposited, possibly leading to loss of funds. Potential accounting issues with invalid strategies."",
      ""Location"": ""Functions `deposit`, `switchStrategy`, `withdraw`, `withdrawFrom`, `transfer`, `transferFrom`. Specifically, lines where `IYield(_strategy)` is called. SavingsAccount.sol:111""
    },
    {
      ""Issue"": ""Potential Reentrancy in `_transfer` Function when transferring ETH and Unsafe `transfer` in `_transfer` function and Missing input validation in `_transfer` function can lead to unexpected behavior with ETH transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_transfer` function uses a low-level `call` to transfer ETH. This is vulnerable to reentrancy attacks if the recipient is a contract that has a fallback function that calls back into the SavingsAccount contract. There is also no check for `address(0)` and if the transfer is close to balance, it may fail."",
      ""Impact"": ""An attacker could potentially drain funds from the SavingsAccount by exploiting the reentrancy vulnerability. Potential denial of service if ETH transfers to certain addresses always revert."",
      ""Location"": ""Function `_transfer`. SavingsAccount.sol:_transfer""
    },
    {
      ""Issue"": ""Lack of Slippage Control and Missing input validation in `switchStrategy` function can lead to DoS and unexpected behavior."",
      ""Severity"": ""Medium"",
      ""Description"": ""The `switchStrategy` function involves converting shares from one strategy to tokens and then locking those tokens into a new strategy. The conversion between shares and tokens can be subject to slippage and integer overflow. If the rate fluctuates unfavorably between the `unlockTokens` and `lockTokens` calls, the user might receive fewer shares in the new strategy than expected."",
      ""Impact"": ""Users may experience losses due to slippage when switching strategies. Users may experience unexpected token losses or receive significantly fewer shares in the new strategy than anticipated. A malicious strategy could manipulate the share price to exploit this, causing a denial of service or loss of funds for users switching to that strategy."",
      ""Location"": ""Function `switchStrategy`. SavingsAccount.sol:104-120""
    },
    {
      ""Issue"": ""Possible rounding errors in `switchStrategy` and `withdraw` functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""In `switchStrategy` and `withdraw` functions, `IYield(_currentStrategy).getSharesForTokens` is used to convert the token amount to shares, and subsequently `IYield(_currentStrategy).unlockTokens` is called. This conversion could be subject to rounding errors, potentially leading to small discrepancies in the amount of tokens or shares a user receives or loses."",
      ""Impact"": ""Minor rounding errors could accumulate over time, leading to a discrepancy between the user\'s expected and actual balance. It could also be exploited by malicious actors to gain a small advantage."",
      ""Location"": ""SavingsAccount.sol:133, SavingsAccount.sol:181, SavingsAccount.sol: Lines 148, 180""
    },
    {
      ""Issue"": ""Potential vulnerability with `_depositToYield` when `_token` is address(0) and Incorrect handling of ETH deposits in `deposit` function."",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_depositToYield` function, when `_token` is the zero address, the code checks if `msg.value == _amount`. While this seems correct, the `IYield(_strategy).lockTokens{value: _ethValue}(msg.sender, _token, _amount)` call still uses `msg.sender` as the sender, which can lead to incorrect ETH handling and loss of funds."",
      ""Impact"": ""The strategy could behave unexpectedly or allow unintended access when ETH is deposited, possibly leading to loss of funds. Potential for incorrect ETH handling within yield strategies, leading to loss of funds or unexpected behavior."",
      ""Location"": ""SavingsAccount.sol:111, SavingsAccount.sol:104-107""
    },
    {
      ""Issue"": ""Unused return value in `_depositToYield` function for `ETH` deposits can lead to incorrect accounting of `msg.value` in the case of failure"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_depositToYield` function, when depositing `ETH` (`_token == address(0)`), the code sets `_ethValue = _amount` and makes a payable call to `IYield(_strategy).lockTokens{value: _ethValue}(msg.sender, _token, _amount)`. However, it does not handle the case where the `lockTokens` function reverts or fails after receiving `msg.value`."",
      ""Impact"": ""Loss of funds for users depositing ETH if the `lockTokens` function in the target Yield contract fails or reverts after receiving the ETH."",
      ""Location"": ""SavingsAccount.sol: Lines 102-107""
    },
    {
      ""Issue"": ""Missing Input Validation in `transfer` and `transferFrom` for Strategy Address and Missing input validation in `transfer` and `transferFrom` functions could lead to unexpected behavior"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `transfer` and `transferFrom` functions allow transferring shares between users for a specific strategy. However, they don't check if the provided `_strategy` address is a valid or registered strategy within the `strategyRegistry`, or if `_strategy` is `address(0)`.  If a zero address or an unregistered strategy is used, the balance updates will occur without interaction with a valid Yield contract, leading to accounting inconsistencies."",
      ""Impact"": ""Users can manipulate their `balanceInShares` mapping without the corresponding tokens being locked or unlocked in a valid yield strategy. This can lead to incorrect accounting and potential exploitation if users are able to withdraw more tokens than they have deposited in reality. Inconsistent behavior in token transfer, potentially leading to loss of funds or unexpected account balances. Users might not get the shares they expect if they call the functions with a zero address as the `_strategy`."",
      ""Location"": ""SavingsAccount.sol: transfer, transferFrom, SavingsAccount.sol: Lines 349-351 and 378-380""
    },
    {
      ""Issue"": ""Potential Reentrancy in `withdrawAll` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `withdrawAll` function iterates through a list of strategies and withdraws tokens from each. The `IYield(_strategyList[i]).unlockTokens` function call can potentially trigger a reentrancy attack if the Yield contract is malicious or has vulnerabilities. Calling `unlockTokens` is an external call that can lead to reentrancy vulnerabilities and gas exhaustion if a malicious strategy manipulates the state or requires excessive gas. Also only one tokenReceived is returned, leading to potential problems if different strategies returns different tokens."",
      ""Impact"": ""A malicious Yield contract can re-enter the `withdrawAll` function during the token withdrawal process. This can cause incorrect accounting, denial of service, or theft of funds. Reentrancy attacks could allow a malicious strategy to drain funds from the SavingsAccount. Gas exhaustion can cause the transaction to fail, preventing users from withdrawing their funds."",
      ""Location"": ""SavingsAccount.sol: withdrawAll (first implementation), SavingsAccount.sol:155-161""
    },
    {
      ""Issue"": ""`withdrawAll` function doesn't handle ERC777 tokens safely."",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_transfer` function performs a simple `safeTransfer` for ERC20 tokens. It doesn't account for ERC777 tokens, which could call back into the contract during the transfer. This could be exploited, especially in the context of the `withdrawAll` function, to potentially cause reentrancy issues or unexpected behavior during the withdrawal process."",
      ""Impact"": ""Potential reentrancy issues if the withdrawn token is an ERC777 token. The callback could manipulate the contract state during the transfer, leading to unexpected outcomes."",
      ""Location"": ""SavingsAccount.sol: Lines 243-277, 227-233""
    },
    {
      ""Issue"": ""Missing input validation in `withdrawAll(address _token)` can lead to denial of service and unexpected behavior"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `withdrawAll(address _token)` iterates through all strategies registered in the `strategyRegistry`. For each strategy, it attempts to withdraw tokens if the user has a balance. However, it accumulates the withdrawn amount in `_tokenReceived` *before* transferring tokens to the user. If a large number of strategies are registered, this can lead to the transaction running out of gas."",
      ""Impact"": ""Denial of Service (DoS) due to out-of-gas errors when withdrawing from many strategies. Potential integer overflow during the accumulation of `_tokenReceived`, leading to incorrect accounting and loss of funds."",
      ""Location"": ""SavingsAccount.sol:250-263""
    },
     {
      ""Issue"": ""Incorrect handling of ETH deposits in `deposit` function."",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `deposit` function, when depositing ETH (`_token == address(0)`), the contract checks if `msg.value == _amount`. If this check passes, the code proceeds to call `IYield(_strategy).lockTokens{value: _ethValue}(msg.sender, _token, _amount)`. While this appears correct, the `msg.sender` in the call to `IYield(_strategy).lockTokens` may expect ETH to be sent from *this* contract (SavingsAccount) to the strategy contract. "",
      ""Impact"": ""Potential for incorrect ETH handling within yield strategies, leading to loss of funds or unexpected behavior. Reliance on strategies handling msg.sender and msg.value correctly."",
      ""Location"": ""SavingsAccount.sol:104-107""
    },
    {
      ""Issue"": ""Withdraw functions use `getSharesForTokens` before balance check"",
      ""Severity"": ""Medium"",
      ""Description"": ""In both the `withdraw` and `withdrawFrom` functions, the `getSharesForTokens` function is called on the `IYield` contract before checking if the user has sufficient balance (in shares)."",
      ""Impact"": ""User might think they are withdrawing a specified amount, but the shares extracted are higher because `getSharesForTokens` is executed before the balance check."",
      ""Location"": ""SavingsAccount.sol:withdraw, SavingsAccount.sol:withdrawFrom""
    },
    {
      ""Issue"": ""Incorrect Emission of Withdrawn Event in `withdrawAll(address _token, address _strategy)` and Incorrect emission of event in `withdrawAll(address _token, address _strategy)` and Inconsistent event emission in `withdraw` and `withdrawFrom` functions."",
      ""Severity"": ""Low"",
      ""Description"": ""The `withdrawAll(address _token, address _strategy)` function emits the `Withdrawn` event. The description of the withdrawn event includes the `_withdrawShares` parameter, but this function always withdraws tokens so the event should reflect this. In the `withdrawAll(address _token, address _strategy)` function, the `Withdrawn` event is emitted with `msg.sender` as both the user and the receiver. The parameter for the user receiving the tokens should be consistent across all calls to the `Withdrawn` event."",
      ""Impact"": ""The event may mislead off-chain consumers of the contract state. Inconsistent event emission makes it harder to analyze contract behavior. Difficulties in tracking withdrawals on-chain due to inconsistent event emission. Can hinder accurate accounting and auditing."",
      ""Location"": ""Function `withdrawAll(address _token, address _strategy)`. SavingsAccount.sol: withdrawAll (second implementation), SavingsAccount.sol:170, 193""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Allowance Modification Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""While SafeMath is used for arithmetic operations, the `increaseAllowance` and `decreaseAllowance` functions may be vulnerable to integer overflow if `_amount` is sufficiently large or small, respectively."",
      ""Impact"": ""Transaction reverts or unexpected allowance values, potentially leading to denial of service or incorrect permissions."",
      ""Location"": ""Functions `increaseAllowance`, `decreaseAllowance`. SavingsAccount.sol: Lines 312, 319""
    },
    {
      ""Issue"": ""Missing Zero Address Check for `_to` in `approve` function and Missing zero-address check for _to address in `approve`, `increaseAllowance`, and `decreaseAllowance` functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The `approve` function doesn't check if the `_to` address is the zero address. Approving the zero address has no practical use and might indicate a user error."",
      ""Impact"": ""No direct security impact, but allows for a meaningless state change that could be confusing. While not directly exploitable, this could lead to unexpected behavior or errors if other contracts rely on the assumption that allowances are not given to the zero address."",
      ""Location"": ""Function `approve`. SavingsAccount.sol:265, SavingsAccount.sol:277, SavingsAccount.sol:289""
    },
    {
      ""Issue"": ""Missing check for `_amount` in `increaseAllowanceToCreditLine` and Lack of checks for `_from` address in `withdrawFrom`, `transferFrom` and `increaseAllowanceToCreditLine` functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The `increaseAllowanceToCreditLine` function, callable only by the `creditLine` address, increases the allowance of a user towards the credit line. It is possible that a very large _amount is provided as input, and there is no upper limit check. In the `withdrawFrom` and `transferFrom` functions, the contract relies solely on `allowance` and does not validate that `_from` is a valid address or has the necessary funds."",
      ""Impact"": ""No specific impact for a regular scenario, but a rogue CreditLine can potentially cause unexpected allowance values for users. Potential for issues related to incorrect accounting or authorization."",
      ""Location"": ""SavingsAccount.sol: increaseAllowanceToCreditLine. Functions: `withdrawFrom`, `transferFrom` and `increaseAllowanceToCreditLine`.""
    },
    {
      ""Issue"": ""Lack of return value check in `_transfer` function for native token transfers"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_transfer` function uses `_to.call{value: _amount}(\'\')` to transfer ETH. While it checks for `_success`, it doesn't inspect the returned data. If the receiving contract's fallback/receive function reverts *without* consuming all gas, the `_success` flag will still be true, but the ETH transfer will have failed."",
      ""Impact"": ""ETH transfers may fail silently, leading to unexpected behavior and loss of funds."",
      ""Location"": ""SavingsAccount.sol: _transfer""
    },
    {
      ""Issue"": ""Missing zero address check in `transfer` and `transferFrom` function for the `_to` address."",
      ""Severity"": ""Low"",
      ""Description"": ""The `transfer` and `transferFrom` functions are missing a check to ensure that the `_to` address is not the zero address. Sending tokens to the zero address effectively burns them, which may not be the intended behavior."",
      ""Impact"": ""Accidental burning of tokens due to transfers to the zero address."",
      ""Location"": ""SavingsAccount.sol:247, SavingsAccount.sol:278""
    },
    {
      ""Issue"": ""Potential rounding errors when converting between tokens and shares."",
      ""Severity"": ""Low"",
      ""Description"": ""The contract relies on external `IYield` contracts to convert between tokens and shares using `getSharesForTokens` and `getTokensForShares`. These conversions may introduce rounding errors."",
      ""Impact"": ""Minor inaccuracies in token/share conversions can lead to unfair distribution of funds."",
      ""Location"": ""SavingsAccount.sol:104, SavingsAccount.sol:296, SavingsAccount.sol:312""
    },
    {
      ""Issue"": ""Missing checks for msg.value being zero when _token != address(0) in _depositToYield"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `_depositToYield` function, when `_token != address(0)`, the code doesn't explicitly check if `msg.value` is zero."",
      ""Impact"": ""While unlikely to cause issues if IYield handles msg.value == 0 case, better clarity for the function's intent"",
      ""Location"": ""Function: `_depositToYield`""
    },
    {
      ""Issue"": ""Potential Front Running in `approve`, `increaseAllowance`, `decreaseAllowance` and Lack of protection against front-running in `deposit` function when depositing ETH."",
      ""Severity"": ""Low"",
      ""Description"": ""The `approve`, `increaseAllowance`, and `decreaseAllowance` functions set the allowance for a spender to withdraw funds. These transactions are susceptible to front-running attacks, where an attacker observes the pending transaction and submits their own transaction with a higher gas price to execute their transaction first."",
      ""Impact"": ""Risk of allowance manipulation by attackers. Potential denial of service for users attempting to deposit ETH due to transaction failures caused by front-running attacks manipulating gas prices during volatile ETH price fluctuations."",
      ""Location"": ""Functions: `approve`, `increaseAllowance`, `decreaseAllowance`. SavingsAccount.sol: Lines 102-105""
    },
    {
      ""Issue"": ""Potential integer overflow/underflow in `increaseAllowance` and `decreaseAllowance`."",
      ""Severity"": ""Low"",
      ""Description"": ""While `SafeMath` is used for subtraction and addition in `decreaseAllowance` and `increaseAllowance`, an extremely large `_amount` supplied to `decreaseAllowance` could still cause an underflow if `allowance[msg.sender][_token][_to]` is initially 0."",
      ""Impact"": ""Theoretically, if an account tries to decrease the allowance by a very large number it could cause an underflow on subtraction. In `increaseAllowance`, an allowance set close to the maximum value can become hard to manage."",
      ""Location"": ""SavingsAccount.sol: Lines 312, 319""
    }
  ],
  ""IssueNumber"": 45,
  ""OutputList"": 20
}",208.76666903495789,4160.0,32.0,"### **[H-07] SavingsAccount withdrawAll and switchStrategy can freeze user funds by ignoring possible strategy liquidity issues**

**Report Description**:  
The `withdrawAll()` and `switchStrategy()` functions in the SavingsAccount contract can freeze user funds due to liquidity issues in the underlying yield strategies (e.g., AaveYield). When the market has tight liquidity, these functions may incorrectly account for partial withdrawals as full withdrawals. Specifically:  
- `withdrawAll()` deletes the user's entry, locking their funds in the strategy if only a partial withdrawal is possible.  
- `switchStrategy()` subtracts the full number of shares from the old strategy but adds a lesser number of shares to the new strategy, effectively freezing the user's funds.  

This can lead to users losing access to their funds and incorrect accounting within the system.

**Match in Response List**:  
Matches with the issue titled **""Lack of Slippage Control and Missing input validation in `switchStrategy` function can lead to DoS and unexpected behavior.""**

**Validation**:  
**Partially Correct**. The response identifies the issue of slippage and potential unexpected behavior in the `switchStrategy` function, which aligns with the liquidity issue described in the report. However, it misses the critical detail about `withdrawAll()` freezing user funds due to liquidity issues. The response also does not explicitly mention the risk of incorrect accounting or the specific impact on users' funds being locked.  

---

### **[H-08] Possibility to drain SavingsAccount contract assets**

**Report Description**:  
A malicious actor can manipulate the `switchStrategy()` function to withdraw tokens locked in the SavingsAccount contract. This could lead to a drain of the contract's assets, and the severity of this risk should be reviewed.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the specific risk of a malicious actor draining the SavingsAccount contract assets through manipulation of the `switchStrategy()` function. This is a critical security concern that is entirely missed in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-07] SavingsAccount withdrawAll and switchStrategy can freeze user funds by ignoring possible strategy liquidity issues**

**Missed Issues from Issue Report**:  
- **[H-08] Possibility to drain SavingsAccount contract assets**

---

### **Detailed Analysis**

1. **[H-07] SavingsAccount withdrawAll and switchStrategy can freeze user funds by ignoring possible strategy liquidity issues**:  
   - The response partially addresses the issue by highlighting slippage and unexpected behavior in `switchStrategy`. However, it fails to cover the freezing of funds in `withdrawAll()` and the broader impact of liquidity issues on user funds.  
   - **Recommendation**: The response should explicitly mention the risk of funds being locked in `withdrawAll()` and the incorrect accounting that results from liquidity issues.

2. **[H-08] Possibility to drain SavingsAccount contract assets**:  
   - This issue is entirely missed in the response list. The risk of a malicious actor draining the contract's assets through `switchStrategy()` is a high-severity vulnerability that requires immediate attention.  
   - **Recommendation**: Add a response that addresses the potential for asset draining through manipulation of `switchStrategy()` and include mitigation strategies such as input validation and access control.

---

### **Conclusion**  
The response list partially addresses one of the two issues in the report but misses a critical high-severity vulnerability. To improve coverage and accuracy, the response list should be updated to include the risk of asset draining and provide more detailed explanations of the liquidity-related issues in `withdrawAll()` and `switchStrategy()`.","```
None.
```",0.0
PriceOracle.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.7.6;

import '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';
import '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';

import './interfaces/IPriceOracle.sol';

contract PriceOracle is Initializable, OwnableUpgradeable, IPriceOracle {
    using SafeMath for uint256;

    uint32 uniswapPriceAveragingPeriod;
    struct PriceData {
        address oracle;
        uint256 decimals;
    }
    /**
     * @notice stores the price oracle and its decimals for chainlink feeds
     **/
    mapping(address => PriceData) public chainlinkFeedAddresses;
    mapping(address => uint256) decimals;

    /**
     * @notice stores the addresses of price feeds for uniswap token pairs
     **/
    mapping(bytes32 => address) public uniswapPools;

    /**
     * @notice Used to initialize the price oracle contract
     * @dev can only be invoked once
     * @param _admin owner of the price oracle
     **/
    function initialize(address _admin) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_admin);
    }

    /**
     * @notice Used to get price of the num vs den token from chainlink
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of den
     * @return no of decimals for the price
     **/
    function getChainlinkLatestPrice(address num, address den) public view returns (uint256, uint256) {
        PriceData memory _feedData1 = chainlinkFeedAddresses[num];
        PriceData memory _feedData2 = chainlinkFeedAddresses[den];
        if (_feedData1.oracle == address(0) || _feedData2.oracle == address(0)) {
            return (0, 0);
        }
        int256 price1;
        int256 price2;
        {
            uint80 roundID1;
            uint256 timeStamp1;
            uint80 answeredInRound1;
            (
                roundID1,
                price1,
                ,
                timeStamp1,
                answeredInRound1
            ) = AggregatorV3Interface(_feedData1.oracle).latestRoundData();
            if(timeStamp1 == 0 || answeredInRound1 < roundID1) {
                return (0, 0);
            }
        }
        {
            uint80 roundID2;
            uint256 timeStamp2;
            uint80 answeredInRound2;
            (
                roundID2,
                price2,
                ,
                timeStamp2,
                answeredInRound2
            ) = AggregatorV3Interface(_feedData2.oracle).latestRoundData();
            if(timeStamp2 == 0 || answeredInRound2 < roundID2) {
                return (0, 0);
            }
        }
        uint256 price = uint256(price1)
            .mul(10**_feedData2.decimals)
            .mul(10**30)
            .div(uint256(price2))
            .div(10**_feedData1.decimals)
            .mul(10**decimals[den])
            .div(10**decimals[num]);
        return (price, 30);
    }

    /**
     * @notice Used to get decimals for a token
     * @param _token address of the token
     * @return number of decimals for the token
     **/
    function getDecimals(address _token) internal view returns (uint8) {
        if (_token == address(0)) {
            return 18;
        }

        try ERC20(_token).decimals() returns (uint8 v) {
            return v;
        } catch Error(string memory) {
            return 0;
        } catch (bytes memory) {
            return 0;
        }
    }

    /**
     * @notice Used to get price of the num vs den token from uniswap
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of den
     * @return no of decimals for the price
     **/
    function getUniswapLatestPrice(address num, address den) public view returns (uint256, uint256) {
        bytes32 _poolTokensId = getUniswapPoolTokenId(num, den);
        address _pool = uniswapPools[_poolTokensId];
        if (_pool == address(0)) {
            return (0, 0);
        }

        int24 _twapTick = OracleLibrary.consult(_pool, uniswapPriceAveragingPeriod);
        uint256 _numTokens = OracleLibrary.getQuoteAtTick(_twapTick, 10**30, num, den);
        return (_numTokens, 30);
    }

    function getUniswapPoolTokenId(address num, address den) internal pure returns (bytes32) {
        if (uint256(num) < uint256(den)) {
            return keccak256(abi.encodePacked(num, den));
        } else {
            return keccak256(abi.encodePacked(den, num));
        }
    }

    /**
     * @notice Used to get price of the num vs den token
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of den
     * @return no of decimals for the price
     **/
    function getLatestPrice(address num, address den) external view override returns (uint256, uint256) {
        uint256 _price;
        uint256 _decimals;
        (_price, _decimals) = getChainlinkLatestPrice(num, den);
        if (_decimals != 0) {
            return (_price, _decimals);
        }
        (_price, _decimals) = getUniswapLatestPrice(num, den);
        if (_decimals != 0) {
            return (_price, _decimals);
        }
        revert(""PriceOracle::getLatestPrice - Price Feed doesn't exist"");
    }

    /**
     * @notice used to check if price feed exists between 2 tokens
     * @param token1 one of the token for which price feed is to be checked
     * @param token2 other token for which price feed is to be checked
     * @return if price feed exists for the token pair
     **/
    function doesFeedExist(address token1, address token2) external view override returns (bool) {
        if (chainlinkFeedAddresses[token1].oracle != address(0) && chainlinkFeedAddresses[token2].oracle != address(0)) {
            return true;
        }

        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);

        if (uniswapPools[_poolTokensId] != address(0)) {
            return true;
        }

        return false;
    }

    /**
     * @notice Used to set the price feed address for a token in chainlink
     * @dev only owner can set
     * @param token address of token for which price feed is added
     * @param priceOracle addrewss of the price feed for the token
     **/
    function setChainlinkFeedAddress(address token, address priceOracle) external onlyOwner {
        uint256 priceOracleDecimals = AggregatorV3Interface(priceOracle).decimals();
        chainlinkFeedAddresses[token] = PriceData(priceOracle, priceOracleDecimals);
        decimals[token] = getDecimals(token);
        emit ChainlinkFeedUpdated(token, priceOracle);
    }

    /**
     * @notice Used to set the price feed address for a token pair in uniswap
     * @dev only owner can set
     * @param token1 address of one of the tokens for which price feed is added
     * @param token2 address of other token for which price feed is added
     * @param pool addrewss of the price feed for the token pair
     **/
    function setUniswapFeedAddress(
        address token1,
        address token2,
        address pool
    ) external onlyOwner {
        require(token1 != token2, 'token1 and token2 should be different addresses');
        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);
        uniswapPools[_poolTokensId] = pool;
        emit UniswapFeedUpdated(token1, token2, _poolTokensId, pool);
    }

    /**
     * @notice Used to set the period in which uniswap price is averaged
     * @dev only owner can set. This is used to prevent attacks to control price feed
     * @param _uniswapPriceAveragingPeriod period for uniswap price averaging
     **/
    function setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) external onlyOwner {
        uniswapPriceAveragingPeriod = _uniswapPriceAveragingPeriod;
        emit UniswapPriceAveragingPeriodUpdated(_uniswapPriceAveragingPeriod);
    }
}",2032,223,"[H-09] PriceOracle Does Not Filter Price Feed Outliers

Function `getLatestPrice()`

If for whatever reason the Chainlink oracle returns a malformed price due to oracle manipulation or a malfunctioned price, the result will be passed onto users, causing unintended consequences as a result.
In the same time it's possible to construct mitigation mechanics for such cases, so user economics be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.
",1,,"pragma solidity ^0.7.6;

import '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';
import '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';

import './interfaces/IPriceOracle.sol';

contract PriceOracle is Initializable, OwnableUpgradeable, IPriceOracle {
    using SafeMath for uint256;

    uint32 uniswapPriceAveragingPeriod;
    struct PriceData {
        address oracle;
        uint256 decimals;
    }
    
    mapping(address => PriceData) public chainlinkFeedAddresses;
    mapping(address => uint256) decimals;

    
    mapping(bytes32 => address) public uniswapPools;

    
    function initialize(address _admin) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_admin);
    }

    
    function getChainlinkLatestPrice(address num, address den) public view returns (uint256, uint256) {
        PriceData memory _feedData1 = chainlinkFeedAddresses[num];
        PriceData memory _feedData2 = chainlinkFeedAddresses[den];
        if (_feedData1.oracle == address(0) || _feedData2.oracle == address(0)) {
            return (0, 0);
        }
        int256 price1;
        int256 price2;
        {
            uint80 roundID1;
            uint256 timeStamp1;
            uint80 answeredInRound1;
            (
                roundID1,
                price1,
                ,
                timeStamp1,
                answeredInRound1
            ) = AggregatorV3Interface(_feedData1.oracle).latestRoundData();
            if(timeStamp1 == 0 || answeredInRound1 < roundID1) {
                return (0, 0);
            }
        }
        {
            uint80 roundID2;
            uint256 timeStamp2;
            uint80 answeredInRound2;
            (
                roundID2,
                price2,
                ,
                timeStamp2,
                answeredInRound2
            ) = AggregatorV3Interface(_feedData2.oracle).latestRoundData();
            if(timeStamp2 == 0 || answeredInRound2 < roundID2) {
                return (0, 0);
            }
        }
        uint256 price = uint256(price1)
            .mul(10**_feedData2.decimals)
            .mul(10**30)
            .div(uint256(price2))
            .div(10**_feedData1.decimals)
            .mul(10**decimals[den])
            .div(10**decimals[num]);
        return (price, 30);
    }

    
    function getDecimals(address _token) internal view returns (uint8) {
        if (_token == address(0)) {
            return 18;
        }

        try ERC20(_token).decimals() returns (uint8 v) {
            return v;
        } catch Error(string memory) {
            return 0;
        } catch (bytes memory) {
            return 0;
        }
    }

    
    function getUniswapLatestPrice(address num, address den) public view returns (uint256, uint256) {
        bytes32 _poolTokensId = getUniswapPoolTokenId(num, den);
        address _pool = uniswapPools[_poolTokensId];
        if (_pool == address(0)) {
            return (0, 0);
        }

        int24 _twapTick = OracleLibrary.consult(_pool, uniswapPriceAveragingPeriod);
        uint256 _numTokens = OracleLibrary.getQuoteAtTick(_twapTick, 10**30, num, den);
        return (_numTokens, 30);
    }

    function getUniswapPoolTokenId(address num, address den) internal pure returns (bytes32) {
        if (uint256(num) < uint256(den)) {
            return keccak256(abi.encodePacked(num, den));
        } else {
            return keccak256(abi.encodePacked(den, num));
        }
    }

    
    function getLatestPrice(address num, address den) external view override returns (uint256, uint256) {
        uint256 _price;
        uint256 _decimals;
        (_price, _decimals) = getChainlinkLatestPrice(num, den);
        if (_decimals != 0) {
            return (_price, _decimals);
        }
        (_price, _decimals) = getUniswapLatestPrice(num, den);
        if (_decimals != 0) {
            return (_price, _decimals);
        }
        revert(""PriceOracle::getLatestPrice - Price Feed doesn't exist"");
    }

    
    function doesFeedExist(address token1, address token2) external view override returns (bool) {
        if (chainlinkFeedAddresses[token1].oracle != address(0) && chainlinkFeedAddresses[token2].oracle != address(0)) {
            return true;
        }

        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);

        if (uniswapPools[_poolTokensId] != address(0)) {
            return true;
        }

        return false;
    }

    
    function setChainlinkFeedAddress(address token, address priceOracle) external onlyOwner {
        uint256 priceOracleDecimals = AggregatorV3Interface(priceOracle).decimals();
        chainlinkFeedAddresses[token] = PriceData(priceOracle, priceOracleDecimals);
        decimals[token] = getDecimals(token);
        emit ChainlinkFeedUpdated(token, priceOracle);
    }

    
    function setUniswapFeedAddress(
        address token1,
        address token2,
        address pool
    ) external onlyOwner {
        require(token1 != token2, 'token1 and token2 should be different addresses');
        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);
        uniswapPools[_poolTokensId] = pool;
        emit UniswapFeedUpdated(token1, token2, _poolTokensId, pool);
    }

    
    function setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) external onlyOwner {
        uniswapPriceAveragingPeriod = _uniswapPriceAveragingPeriod;
        emit UniswapPriceAveragingPeriodUpdated(_uniswapPriceAveragingPeriod);
    }
}",1404,1,0,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only the owner can call `setChainlinkFeedAddress`, `setUniswapFeedAddress`, and `setUniswapPriceAveragingPeriod` functions."",
        ""Confirm the `OwnableUpgradeable` contract is initialized correctly and the owner is set during deployment and upgrades."",
        ""Analyze the `initialize` function to confirm that the admin address is correctly set as the owner."",
        ""Check whether there are any potential vulnerabilities related to ownership transfer, such as accidental ownership transfer to a zero address.""
      ]
    },
    {
      ""Area"": ""Chainlink Price Feed Integrity"",
      ""Tasks"": [
        ""Verify that the `AggregatorV3Interface` is correctly implemented and that the reported prices are within expected ranges by cross-referencing with other sources."",
        ""Check the return values of `AggregatorV3Interface(_feedData1.oracle).latestRoundData()` and `AggregatorV3Interface(_feedData2.oracle).latestRoundData()` to ensure that `timeStamp` is not zero and that `answeredInRound < roundID` condition does not occur."",
        ""Investigate potential vulnerabilities in Chainlink's price feed mechanism that could be exploited to manipulate prices."",
        ""Analyze the logic in `getChainlinkLatestPrice` to ensure it correctly handles different decimal precisions between the numerator and denominator tokens."",
        ""Assess potential vulnerabilities of using deprecated Chainlink interfaces. Although v0.7 is used, understand upgrade paths and potential compatibilities.""
      ]
    },
    {
      ""Area"": ""Uniswap V3 TWAP Price Integrity"",
      ""Tasks"": [
        ""Ensure the `uniswapPriceAveragingPeriod` is set to a reasonable value to prevent manipulation by short-term price fluctuations."",
        ""Verify that the `OracleLibrary.consult` and `OracleLibrary.getQuoteAtTick` functions are used correctly to fetch the TWAP price from Uniswap V3 pools."",
        ""Investigate potential vulnerabilities in Uniswap V3's TWAP mechanism that could be exploited to manipulate prices."",
        ""Check the correctness of the `getUniswapPoolTokenId` function to ensure that it always returns the same ID for a given pair of tokens, regardless of their order."",
        ""Review gas costs associated with fetching Uniswap prices, as it can be significantly more expensive than Chainlink, and could create DoS vectors.""
      ]
    },
    {
      ""Area"": ""Arithmetic Overflow/Underflow"",
      ""Tasks"": [
        ""Confirm that `SafeMath` is used correctly in all arithmetic operations, especially when dealing with prices and decimal precisions."",
        ""Examine the `getChainlinkLatestPrice` function for potential overflow issues, especially in the price calculation logic where multiplications and divisions are performed."",
        ""Analyze edge cases in calculations to ensure no underflows or overflows can occur."",
        ""Specifically examine `uint256(price1).mul(10**_feedData2.decimals).mul(10**30).div(uint256(price2)).div(10**_feedData1.decimals).mul(10**decimals[den]).div(10**decimals[num]);` for potential overflows and precision loss.""
      ]
    },
    {
      ""Area"": ""Decimal Precision Handling"",
      ""Tasks"": [
        ""Verify that the `getDecimals` function correctly retrieves the decimal precision of ERC-20 tokens and handles the case where the token is the zero address."",
        ""Check that the decimal precision values from Chainlink feeds are correctly stored and used in calculations."",
        ""Investigate potential inconsistencies or errors that could arise from incorrect decimal precision handling, leading to inaccurate price calculations."",
        ""Ensure that the `decimals` mapping is properly initialized when a new Chainlink feed is set.""
      ]
    },
    {
      ""Area"": ""Fallback Mechanism"",
      ""Tasks"": [
        ""Review the logic in `getLatestPrice` to ensure the fallback mechanism from Chainlink to Uniswap is correctly implemented."",
        ""Verify that the function reverts with the correct error message if neither Chainlink nor Uniswap provides a price feed."",
        ""Assess potential attack vectors related to manipulating the availability of Chainlink feeds to force the contract to use potentially less reliable Uniswap TWAP prices.""
      ]
    },
    {
      ""Area"": ""Uniswap Pool Identification"",
      ""Tasks"": [
        ""Ensure `getUniswapPoolTokenId` function consistently generates same pool ID, irrelevant to token order."",
        ""Confirm `setUniswapFeedAddress` enforces that token1 and token2 are different to prevent invalid pool configurations."",
        ""Check if there are validations to ensure the `pool` address set in `setUniswapFeedAddress` is a valid Uniswap V3 pool contract and contains the specified tokens.""
      ]
    },
     {
      ""Area"": ""Upgradeability"",
      ""Tasks"": [
        ""Verify that the upgradeable contract follows OpenZeppelin's upgradeability patterns correctly."",
        ""Check that storage slots are properly managed across upgrades to prevent data corruption."",
        ""Ensure that the `initializer` function can only be called once.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Review the code for gas inefficiencies, especially in frequently called functions like `getLatestPrice` and `getChainlinkLatestPrice`."",
        ""Consider caching frequently accessed data to reduce gas costs."",
        ""Optimize the order of operations in arithmetic calculations to minimize gas usage.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines a PriceOracle contract that fetches prices from Chainlink and Uniswap. It prioritizes Chainlink oracles and falls back to Uniswap V3 TWAP prices if Chainlink feeds are unavailable. The contract is upgradeable and Ownable, allowing for administrative control over feed addresses and averaging periods."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""PriceOracle"",
    ""Purpose"": ""Provides a unified interface for fetching price data from Chainlink and Uniswap V3."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Initializable"", ""OwnableUpgradeable"", ""IPriceOracle""],
      ""Imports"": [
        ""@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol"",
        ""@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol"",
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts/math/SafeMath.sol"",
        ""@openzeppelin/contracts/token/ERC20/ERC20.sol"",
        ""./interfaces/IPriceOracle.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""uniswapPriceAveragingPeriod"",
        ""Type"": ""uint32"",
        ""Purpose"": ""Defines the averaging period for Uniswap TWAP prices.""
      },
      {
        ""Name"": ""chainlinkFeedAddresses"",
        ""Type"": ""mapping(address => PriceData)"",
        ""Purpose"": ""Maps token addresses to their corresponding Chainlink price feed addresses and decimal precision.""
      },
      {
        ""Name"": ""decimals"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Maps token addresses to their decimal precision, retrieved directly from the token contract.""
      },
      {
        ""Name"": ""uniswapPools"",
        ""Type"": ""mapping(bytes32 => address)"",
        ""Purpose"": ""Maps a keccak256 hash of two token addresses to the address of their Uniswap V3 pool.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract and sets the owner."",
        ""Parameters"": [""address _admin""],
        ""Returns"": []
      },
      {
        ""Name"": ""getChainlinkLatestPrice"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Fetches the latest price from Chainlink price feeds for two given tokens."",
        ""Parameters"": [""address num"", ""address den""],
        ""Returns"": [""uint256"", ""uint256""]
      },
      {
        ""Name"": ""getDecimals"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Retrieves the decimal precision of a given token."",
        ""Parameters"": [""address _token""],
        ""Returns"": [""uint8""]
      },
      {
        ""Name"": ""getUniswapLatestPrice"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Fetches the latest price from a Uniswap V3 pool for two given tokens using TWAP."",
        ""Parameters"": [""address num"", ""address den""],
        ""Returns"": [""uint256"", ""uint256""]
      },
      {
        ""Name"": ""getUniswapPoolTokenId"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Generates a unique identifier for a Uniswap V3 pool based on the token addresses."",
        ""Parameters"": [""address num"", ""address den""],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""getLatestPrice"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Provides the latest price for two tokens, prioritizing Chainlink and falling back to Uniswap."",
        ""Parameters"": [""address num"", ""address den""],
        ""Returns"": [""uint256"", ""uint256""]
      },
      {
        ""Name"": ""doesFeedExist"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Checks if a price feed exists for the given tokens, either through Chainlink or Uniswap."",
        ""Parameters"": [""address token1"", ""address token2""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""setChainlinkFeedAddress"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the Chainlink price feed address for a given token."",
        ""Parameters"": [""address token"", ""address priceOracle""],
        ""Returns"": []
      },
      {
        ""Name"": ""setUniswapFeedAddress"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the Uniswap V3 pool address for two given tokens."",
        ""Parameters"": [""address token1"", ""address token2"", ""address pool""],
        ""Returns"": []
      },
      {
        ""Name"": ""setUniswapPriceAveragingPeriod"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the averaging period for Uniswap TWAP prices."",
        ""Parameters"": [""uint32 _uniswapPriceAveragingPeriod""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""AggregatorV3Interface (Chainlink price feeds)"",
    ""OracleLibrary (Uniswap V3 TWAP)"",
    ""ERC20 (for fetching decimal precision)""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable contract using OpenZeppelin's upgradeable contracts."",
    ""Ownable contract for access control."",
    ""Prioritization of Chainlink oracles over Uniswap V3 TWAP."",
    ""Uses SafeMath for arithmetic operations to prevent overflows/underflows."",
     ""Retrieves the number of decimals for tokens directly from the ERC20 contract, and defines it as 18 if token is address(0).""
  ],
  ""Questions"": [
    ""Is there any input validation implemented to ensure `_uniswapPriceAveragingPeriod` is within a reasonable range?"",
    ""Why is `decimals` mapped to `uint256` instead of `uint8` given that `getDecimals` returns `uint8`?"",
    ""Could there be an issue if `decimals[token]` is not explicitly set, leading to a default value of 0 and incorrect price calculations until `setChainlinkFeedAddress` is called?"",
    ""In `getChainlinkLatestPrice`, the result is multiplied by 10**30. What's the purpose of multiplying by this arbitrary number, and then dividing by it, and how does it affect the decimal representation of the final price?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Missing Input Validation in `setChainlinkFeedAddress` and `setUniswapFeedAddress`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setChainlinkFeedAddress` function lacks validation to ensure that the provided `priceOracle` address implements the `AggregatorV3Interface` and that the `pool` address in `setUniswapFeedAddress` is a valid Uniswap V3 pool. Additionally, neither function checks for zero addresses, potentially leading to incorrect price data or denial of service. The decimals for token is not checked for validity."",
      ""Impact"": ""Incorrect price data, potential financial losses for users relying on the price feed, denial of service if price retrieval fails due to invalid oracle/pool addresses, and possible exploitation through malicious contracts."",
      ""Location"": ""PriceOracle.sol:setChainlinkFeedAddress, PriceOracle.sol:setUniswapFeedAddress""
    },
    {
      ""Issue"": ""Centralization Risk: Owner Control"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract inherits from `OwnableUpgradeable`, granting the owner significant control over the price feeds. The owner can arbitrarily set the Chainlink and Uniswap feed addresses, and the Uniswap price averaging period. This introduces a centralization risk, as a malicious or compromised owner could manipulate the price feeds to their advantage."",
      ""Impact"": ""A malicious owner could manipulate the price feeds, potentially leading to financial losses for users of dependent smart contracts. The integrity of the price data relies entirely on the trustworthiness of the owner. Risk of the entire price oracle being compromised if the owner\'s address is compromised."",
      ""Location"": ""PriceOracle.sol: All functions protected by `onlyOwner` modifier""
    },
    {
      ""Issue"": ""Possible Stale Price Data from Chainlink and Uniswap"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `getChainlinkLatestPrice` function lacks validation for the age of the timestamp, which may return a very old timestamp, leading to stale price data being used. A maximum acceptable age for the timestamp should be configured and validated. Additionally, the `setUniswapPriceAveragingPeriod` function does not have an upper bound, potentially resulting in manipulation of the price feed based on older data and incorrect results if set to an unreasonable period. There may be stale data in `getUniswapLatestPrice` if the pool is not actively traded."",
      ""Impact"": ""Using outdated price information, potentially leading to incorrect calculations and financial losses for dependent contracts."",
      ""Location"": ""getChainlinkLatestPrice, setUniswapPriceAveragingPeriod, getUniswapLatestPrice""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `getChainlinkLatestPrice`"",
      ""Severity"": ""Low"",
      ""Description"": ""While SafeMath is used for arithmetic operations on `uint256`, the `price1` and `price2` variables obtained from Chainlink oracles are of type `int256`. There is a conversion from `int256` to `uint256` without explicit overflow/underflow checks. If `price1` or `price2` are negative, the conversion to `uint256` will result in a very large number, leading to incorrect price calculations."",
      ""Impact"": ""Incorrect price calculations can lead to financial losses for users or incorrect execution of dependent smart contracts.  The severity is lower because Chainlink oracles are expected to return positive prices, making this scenario less likely."",
      ""Location"": ""PriceOracle.sol: getChainlinkLatestPrice""
    },
    {
      ""Issue"": ""Potential Denial of Service in `getDecimals` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `getDecimals` function attempts to retrieve the decimals of an ERC20 token. A malicious or faulty token contract could revert or run out of gas within the `decimals()` function, causing the `getDecimals` function to always return 0, potentially disrupting the price calculation logic that relies on token decimals."",
      ""Impact"": ""If a token contract's `decimals()` function always fails, the `getDecimals` function will always return 0, which can affect the price calculations in the `getChainlinkLatestPrice` function. It would also likely make the oracle revert if the user attempts to calculate a price for a token without an implemented `decimals()` function."",
      ""Location"": ""PriceOracle.sol:getDecimals""
    },
    {
      ""Issue"": ""Potential Reentrancy Risk (Mitigated but Still Present)"",
      ""Severity"": ""Low"",
      ""Description"": ""The `getLatestPrice` function calls external contracts (`AggregatorV3Interface` and Uniswap V3 pools). Although unlikely due to the specific Chainlink and Uniswap implementations, a malicious external contract could potentially re-enter the `PriceOracle` contract during these external calls."",
      ""Impact"": ""If reentrancy is exploited, a malicious contract might be able to manipulate the state of the `PriceOracle` contract during the external call, potentially leading to incorrect price data being returned."",
      ""Location"": ""PriceOracle.sol:getLatestPrice, calls to external contracts""
    },
    {
      ""Issue"": ""Potential division by zero in `getChainlinkLatestPrice`"",
      ""Severity"": ""Low"",
      ""Description"": ""In `getChainlinkLatestPrice`, if `_feedData2.decimals` or `decimals[num]` evaluates to a number that causes the divisor in the calculation of `price` to equal zero, a division by zero error will occur."",
      ""Impact"": ""The `getChainlinkLatestPrice` function will revert, potentially causing the `getLatestPrice` function to fail, interrupting the price feed and potentially disrupting reliant functionality."",
      ""Location"": ""PriceOracle.sol:60-71""
    },
    {
      ""Issue"": ""Potential rounding errors in `getChainlinkLatestPrice`"",
      ""Severity"": ""Low"",
      ""Description"": ""The calculation in `getChainlinkLatestPrice` involves multiple multiplications and divisions, which can lead to rounding errors. The order of operations could be optimized to minimize these errors."",
      ""Impact"": ""Slight inaccuracies in the calculated price, which could accumulate over time and affect financial calculations."",
      ""Location"": ""PriceOracle.sol:72-78""
    },
    {
      ""Issue"": ""Lack of slippage protection in getUniswapLatestPrice"",
      ""Severity"": ""Low"",
      ""Description"": ""The `getUniswapLatestPrice` function relies on `OracleLibrary.consult` and `OracleLibrary.getQuoteAtTick`. These functions retrieve TWAP data from the Uniswap V3 pool. While TWAP is intended to be more resistant to manipulation than spot prices, there\'s still a risk of slippage, especially if `uniswapPriceAveragingPeriod` is too short, or if a large trade occurs close to the query time. This risk is not explicitly handled."",
      ""Impact"": ""Price manipulation or inaccurate price feeds under certain conditions, such as large trades in the pool."",
      ""Location"": ""PriceOracle.sol: `getUniswapLatestPrice` function.""
    },
    {
      ""Issue"": ""Lack of reentrancy protection"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract does not implement any reentrancy protection mechanisms. Although the current functions do not appear directly vulnerable to reentrancy, future modifications or extensions to the contract could introduce vulnerabilities."",
      ""Impact"": ""Potential for malicious actors to exploit reentrancy vulnerabilities in future versions of the contract."",
      ""Location"": ""All state-modifying functions (e.g., setChainlinkFeedAddress, setUniswapFeedAddress, setUniswapPriceAveragingPeriod)""
    },
    {
      ""Issue"": ""Hardcoded Decimal Places in `getChainlinkLatestPrice` and `getUniswapLatestPrice`"",
      ""Severity"": ""Information"",
      ""Description"": ""The functions `getChainlinkLatestPrice` and `getUniswapLatestPrice` both return a `uint256` price and a `uint256` representing the number of decimals. In both, this decimal number is hardcoded to `30`. In the future, these functions should be modified to dynamically return the decimal places so the users of the oracle can accurately interpret the price returned."",
      ""Impact"": ""The user of the oracle must know a priori that the decimal places are `30`, or the user will be unable to accurately interpret the price returned by the oracle. As the contract evolves, these numbers might change, which would require the users of the oracle to change their code."",
      ""Location"": ""PriceOracle.sol:getChainlinkLatestPrice, PriceOracle.sol:getUniswapLatestPrice""
    }
  ],
  ""IssueNumber"": 35,
  ""OutputList"": 12
}",178.08710289001465,3610.0,32.0,"### **[H-09] PriceOracle Does Not Filter Price Feed Outliers**

**Report Description**:  
The `getLatestPrice()` function in the `PriceOracle` contract does not filter out malformed or manipulated price data from the Chainlink oracle. If the oracle returns an outlier or malfunctioned price due to manipulation or technical issues, the result will be passed directly to users, leading to unintended consequences. This creates a substantial attack surface, as malicious actors could exploit this vulnerability to manipulate prices. Implementing mitigation mechanics, such as outlier detection or price bounds, would ensure that only sustainable price movements affect user economics.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of unfiltered price feed outliers in the `getLatestPrice()` function. While the response list includes issues related to stale data, centralization risks, and input validation, it does not cover the specific vulnerability of failing to filter or validate price outliers. This is a critical gap, as the lack of outlier detection can lead to significant financial risks and exploitation.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-09] PriceOracle Does Not Filter Price Feed Outliers**","```
None.
```",0.0
NoYield.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/ICEther.sol';
import '../interfaces/Invest/ICToken.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into available exchanges
 * @author Sublime
 **/
contract NoYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice stores the address of savings account contract
     **/
    address payable public savingsAccount;

    /**
     * @notice checks if contract is invoked by savings account
     **/
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    /**
     * @notice used to initialize the variables in the contract
     * @dev can only be called once
     * @param _owner address of the owner
     * @param _savingsAccount address of the savings account contract
     **/
    function initialize(address _owner, address payable _savingsAccount) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
    }

    /**
     * @notice used to query liquidity token for a given asset
     * @param _asset address of the asset
     * @return _tokenAddress address of the lqiudity token for the asset
     **/
    function liquidityToken(address _asset) external view override returns (address _tokenAddress) {
        _tokenAddress = _asset;
    }

    /**
     * @notice used to update savings account contract address
     * @dev can only be called by owner
     * @param _savingsAccount address of updated savings account contract
     **/
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _wallet address to which tokens are withdrawn
     */
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        uint256 amount = IERC20(_asset).balanceOf(address(this));
        IERC20(_asset).safeTransfer(_wallet, received);
        received = amount;
    }

    /**
     * @notice Used to lock tokens in the protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param user the address of user
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');
        if (asset != address(0)) {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
        } else {
            require(msg.value == amount, 'Invest: ETH amount');
        }
        sharesReceived = amount;
        emit LockedTokens(user, asset, sharesReceived);
    }

    /**
     * @notice Used to unlock tokens from the protocol
     * @param asset the address of underlying token
     * @param amount the amount of asset
     * @return tokensReceived received amount of tokens received
     **/
    function unlockTokens(address asset, uint256 amount)
        external
        override
        onlySavingsAccount
        nonReentrant
        returns (uint256 tokensReceived)
    {
        tokensReceived = _unlockTokens(asset, amount);
    }

    /**
     * @notice Used to unlock shares
     * @param asset the address of underlying token
     * @param amount the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        received = _unlockTokens(asset, amount);
    }

    function _unlockTokens(address asset, uint256 amount) internal returns (uint256 received) {
        require(amount != 0, 'Invest: amount');
        received = amount;
        if (asset == address(0)) {
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            IERC20(asset).safeTransfer(savingsAccount, received);
        }
        emit UnlockedTokens(asset, received);
    }

    /**
     * @dev Used to get amount of underlying tokens for given number of shares
     * @param shares the amount of shares
     * @param asset the address of token locked
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) external pure override returns (uint256 amount) {
        amount = shares;
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param amount the amount of tokens
     * @param asset the address of token
     * @return shares amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 amount, address asset) external pure override returns (uint256 shares) {
        shares = amount;
    }
}",1322,165,"[H-10] Wrong implementation of NoYield.sol#emergencyWithdraw()

Submitted by WatchPug, also found by 0x1f8b
https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/NoYield.sol#L78-L83
function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
    require(_wallet != address(0), 'cant burn');
    uint256 amount = IERC20(_asset).balanceOf(address(this));
    IERC20(_asset).safeTransfer(_wallet, received);
    received = amount;
}

received is not being assigned prior to L81, therefore, at L81, received is 0.
As a result, the emergencyWithdraw() does not work, in essence.


[H-11] Unable To Call emergencyWithdraw ETH in NoYield Contract

The `emergencyWithdraw` function is implemented in all yield sources to allow the onlyOwner role to drain the contract's balance in case of emergency. The contract considers ETH as a zero address asset. However, there is a call made on _asset which will revert if it is the zero address. As a result, ETH tokens can never be withdrawn from the NoYield contract in the event of an emergency.
  [M-06] NoYield.sol Tokens with fee on transfer are not supported

There are ERC20 tokens that charge fee for every transfer() or transferFrom().
In the current implementation, NoYield.sol#lockTokens() assumes that the received amount is the same as the transfer amount, and uses it to calculate sharesReceived amounts.
As a result, in `unlockTokens()`, later users may not be able to successfully withdraw their tokens, as it may revert at L141 for insufficient balance.
https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/NoYield.sol#L93-L106
",3,,"pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/ICEther.sol';
import '../interfaces/Invest/ICToken.sol';


contract NoYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    
    address payable public savingsAccount;

    
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    
    function initialize(address _owner, address payable _savingsAccount) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
    }

    
    function liquidityToken(address _asset) external view override returns (address _tokenAddress) {
        _tokenAddress = _asset;
    }

    
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        uint256 amount = IERC20(_asset).balanceOf(address(this));
        IERC20(_asset).safeTransfer(_wallet, received);
        received = amount;
    }

    
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');
        if (asset != address(0)) {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
        } else {
            require(msg.value == amount, 'Invest: ETH amount');
        }
        sharesReceived = amount;
        emit LockedTokens(user, asset, sharesReceived);
    }

    
    function unlockTokens(address asset, uint256 amount)
        external
        override
        onlySavingsAccount
        nonReentrant
        returns (uint256 tokensReceived)
    {
        tokensReceived = _unlockTokens(asset, amount);
    }

    
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        received = _unlockTokens(asset, amount);
    }

    function _unlockTokens(address asset, uint256 amount) internal returns (uint256 received) {
        require(amount != 0, 'Invest: amount');
        received = amount;
        if (asset == address(0)) {
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            IERC20(asset).safeTransfer(savingsAccount, received);
        }
        emit UnlockedTokens(asset, received);
    }

    
    function getTokensForShares(uint256 shares, address asset) external pure override returns (uint256 amount) {
        amount = shares;
    }

    
    function getSharesForTokens(uint256 amount, address asset) external pure override returns (uint256 shares) {
        shares = amount;
    }
}",786,2,1,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that the `onlyOwner` modifier is correctly implemented and prevents unauthorized access to sensitive functions like `updateSavingsAccount` and `emergencyWithdraw`."",
        ""Confirm that the `initialize` function can only be called once, preventing re-initialization and potential ownership changes."",
        ""Verify that the owner can successfully change the `savingsAccount` address using `updateSavingsAccount` and that the `SavingsAccountUpdated` event is emitted correctly."",
        ""Check that the `onlySavingsAccount` modifier correctly restricts access to the `lockTokens`, `unlockTokens`, and `unlockShares` functions, ensuring only the designated savings account can call them."",
        ""Ensure proper checks on `_owner` and `_savingsAccount` in the `initialize` function to prevent initialization with a zero address.""
      ]
    },
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Confirm that the `nonReentrant` modifier effectively prevents reentrancy attacks in `lockTokens`, `unlockTokens`, and `unlockShares`."",
        ""Analyze the `savingsAccount.call{value: received}('')` function in `_unlockTokens` for potential reentrancy issues, even though a reentrancy guard is used. Pay special attention to gas limits and potential call stack exhaustion."",
        ""Simulate external contract calls within the `savingsAccount` to test the effectiveness of the reentrancy guard.""
      ]
    },
    {
      ""Area"": ""Token Handling and Transfers"",
      ""Tasks"": [
        ""Verify that the `safeTransfer` and `safeTransferFrom` functions from the SafeERC20 library are used correctly to prevent potential ERC20 transfer failures."",
        ""Check for potential integer overflow/underflow issues when handling token amounts, even though SafeMath is used (ensure it's used consistently throughout the contract)."",
        ""Analyze the `lockTokens` function to ensure that the `safeTransferFrom` function correctly transfers tokens from the user to the contract."",
        ""Review the `emergencyWithdraw` function to ensure that the owner can withdraw tokens to an arbitrary address and that the withdrawn amount is accurately tracked. Address the discrepancy in the `emergencyWithdraw` function regarding the assignment to `received` before the transfer. It should be `received = amount; IERC20(_asset).safeTransfer(_wallet, amount);`"",
        ""In `_unlockTokens`, confirm that the `asset == address(0)` condition correctly handles Ether transfers and that the `savingsAccount.call{value: received}('')` function functions as expected."",
        ""Confirm that the contract handles tokens with different decimal precisions correctly. Consider adding a check or conversion to handle tokens with unusual decimal counts."",
        ""Verify handling of edge cases in token transfers, such as when the contract initially has no tokens or when the requested amount exceeds the contract's balance.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the contract's gas usage and identify potential areas for optimization."",
        ""Consider using more efficient data types or storage patterns to reduce gas costs."",
        ""Evaluate the cost of emitting events and determine if they are necessary."",
        ""Check for redundant calculations or operations that can be eliminated.""
      ]
    },
    {
      ""Area"": ""Functional Correctness"",
      ""Tasks"": [
        ""Verify that the `liquidityToken` function simply returns the input asset address, as intended."",
        ""Confirm that the `getTokensForShares` and `getSharesForTokens` functions correctly return the input amount (shares or tokens) due to the 1:1 relationship, as documented."",
        ""Ensure the `require` statements for non-zero amounts in `lockTokens` and `_unlockTokens` are effective and prevent unintended behavior."",
        ""Test all functions with different input values, including edge cases and boundary conditions, to ensure they function as expected."",
        ""Verify the logic in `_unlockTokens` handles ETH and ERC20 tokens correctly.""
      ]
    },
    {
      ""Area"": ""Error Handling and Edge Cases"",
      ""Tasks"": [
        ""Thoroughly test all `require` statements to ensure they trigger under the correct conditions."",
        ""Check how the contract behaves when attempting to transfer zero tokens or shares."",
        ""Test the behavior of `lockTokens` and `unlockTokens` with very large amounts to check for potential overflow issues or other unexpected behavior."",
        ""Verify that the contract handles situations where the `savingsAccount` is a contract that reverts on receiving Ether or tokens."",
        ""Evaluate the impact of a failed token transfer in `_unlockTokens`. Does it correctly revert the transaction?""
      ]
    },
    {
      ""Area"": ""Naming Conventions and Code Clarity"",
      ""Tasks"": [
        ""Consider a more descriptive name for the contract that better reflects its purpose (e.g., `TokenLocker`, `NoYieldInvestment`)."",
        ""Review the code for any unclear or confusing logic and refactor it to improve readability."",
        ""Ensure that all comments are accurate and up-to-date.""
      ]
    },
    {
      ""Area"": ""External Interactions and Interfaces"",
      ""Tasks"": [
        ""Review the interfaces `IYield`, `ICEther`, and `ICToken` to ensure they are correctly defined and compatible with the contract's interactions."",
        ""Consider potential vulnerabilities or issues related to the external contracts being interacted with, especially regarding `savingsAccount`.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `NoYield` is designed to act as an investment module with no actual yield generation. It allows a designated savings account to lock and unlock tokens on behalf of users. The contract uses OpenZeppelin libraries for access control (OwnableUpgradeable), reentrancy protection (ReentrancyGuard), safe ERC20 operations (SafeERC20), and safe math (SafeMath). It also relies on custom interfaces for interacting with external entities like a Yield contract, Cether, and CTokens. The contract primarily focuses on managing token deposits and withdrawals, offering functions for locking and unlocking tokens/shares, which are treated equivalently in this no-yield scenario. The owner has an emergency withdraw function."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NoYield"",
    ""Purpose"": ""Acts as an investment module, managing token deposits and withdrawals without generating any yield."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""IYield"",
        ""Initializable"",
        ""OwnableUpgradeable"",
        ""ReentrancyGuard""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"",
        ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"",
        ""@openzeppelin/contracts/math/SafeMath.sol"",
        ""../interfaces/IYield.sol"",
        ""../interfaces/Invest/ICEther.sol"",
        ""../interfaces/Invest/ICToken.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""savingsAccount"",
        ""Type"": ""address payable"",
        ""Purpose"": ""Address of the savings account authorized to lock and unlock tokens.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlySavingsAccount"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function execution to the savings account."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract, setting the owner and savings account. It leverages the Initializable pattern."",
        ""Parameters"": [
          ""_owner (address)"",
          ""_savingsAccount (address payable)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""liquidityToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the provided asset address as the token address, essentially an identity function."",
        ""Parameters"": [
          ""_asset (address)""
        ],
        ""Returns"": [
          ""_tokenAddress (address)""
        ]
      },
      {
        ""Name"": ""updateSavingsAccount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the savings account address. Can only be called by the owner."",
        ""Parameters"": [
          ""_savingsAccount (address payable)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_updateSavingsAccount"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to update the savings account address and emit an event."",
        ""Parameters"": [
          ""_savingsAccount (address payable)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to withdraw any ERC20 tokens from the contract. "",
        ""Parameters"": [
          ""_asset (address)"",
          ""_wallet (address payable)""
        ],
        ""Returns"": [
          ""received (uint256)""
        ]
      },
      {
        ""Name"": ""lockTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Locks tokens from a user, transferring them to the contract. It supports both ERC20 tokens and Ether."",
        ""Parameters"": [
          ""user (address)"",
          ""asset (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [
          ""sharesReceived (uint256)""
        ]
      },
      {
        ""Name"": ""unlockTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Unlocks tokens, transferring them to the savings account."",
        ""Parameters"": [
          ""asset (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [
          ""tokensReceived (uint256)""
        ]
      },
      {
        ""Name"": ""unlockShares"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Unlocks shares, which are equivalent to tokens in this implementation, transferring them to the savings account."",
        ""Parameters"": [
          ""asset (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [
          ""received (uint256)""
        ]
      },
      {
        ""Name"": ""_unlockTokens"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to perform the unlocking logic. Handles both ERC20 tokens and Ether."",
        ""Parameters"": [
          ""asset (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [
          ""received (uint256)""
        ]
      },
      {
        ""Name"": ""getTokensForShares"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the same amount passed as shares since there is no yield. Shares and tokens are treated as equivalent."",
        ""Parameters"": [
          ""shares (uint256)"",
          ""asset (address)""
        ],
        ""Returns"": [
          ""amount (uint256)""
        ]
      },
      {
        ""Name"": ""getSharesForTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the same amount passed as tokens since there is no yield. Shares and tokens are treated as equivalent."",
        ""Parameters"": [
          ""amount (uint256)"",
          ""asset (address)""
        ],
        ""Returns"": [
          ""shares (uint256)""
        ]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20(asset).safeTransferFrom(user, address(this), amount)"",
    ""IERC20(asset).safeTransfer(savingsAccount, received)"",
    ""savingsAccount.call{value: received}('')""
  ],
  ""SpecialMechanisms"": [
    ""OwnableUpgradeable for access control."",
    ""ReentrancyGuard for preventing reentrancy attacks."",
    ""SafeERC20 for safe ERC20 token transfers."",
    ""Initializable to allow upgradeable contract initialization.""
  ],
  ""Questions"": [
    ""Is there a specific reason for inheriting from IYield if the contract is explicitly designed *not* to generate yield?"",
    ""The naming is a bit confusing. Should this contract be named something other than NoYield. Perhaps a contract that's sole purpose is to lock and unlock tokens without yield can have a better name than 'NoYield'."",
    ""Are there any known limitations or edge cases related to the savingsAccount.call{value: received}('') function, especially concerning gas limits?"",
    ""In the emergencyWithdraw function, received is initialized but reassigned without using the initialized value. Should the order be reversed to assign the amount before the transfer, or is this intentional?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Missing Access Control for `emergencyWithdraw`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `emergencyWithdraw` function allows the owner to withdraw any ERC20 token or ETH held by the contract without proper validation of the withdrawn amount, potentially leading to unintended consequences or malicious fund draining. Several issues exist: there's no mechanism to prevent withdrawing funds sent intentionally to the contract for a rug pull, no checks to ensure the amount withdrawn does not exceed the contract's balance, and the withdrawn amount is not validated against a reasonable threshold. The transferred amount also incorrectly uses `received` instead of `amount`. A more restrictive access control scheme and proper amount validation are needed."",
      ""Impact"": ""Potential for owner to drain user's funds mistakenly sent to the contract or maliciously drain funds in a rug-pull scenario. Potential loss of user funds due to compromised owner account or malicious owner. Incorrect handling of the amount to be withdrawn could lead to denial of service or other unexpected behaviors."",
      ""Location"": ""emergencyWithdraw function""
    },
    {
      ""Issue"": ""Potential Reentrancy in `_unlockTokens` when transferring ETH/Possible ETH loss if asset is address(0) and savingsAccount is malicious"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_unlockTokens` function attempts to transfer ETH using a low-level `call`. If the recipient contract (`savingsAccount`) has a fallback function that consumes a lot of gas or reverts, the call could fail. Moreover, if the `savingsAccount` is a malicious contract, it could potentially re-enter the `unlockTokens` or `unlockShares` functions (though mitigated by `nonReentrant` modifier) if other functions in `savingsAccount` can call back into this contract. Further, if `savingsAccount` is a contract and its fallback function *succeeds* without actually accepting the ETH, it could potentially lead to an unexpected state. While a successful transfer is checked, the *outcome* of the receiver is not. An event should be emitted inside of `savingsAccount` to confirm the eth was accepted or handle the error appropriately."",
      ""Impact"": ""Transaction failure or potential reentrancy vulnerability if `savingsAccount` is malicious. Potential for ETH to be locked or lost if `savingsAccount` is malicious."",
      ""Location"": ""_unlockTokens function, savingsAccount.call""
    },
    {
      ""Issue"": ""Incorrect Token Transfer Amount in `emergencyWithdraw`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In `emergencyWithdraw`, the amount that is actually transferred is assigned to `received` *after* the transfer happens, and then `received` is used instead of `amount` to transfer the tokens. This results in the function always returning the total amount in the contract regardless of the safeTransfer success and may lead to inconsistencies in the contract\'s state, as the internal accounting (received) may not match the actual token balances."",
      ""Impact"": ""Deceptive reporting of withdrawn amount, potential loss of funds without proper accounting. A malicious operator could potentially drain all funds without the contract reporting it. Could lead to inconsistencies in the contract\'s state, as the internal accounting (received) may not match the actual token balances."",
      ""Location"": ""emergencyWithdraw function""
    },
    {
      ""Issue"": ""Lack of slippage control in `lockTokens` for ETH deposits"",
      ""Severity"": ""Low"",
      ""Description"": ""The `lockTokens` function allows users to deposit ETH directly when `asset` is the zero address. The contract requires that `msg.value` is equal to the passed `amount`, creating an unneeded point of failure and potential loss of ETH due to overpayment/frontrunning. It also does not account for potential overpayment if a user sends more ETH than required. No slippage protection for withdrawals."",
      ""Impact"": ""Failed transaction if exact ETH amount is not sent. Potential for users to overpay when depositing ETH due to transaction frontrunning and gas price fluctuations. Potential for users to lose ETH due to overpayment if they accidentally or maliciously send more than the required amount."",
      ""Location"": ""lockTokens function, asset == address(0) branch, lockTokens function""
    },
    {
      ""Issue"": ""Redundant Share Calculations"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `getTokensForShares` and `getSharesForTokens` simply return the input value. This effectively makes shares and tokens equivalent, removing any potential scaling or calculation based on an underlying yield strategy. If a yield strategy is to be implemented in the future these functions will need to be adjusted, but as of this moment their existence is purely redundant. Potential loss of precision in Shares/Tokens Conversion Due to No Yield. Slippage issues if used in yield environment."",
      ""Impact"": ""The current implementation makes the share calculation methods redundant, and could cause confusion. Not an immediate security risk, but could cause problems if this contract is used as a base for another yield-bearing contract without modification."",
      ""Location"": ""getTokensForShares and getSharesForTokens functions""
    },
    {
      ""Issue"": ""Potential precision loss"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract handles arbitrary ERC20 tokens. There\'s no check to ensure that tokens use a compatible number of decimals. If a token with a very high number of decimals is deposited, and then withdrawn, it might lead to rounding errors or unexpected behavior during amount calculations, especially if integrated with a system working with a different default number of decimals. No protection against deflationary tokens."",
      ""Impact"": ""Potential rounding errors and precision loss when dealing with ERC20 tokens with different decimal places. Inaccurate accounting of token balances and potential unexpected behavior when interacting with deflationary tokens."",
      ""Location"": ""Entire contract, specifically interactions with IERC20 tokens., unlockTokens function""
    },
    {
      ""Issue"": ""Potential for griefing in `emergencyWithdraw`"",
      ""Severity"": ""Low"",
      ""Description"": ""Although the `emergencyWithdraw` function is onlyOwner, a malicious owner could potentially grief users by withdrawing ERC20 tokens held by the contract, even if those tokens represent locked funds for other users. This violates the principle of predictable contract behavior."",
      ""Impact"": ""Possible loss of funds for users if the owner maliciously withdraws all tokens."",
      ""Location"": ""emergencyWithdraw function""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `updateSavingsAccount` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `updateSavingsAccount` function, which allows the owner to change the savings account address, is vulnerable to front-running. An attacker could observe a transaction to `updateSavingsAccount` in the mempool and submit their own transaction with a higher gas price to change the `savingsAccount` address before the original transaction is executed. This could allow the attacker to redirect funds intended for the original savings account to their own address when `unlockTokens` is called."",
      ""Impact"": ""Potential for funds to be redirected to an attacker-controlled address."",
      ""Location"": ""function `updateSavingsAccount`""
    },
    {
      ""Issue"": ""Lack of input validation in `lockTokens` for asset address"",
      ""Severity"": ""Low"",
      ""Description"": ""The `lockTokens` function does not validate if the provided `asset` address is a valid ERC20 token address before attempting `IERC20(asset).safeTransferFrom`. If the provided `asset` address is not a contract or does not implement the ERC20 interface correctly, the `safeTransferFrom` call will revert. This may result in unexpected behavior and potentially lock the user\'s funds."",
      ""Impact"": ""Potentially block user funds."",
      ""Location"": ""function `lockTokens`""
    },
    {
      ""Issue"": ""No yield is actually generated"",
      ""Severity"": ""Info"",
      ""Description"": ""This contract is named `NoYield`, and indeed, it does not generate any yield. The `getTokensForShares` and `getSharesForTokens` functions simply return the input amount. It essentially acts as a vault without any interest or rewards."",
      ""Impact"": ""The contract provides no yield generation, so users won\'t earn passive income."",
      ""Location"": ""getTokensForShares, getSharesForTokens""
    },
    {
      ""Issue"": ""No yield, but still emitting `LockedTokens` and `UnlockedTokens`"",
      ""Severity"": ""Info"",
      ""Description"": ""The contract name `NoYield` and implementation implies that there are no actual yields generated. However, the `lockTokens` and `unlockTokens` functions still emit `LockedTokens` and `UnlockedTokens` events. This could be confusing for users or other contracts interacting with this contract, as it might suggest that tokens are being locked or unlocked as part of a yield-generating mechanism, when in fact, they are simply being transferred and tracked within this contract. This is more of a clarity and usability issue than a security vulnerability."",
      ""Impact"": ""Potential confusion and misinterpretation of contract behavior."",
      ""Location"": ""functions `lockTokens` and `unlockTokens`""
    },
    {
      ""Issue"": ""Redundant `getTokensForShares` and `getSharesForTokens` functions"",
      ""Severity"": ""Info"",
      ""Description"": ""The `getTokensForShares` and `getSharesForTokens` functions simply return the input value. This indicates that 1 share always equals 1 token. While this simplifies the contract logic, it eliminates any potential for the contract to dynamically calculate share values based on factors like accumulated interest or fees. Since there is no yield, these functions are correct, but they expose that no \'share\' logic is present."",
      ""Impact"": ""Lack of flexibility and potential for future yield implementations without significant modifications."",
      ""Location"": ""functions `getTokensForShares` and `getSharesForTokens`""
    },
    {
      ""Issue"": ""Redundant super.transferOwnership call in initialize() / Unnecessary overriding of OwnableUpgradeable's `transferOwnership` function in initialize"",
      ""Severity"": ""Info"",
      ""Description"": ""The initializer already calls `__Ownable_init()` which sets the owner. Subsequently calling `super.transferOwnership(_owner)` is redundant. This doesn't introduce a security vulnerability but adds unnecessary gas cost. It's recommended to avoid overriding the standard `transferOwnership` function unless there's a strong reason to do so."",
      ""Impact"": ""Unnecessary gas consumption during contract initialization. Redundant code and potential confusion."",
      ""Location"": ""initialize function""
    },
    {
      ""Issue"": ""Missing event for `emergencyWithdraw`"",
      ""Severity"": ""Info"",
      ""Description"": ""While the `emergencyWithdraw` function includes a return value for the amount of tokens received, there is no event emitted after withdrawing the tokens. Emitting an event would provide a more transparent audit trail for emergency withdrawals."",
      ""Impact"": ""Reduced auditability."",
      ""Location"": ""emergencyWithdraw function""
    },
    {
      ""Issue"": ""Inconsistent Naming Convention"",
      ""Severity"": ""Info"",
      ""Description"": ""The contract uses both underscore prefixes (e.g., `_asset`) and suffixes (e.g., `_tokenAddress`) for function arguments. While not a security vulnerability, consistent naming conventions improve code readability and maintainability."",
      ""Impact"": ""Reduced code readability and maintainability."",
      ""Location"": ""Throughout the contract.""
    },
    {
      ""Issue"": ""Lack of slippage control during token withdrawal"",
      ""Severity"": ""Info"",
      ""Description"": ""The `_unlockTokens` function transfers `amount` tokens to the `savingsAccount` without considering slippage or potential price changes. If the asset being transferred is highly volatile or has low liquidity, the `savingsAccount` might receive fewer tokens than expected, or the transaction could fail entirely if the price moves unfavorably between the time the transaction is initiated and when it is executed."",
      ""Impact"": ""A unexpected result on asset transfer"",
      ""Location"": ""unlockTokens and _unlockTokens functions""
    },
    {
      ""Issue"": ""Redundant amount check in lockTokens"",
      ""Severity"": ""Info"",
      ""Description"": ""The check `require(msg.value == amount, 'Invest: ETH amount');` is redundant because if `msg.value` is not equal to amount the transfer will fail. It doesn't make a big impact because it is checked inside of a `require` statement, but its unnecessary."",
      ""Impact"": ""None."",
      ""Location"": ""lockTokens""
    }
  ],
  ""IssueNumber"": 38,
  ""OutputList"": 17
}",167.10873818397522,3655.0,32.0,"### **Comparison and Evaluation**

---

#### **[H-10] Wrong implementation of NoYield.sol#emergencyWithdraw()**

**Report Description**:  
The `emergencyWithdraw` function in `NoYield.sol` incorrectly assigns the `received` variable after the `safeTransfer` call. Since `received` is used in the transfer, it defaults to `0`, causing the function to fail. This implementation flaw renders the `emergencyWithdraw` function non-functional.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Token Transfer Amount in `emergencyWithdraw`""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the incorrect assignment of `received` in the `emergencyWithdraw` function. It correctly explains the impact of this flaw, which aligns with the issue report.

---

#### **[H-11] Unable To Call emergencyWithdraw ETH in NoYield Contract**

**Report Description**:  
The `emergencyWithdraw` function does not handle ETH withdrawals because it attempts to call `IERC20(_asset)` even when `_asset` is the zero address (representing ETH). This causes the function to revert, preventing ETH from being withdrawn in emergencies.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the specific issue of ETH withdrawal failure due to the zero address check. This is a critical oversight, as it prevents the contract from functioning as intended in emergencies.

---

#### **[M-06] NoYield.sol Tokens with fee on transfer are not supported**

**Report Description**:  
The `lockTokens` function in `NoYield.sol` assumes that the received token amount matches the transferred amount, which is incorrect for tokens with fee-on-transfer mechanisms. This discrepancy can lead to insufficient balance errors during withdrawals, potentially locking user funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of fee-on-transfer tokens, which is a significant oversight. This vulnerability can lead to user funds being locked, and the lack of a response indicates a gap in the analysis.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-10] Wrong implementation of NoYield.sol#emergencyWithdraw()**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-11] Unable To Call emergencyWithdraw ETH in NoYield Contract**
- **[M-06] NoYield.sol Tokens with fee on transfer are not supported**

---

### **Conclusion**

The response list partially covers the issues in the issue report. While it correctly identifies the flaw in the `emergencyWithdraw` function related to the `received` variable, it misses critical issues such as the inability to withdraw ETH and the lack of support for fee-on-transfer tokens. These gaps highlight the need for a more comprehensive review of the contract's functionality and edge cases.","```
1. Incorrect Token Transfer Amount in `emergencyWithdraw`
```",0.3333333333333333
PoolFactory.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '../Proxy.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/IPriceOracle.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';

/**
 * @title Pool Factory contract with methods for handling different pools
 * @notice Implements the functions related to Pool (CRUD)
 * @author Sublime
 */
contract PoolFactory is Initializable, OwnableUpgradeable, IPoolFactory {
    /*
     * @notice Used to define limits for the Pool parameters
     * @param min the minimum threshold for the parameter
     * @param max the maximum threshold for the parameter
     */
    struct Limits {
        uint256 min;
        uint256 max;
    }

    /**
     * @notice function definition of the pool contract
     */
    bytes4 public poolInitFuncSelector; //  bytes4(keccak256(""initialize(uint256,address,address,address,uint256,uint256,uint256,uint256,bool)""))

    /**
     * @notice address of the latest implementation of the pool logic
     */
    address public poolImpl;

    /**
     * @notice address of the contract storing the user registry
     */
    address public override userRegistry;

    /**
     * @notice address of the contract storing the strategy registry
     */
    address public strategyRegistry;

    /**
     * @notice address of the latest implementation of the extension logic
     */
    address public override extension;

    /**
     * @notice address of the latest implementation of the repayment logic
     */
    address public override repaymentImpl;

    /**
     * @notice address of the latest implementation of the pool logic
     */
    address public override priceOracle;

    /**
     * @notice address of the savings account used
     */
    address public override savingsAccount;

    /**
     * @notice the time interval for the lenders to make contributions to pool
     */
    uint256 public override collectionPeriod;

    /**
     * @notice the time interval for the borrower to withdraw the loan from pool
     */
    uint256 public override loanWithdrawalDuration;

    /**
     * @notice the time interval for the active stage of the margin call
     */
    uint256 public override marginCallDuration;

    /**
     * @notice Fraction of the requested amount for pool below which pool is cancelled
     */
    uint256 public override minBorrowFraction;

    /**
     * @notice the fraction used for calculating the liquidator reward
     */
    uint256 public override liquidatorRewardFraction;

    /**
     * @notice the fraction used for calculating the penalty when the pool is cancelled
     */
    uint256 public override poolCancelPenaltyMultiple;

    /**
     * @notice Contract Address of no yield
     */
    address public override noStrategyAddress;

    uint256 protocolFeeFraction;
    address protocolFeeCollector;

    /*
     * @notice Used to mark assets supported for borrowing
     */
    mapping(address => bool) isBorrowToken;

    /*
     * @notice Used to mark supported collateral assets
     */
    mapping(address => bool) isCollateralToken;

    /**
     * @notice Used to keep track of valid pool addresses
     */
    mapping(address => bool) public override poolRegistry;

    /*
     * @notice Used to set the min/max borrow amount for Pools
     */
    Limits poolSizeLimit;

    /*
     * @notice Used to set the min/max collateral ratio for Pools
     */
    Limits idealCollateralRatioLimit;

    /*
     * @notice Used to set the min/max borrow rates (interest rate provided by borrower) for Pools
     */
    Limits borrowRateLimit;

    /*
     * @notice used to set the min/max repayment interval for Pools
     */
    Limits repaymentIntervalLimit;

    /*
     * @notice used to set the min/max number of repayment intervals for Pools
     */
    Limits noOfRepaymentIntervalsLimit;

    /**
     * @notice functions affected by this modifier can only be invoked by the Pool
     */
    modifier onlyPool() {
        require(poolRegistry[msg.sender], 'PoolFactory::onlyPool - Only pool can destroy itself');
        _;
    }

    /**
     * @notice functions affected by this modifier can only be invoked by the borrow of the Pool
     */
    modifier onlyBorrower(address _verifier) {
        require(
            IVerification(userRegistry).isUser(msg.sender, _verifier),
            'PoolFactory::onlyBorrower - Only a valid Borrower can create Pool'
        );
        _;
    }

    /**
     * @notice returns the owner of the pool
     */
    function owner() public view override(IPoolFactory, OwnableUpgradeable) returns (address) {
        return OwnableUpgradeable.owner();
    }

    /**
     * @notice used to initialize the pool factory
     * @dev initializer can only be run once
     * @param _admin address of admin
     * @param _collectionPeriod period for which lenders can lend for pool
     * @param _loanWithdrawalDuration period for which lent tokens can be withdrawn after pool starts
     * @param _marginCallDuration duration of margin call before which collateral ratio has to be maintained
     * @param _poolInitFuncSelector function signature for initializing pool
     * @param _liquidatorRewardFraction fraction of liquidation amount which is given to liquidator as reward multiplied by 10**30
     * @param _poolCancelPenaltyMultiple multiple of borrow rate of pool as penality for cancellation of pool multiplied by 10**30
     * @param _minBorrowFraction amountCollected/amountRequested for a pool, if less than fraction by pool start time then pool can be cancelled without penality multiplied by 10**30
     * @param _protocolFeeFraction fraction of amount borrowed in pool which is collected as protocol fee
     * @param _protocolFeeCollector address where protocol fee is collected
     * @param _noStrategy address of the no strategy address
     */
    function initialize(
        address _admin,
        uint256 _collectionPeriod,
        uint256 _loanWithdrawalDuration,
        uint256 _marginCallDuration,
        bytes4 _poolInitFuncSelector,
        uint256 _liquidatorRewardFraction,
        uint256 _poolCancelPenaltyMultiple,
        uint256 _minBorrowFraction,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        address _noStrategy
    ) external initializer {
        {
            OwnableUpgradeable.__Ownable_init();
            OwnableUpgradeable.transferOwnership(_admin);
        }
        _updateCollectionPeriod(_collectionPeriod);
        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);
        _updateMarginCallDuration(_marginCallDuration);
        _updatepoolInitFuncSelector(_poolInitFuncSelector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);
        _updateMinBorrowFraction(_minBorrowFraction);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateNoStrategy(_noStrategy);
    }

    /**
     * @notice used to setImplementation addresses
     * @dev used to set some of the contracts pool factory interacts with. only admin can invoke
     * @param _poolImpl address of the implementation address of pool
     * @param _repaymentImpl address of the implementation address of repayments
     * @param _userRegistry address of the user registry where users are verified
     * @param _strategyRegistry address of the startegy registry where strategies are whitelisted
     * @param _priceOracle address of the price oracle
     * @param _savingsAccount address of the savings account contract
     * @param _extension address of the extension contract for pools
     */
    function setImplementations(
        address _poolImpl,
        address _repaymentImpl,
        address _userRegistry,
        address _strategyRegistry,
        address _priceOracle,
        address _savingsAccount,
        address _extension
    ) external onlyOwner {
        _updatePoolLogic(_poolImpl);
        _updateRepaymentImpl(_repaymentImpl);
        _updateSavingsAccount(_savingsAccount);
        _updatedExtension(_extension);
        _updateUserRegistry(_userRegistry);
        _updateStrategyRegistry(_strategyRegistry);
        _updatePriceoracle(_priceOracle);
    }

    /**
     * @notice invoked when a new borrow pool is created. deploys a new pool for every borrow request
     * @param _poolSize loan amount requested
     * @param _borrowToken borrow asset requested
     * @param _collateralToken collateral asset requested
     * @param _idealCollateralRatio ideal pool collateral ratio set by the borrower
     * @param _borrowRate interest rate provided by the borrower
     * @param _repaymentInterval interval between the last dates of two repayment cycles
     * @param _noOfRepaymentIntervals number of repayments to be made during the duration of the loan
     * @param _poolSavingsStrategy savings strategy selected for the pool collateral
     * @param _collateralAmount collateral amount deposited
     * @param _transferFromSavingsAccount if true, initial collateral is transferred from borrower's savings account, if false, borrower transfers initial collateral deposit from wallet
     * @param _salt random and unique initial seed
     */
    function createPool(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        bytes32 _salt,
        address _verifier,
        address _lenderVerifier
    ) external payable onlyBorrower(_verifier) {
        if (_collateralToken == address(0)) {
            require(msg.value == _collateralAmount, 'PoolFactory::createPool - Ether send is different from collateral amount specified');
        }
        require(_borrowToken != _collateralToken, 'PoolFactory::createPool - cant borrow the asset put in as collateralToken');
        require(isBorrowToken[_borrowToken], 'PoolFactory::createPool - Invalid borrow token type');
        require(isCollateralToken[_collateralToken], 'PoolFactory::createPool - Invalid collateral token type');
        require(
            IPriceOracle(priceOracle).doesFeedExist(_collateralToken, _borrowToken),
            ""PoolFactory::createPool - Price feed doesn't support token pair""
        );
        require(IStrategyRegistry(strategyRegistry).registry(_poolSavingsStrategy), 'PoolFactory::createPool - Invalid strategy');
        require(isWithinLimits(_poolSize, poolSizeLimit.min, poolSizeLimit.max), 'PoolFactory::createPool - PoolSize not within limits');
        require(
            isWithinLimits(_idealCollateralRatio, idealCollateralRatioLimit.min, idealCollateralRatioLimit.max),
            'PoolFactory::createPool - Collateral Ratio not within limits'
        );
        require(
            isWithinLimits(_borrowRate, borrowRateLimit.min, borrowRateLimit.max),
            'PoolFactory::createPool - Borrow rate not within limits'
        );
        require(
            isWithinLimits(_noOfRepaymentIntervals, noOfRepaymentIntervalsLimit.min, noOfRepaymentIntervalsLimit.max),
            'PoolFactory::createPool - Loan duration not within limits'
        );
        require(
            isWithinLimits(_repaymentInterval, repaymentIntervalLimit.min, repaymentIntervalLimit.max),
            'PoolFactory::createPool - Repayment interval not within limits'
        );
        _createPool(
            _poolSize,
            _borrowRate,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _salt,
            _lenderVerifier
        );
    }

    // @dev These functions are used to avoid stack too deep
    function _createPool(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        bytes32 _salt,
        address _lenderVerifier
    ) internal {
        bytes memory data = _encodePoolInitCall(
            _poolSize,
            _borrowRate,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _lenderVerifier
        );
        bytes32 salt = keccak256(abi.encodePacked(_salt, msg.sender));
        bytes memory bytecode = abi.encodePacked(type(SublimeProxy).creationCode, abi.encode(poolImpl, address(0x01), data));
        uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;

        address pool = _deploy(amount, salt, bytecode);

        poolRegistry[pool] = true;
        emit PoolCreated(pool, msg.sender);
    }

    // @dev These functions are used to avoid stack too deep
    function _encodePoolInitCall(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier
    ) internal view returns (bytes memory data) {
        data = abi.encodeWithSelector(
            poolInitFuncSelector,
            _poolSize,
            _borrowRate,
            msg.sender,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _lenderVerifier,
            loanWithdrawalDuration,
            collectionPeriod
        );
    }

    /**
     * @dev Deploys a contract using `CREATE2`. The address where the contract
     * will be deployed can be known in advance via {computeAddress}.
     *
     * The bytecode for a contract can be obtained from Solidity with
     * `type(contractName).creationCode`.
     *
     * Requirements:
     *
     * - `bytecode` must not be empty.
     * - `salt` must have not been used for `bytecode` already.
     * - the factory must have a balance of at least `amount`.
     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.
     */
    function _deploy(
        uint256 amount,
        bytes32 salt,
        bytes memory bytecode
    ) internal returns (address addr) {
        require(bytecode.length != 0, 'Create2: bytecode length is zero');
        // solhint-disable-next-line no-inline-assembly
        assembly {
            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)
        }
        require(addr != address(0), 'Create2: Failed on deploy');
    }

    /**
     * @notice invoked to check if pool parameters are within thresholds
     * @param _value supplied value of the parameter
     * @param _min minimum threshold of the parameter
     * @param _max maximum threshold of the parameter
     */
    function isWithinLimits(
        uint256 _value,
        uint256 _min,
        uint256 _max
    ) internal pure returns (bool) {
        if (_min != 0 && _max != 0) {
            return (_value >= _min && _value <= _max);
        } else if (_min != 0) {
            return (_value >= _min);
        } else if (_max != 0) {
            return (_value <= _max);
        } else {
            return true;
        }
    }

    /**
     * @notice used to update the list of supported borrow tokens
     * @param _borrowToken address of the borrow asset
     * @param _isSupported true if _borrowToken is a valid borrow asset, false if _borrowToken is an invalid borrow asset
     */
    function updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) external onlyOwner {
        _updateSupportedBorrowTokens(_borrowToken, _isSupported);
    }

    function _updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) internal {
        isBorrowToken[_borrowToken] = _isSupported;
        emit BorrowTokenUpdated(_borrowToken, _isSupported);
    }

    /**
     * @notice used to update the list of supported Collateral tokens
     * @param _collateralToken address of the Collateral asset
     * @param _isSupported true if _collateralToken is a valid Collateral asset, false if _collateralToken is an invalid Collateral asset
     */
    function updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) external onlyOwner {
        _updateSupportedCollateralTokens(_collateralToken, _isSupported);
    }

    function _updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) internal {
        isCollateralToken[_collateralToken] = _isSupported;
        emit CollateralTokenUpdated(_collateralToken, _isSupported);
    }

    /**
     * @notice used to update the pointer to Initializer function of the proxy pool contract
     * @param _functionId updated function definition of the proxy pool contract
     */
    function updatepoolInitFuncSelector(bytes4 _functionId) external onlyOwner {
        _updatepoolInitFuncSelector(_functionId);
    }

    function _updatepoolInitFuncSelector(bytes4 _functionId) internal {
        poolInitFuncSelector = _functionId;
        emit PoolInitSelectorUpdated(_functionId);
    }

    /**
     * @notice used to update the Pool.sol logic
     * @param _poolLogic the address of the new Pool logic contract
     */
    function updatePoolLogic(address _poolLogic) external onlyOwner {
        _updatePoolLogic(_poolLogic);
    }

    function _updatePoolLogic(address _poolLogic) internal {
        poolImpl = _poolLogic;
        emit PoolLogicUpdated(_poolLogic);
    }

    /**
     * @notice used to update the user registry
     * @param _userRegistry address of the contract storing the user registry
     */
    function updateUserRegistry(address _userRegistry) external onlyOwner {
        _updateUserRegistry(_userRegistry);
    }

    function _updateUserRegistry(address _userRegistry) internal {
        userRegistry = _userRegistry;
        emit UserRegistryUpdated(_userRegistry);
    }

    /**
     * @notice used to update the strategy registry
     * @param _strategyRegistry address of the contract storing the strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the implementation of the repayment logic
     * @param _repaymentImpl address of the updated repayment.sol contract
     */
    function updateRepaymentImpl(address _repaymentImpl) external onlyOwner {
        _updateRepaymentImpl(_repaymentImpl);
    }

    function _updateRepaymentImpl(address _repaymentImpl) internal {
        repaymentImpl = _repaymentImpl;
        emit RepaymentImplUpdated(_repaymentImpl);
    }

    /**
     * @notice used to update contract address of nostrategy contract
     * @param _noStrategy address of the updated noYield.sol contract
     */
    function updateNoStrategy(address _noStrategy) external onlyOwner {
        _updateNoStrategy(_noStrategy);
    }

    function _updateNoStrategy(address _noStrategy) internal {
        noStrategyAddress = _noStrategy;
        emit NoStrategyUpdated(_noStrategy);
    }

    /**
     * @notice used to update the implementation of the price oracle logic
     * @param _priceOracle address of the updated price oracle contract
     */
    function updatePriceoracle(address _priceOracle) external onlyOwner {
        _updatePriceoracle(_priceOracle);
    }

    function _updatePriceoracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the extensions contract
     * @param _extension address of the updated extensions contract
     */
    function updatedExtension(address _extension) external onlyOwner {
        _updatedExtension(_extension);
    }

    function _updatedExtension(address _extension) internal {
        extension = _extension;
        emit ExtensionImplUpdated(_extension);
    }

    /**
     * @notice used to update the savings account contract
     * @param _savingsAccount address of the updated savings account contract
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the collection period of the Pool
     * @param _collectionPeriod updated value of the collection period
     */
    function updateCollectionPeriod(uint256 _collectionPeriod) external onlyOwner {
        _updateCollectionPeriod(_collectionPeriod);
    }

    function _updateCollectionPeriod(uint256 _collectionPeriod) internal {
        collectionPeriod = _collectionPeriod;
        emit CollectionPeriodUpdated(_collectionPeriod);
    }

    /**
     * @notice used to update the loan withdrawal duration by owner
     * @param _loanWithdrawalDuration updated value of loanWithdrawalDuration
     */
    function updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) external onlyOwner {
        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);
    }

    function _updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) internal {
        loanWithdrawalDuration = _loanWithdrawalDuration;
        emit LoanWithdrawalDurationUpdated(_loanWithdrawalDuration);
    }

    /**
     * @notice used to update the active stage of the margin call of the Pool
     * @param _marginCallDuration updated value of the margin call duration
     */
    function updateMarginCallDuration(uint256 _marginCallDuration) external onlyOwner {
        _updateMarginCallDuration(_marginCallDuration);
    }

    function _updateMarginCallDuration(uint256 _marginCallDuration) internal {
        marginCallDuration = _marginCallDuration;
        emit MarginCallDurationUpdated(_marginCallDuration);
    }

    /**
     * @notice used to update the min borrow fraction by owner
     * @param _minBorrowFraction updated value of min borrow fraction multiplied by 10**30
     */
    function updateMinBorrowFraction(uint256 _minBorrowFraction) external onlyOwner {
        _updateMinBorrowFraction(_minBorrowFraction);
    }

    function _updateMinBorrowFraction(uint256 _minBorrowFraction) internal {
        minBorrowFraction = _minBorrowFraction;
        emit MinBorrowFractionUpdated(_minBorrowFraction);
    }

    /**
     * @notice used to update the reward fraction for liquidation of the Pool
     * @param _liquidatorRewardFraction updated value of the reward fraction for liquidation multiplied by 10**30
     */
    function updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) internal {
        liquidatorRewardFraction = _liquidatorRewardFraction;
        emit LiquidatorRewardFractionUpdated(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the pool cancel penalty multiple
     * @param _poolCancelPenaltyMultiple updated value of the pool cancel penalty multiple multiplied by 10**30
     */
    function updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) external onlyOwner {
        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);
    }

    function _updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) internal {
        poolCancelPenaltyMultiple = _poolCancelPenaltyMultiple;
        emit PoolCancelPenaltyMultipleUpdated(_poolCancelPenaltyMultiple);
    }

    /**
     * @notice used to update the fraction of borrowed amount charged as protocol fee
     * @param _protocolFee updated value of protocol fee fraction multiplied by 10**30
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the address in which protocol fee is collected
     * @param _protocolFeeCollector updated address of protocol fee collector
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the thresholds of the pool size of the Pool
     * @param _min updated value of the minimum threshold value of the pool size
     * @param _max updated value of the maximum threshold value of the pool size
     */
    function updatePoolSizeLimit(uint256 _min, uint256 _max) external onlyOwner {
        poolSizeLimit = Limits(_min, _max);
        emit LimitsUpdated('PoolSize', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the collateral ratio of the Pool
     * @param _min updated value of the minimum threshold value of the collateral ratio
     * @param _max updated value of the maximum threshold value of the collateral ratio
     */
    function updateidealCollateralRatioLimit(uint256 _min, uint256 _max) external onlyOwner {
        idealCollateralRatioLimit = Limits(_min, _max);
        emit LimitsUpdated('CollateralRatio', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the borrow rate of the Pool
     * @param _min updated value of the minimum threshold value of the borrow rate
     * @param _max updated value of the maximum threshold value of the borrow rate
     */
    function updateBorrowRateLimit(uint256 _min, uint256 _max) external onlyOwner {
        borrowRateLimit = Limits(_min, _max);
        emit LimitsUpdated('BorrowRate', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the repayment interval of the Pool
     * @param _min updated value of the minimum threshold value of the repayment interval
     * @param _max updated value of the maximum threshold value of the repayment interval
     */
    function updateRepaymentIntervalLimit(uint256 _min, uint256 _max) external onlyOwner {
        repaymentIntervalLimit = Limits(_min, _max);
        emit LimitsUpdated('RepaymentInterval', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the number of repayment intervals of the Pool
     * @param _min updated value of the minimum threshold value of the number of repayment intervals
     * @param _max updated value of the maximum threshold value of the number of repayment intervals
     */
    function updateNoOfRepaymentIntervalsLimit(uint256 _min, uint256 _max) external onlyOwner {
        noOfRepaymentIntervalsLimit = Limits(_min, _max);
        emit LimitsUpdated('NoOfRepaymentIntervals', _min, _max);
    }

    /**
     * @notice used to query protocol fee fraction and address of the collector
     * @return protocolFee Fraction multiplied by 10**30
     * @return address of protocol fee collector
     */
    function getProtocolFeeData() external view override returns (uint256, address) {
        return (protocolFeeFraction, protocolFeeCollector);
    }
}",6187,746,"[M-01] Ether can be locked in the PoolFactory contract without a way to retrieve it

If a borrower calls the createPool function with a non-zero value, but also includes an ERC20 token address for _collateralToken, then the Ether value sent will be locked in the PoolFactory contract forever.
createPool L260-317
In the _createPool function, a _collateralToken address other than the zero address will set the amount variable to zero. That amount variable will be passed to create2 which will send 0 wei to the newly created Pool contract.
``` // _createPool L349
uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;
```

",1,,"pragma solidity 0.7.6;

import '../Proxy.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/IPriceOracle.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';


contract PoolFactory is Initializable, OwnableUpgradeable, IPoolFactory {
    
    struct Limits {
        uint256 min;
        uint256 max;
    }

    
    bytes4 public poolInitFuncSelector; 

    
    address public poolImpl;

    
    address public override userRegistry;

    
    address public strategyRegistry;

    
    address public override extension;

    
    address public override repaymentImpl;

    
    address public override priceOracle;

    
    address public override savingsAccount;

    
    uint256 public override collectionPeriod;

    
    uint256 public override loanWithdrawalDuration;

    
    uint256 public override marginCallDuration;

    
    uint256 public override minBorrowFraction;

    
    uint256 public override liquidatorRewardFraction;

    
    uint256 public override poolCancelPenaltyMultiple;

    
    address public override noStrategyAddress;

    uint256 protocolFeeFraction;
    address protocolFeeCollector;

    
    mapping(address => bool) isBorrowToken;

    
    mapping(address => bool) isCollateralToken;

    
    mapping(address => bool) public override poolRegistry;

    
    Limits poolSizeLimit;

    
    Limits idealCollateralRatioLimit;

    
    Limits borrowRateLimit;

    
    Limits repaymentIntervalLimit;

    
    Limits noOfRepaymentIntervalsLimit;

    
    modifier onlyPool() {
        require(poolRegistry[msg.sender], 'PoolFactory::onlyPool - Only pool can destroy itself');
        _;
    }

    
    modifier onlyBorrower(address _verifier) {
        require(
            IVerification(userRegistry).isUser(msg.sender, _verifier),
            'PoolFactory::onlyBorrower - Only a valid Borrower can create Pool'
        );
        _;
    }

    
    function owner() public view override(IPoolFactory, OwnableUpgradeable) returns (address) {
        return OwnableUpgradeable.owner();
    }

    
    function initialize(
        address _admin,
        uint256 _collectionPeriod,
        uint256 _loanWithdrawalDuration,
        uint256 _marginCallDuration,
        bytes4 _poolInitFuncSelector,
        uint256 _liquidatorRewardFraction,
        uint256 _poolCancelPenaltyMultiple,
        uint256 _minBorrowFraction,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        address _noStrategy
    ) external initializer {
        {
            OwnableUpgradeable.__Ownable_init();
            OwnableUpgradeable.transferOwnership(_admin);
        }
        _updateCollectionPeriod(_collectionPeriod);
        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);
        _updateMarginCallDuration(_marginCallDuration);
        _updatepoolInitFuncSelector(_poolInitFuncSelector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);
        _updateMinBorrowFraction(_minBorrowFraction);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateNoStrategy(_noStrategy);
    }

    
    function setImplementations(
        address _poolImpl,
        address _repaymentImpl,
        address _userRegistry,
        address _strategyRegistry,
        address _priceOracle,
        address _savingsAccount,
        address _extension
    ) external onlyOwner {
        _updatePoolLogic(_poolImpl);
        _updateRepaymentImpl(_repaymentImpl);
        _updateSavingsAccount(_savingsAccount);
        _updatedExtension(_extension);
        _updateUserRegistry(_userRegistry);
        _updateStrategyRegistry(_strategyRegistry);
        _updatePriceoracle(_priceOracle);
    }

    
    function createPool(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        bytes32 _salt,
        address _verifier,
        address _lenderVerifier
    ) external payable onlyBorrower(_verifier) {
        if (_collateralToken == address(0)) {
            require(msg.value == _collateralAmount, 'PoolFactory::createPool - Ether send is different from collateral amount specified');
        }
        require(_borrowToken != _collateralToken, 'PoolFactory::createPool - cant borrow the asset put in as collateralToken');
        require(isBorrowToken[_borrowToken], 'PoolFactory::createPool - Invalid borrow token type');
        require(isCollateralToken[_collateralToken], 'PoolFactory::createPool - Invalid collateral token type');
        require(
            IPriceOracle(priceOracle).doesFeedExist(_collateralToken, _borrowToken),
            ""PoolFactory::createPool - Price feed doesn't support token pair""
        );
        require(IStrategyRegistry(strategyRegistry).registry(_poolSavingsStrategy), 'PoolFactory::createPool - Invalid strategy');
        require(isWithinLimits(_poolSize, poolSizeLimit.min, poolSizeLimit.max), 'PoolFactory::createPool - PoolSize not within limits');
        require(
            isWithinLimits(_idealCollateralRatio, idealCollateralRatioLimit.min, idealCollateralRatioLimit.max),
            'PoolFactory::createPool - Collateral Ratio not within limits'
        );
        require(
            isWithinLimits(_borrowRate, borrowRateLimit.min, borrowRateLimit.max),
            'PoolFactory::createPool - Borrow rate not within limits'
        );
        require(
            isWithinLimits(_noOfRepaymentIntervals, noOfRepaymentIntervalsLimit.min, noOfRepaymentIntervalsLimit.max),
            'PoolFactory::createPool - Loan duration not within limits'
        );
        require(
            isWithinLimits(_repaymentInterval, repaymentIntervalLimit.min, repaymentIntervalLimit.max),
            'PoolFactory::createPool - Repayment interval not within limits'
        );
        _createPool(
            _poolSize,
            _borrowRate,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _salt,
            _lenderVerifier
        );
    }

    
    function _createPool(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        bytes32 _salt,
        address _lenderVerifier
    ) internal {
        bytes memory data = _encodePoolInitCall(
            _poolSize,
            _borrowRate,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _lenderVerifier
        );
        bytes32 salt = keccak256(abi.encodePacked(_salt, msg.sender));
        bytes memory bytecode = abi.encodePacked(type(SublimeProxy).creationCode, abi.encode(poolImpl, address(0x01), data));
        uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;

        address pool = _deploy(amount, salt, bytecode);

        poolRegistry[pool] = true;
        emit PoolCreated(pool, msg.sender);
    }

    
    function _encodePoolInitCall(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier
    ) internal view returns (bytes memory data) {
        data = abi.encodeWithSelector(
            poolInitFuncSelector,
            _poolSize,
            _borrowRate,
            msg.sender,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _lenderVerifier,
            loanWithdrawalDuration,
            collectionPeriod
        );
    }

    
    function _deploy(
        uint256 amount,
        bytes32 salt,
        bytes memory bytecode
    ) internal returns (address addr) {
        require(bytecode.length != 0, 'Create2: bytecode length is zero');
        
        assembly {
            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)
        }
        require(addr != address(0), 'Create2: Failed on deploy');
    }

    
    function isWithinLimits(
        uint256 _value,
        uint256 _min,
        uint256 _max
    ) internal pure returns (bool) {
        if (_min != 0 && _max != 0) {
            return (_value >= _min && _value <= _max);
        } else if (_min != 0) {
            return (_value >= _min);
        } else if (_max != 0) {
            return (_value <= _max);
        } else {
            return true;
        }
    }

    
    function updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) external onlyOwner {
        _updateSupportedBorrowTokens(_borrowToken, _isSupported);
    }

    function _updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) internal {
        isBorrowToken[_borrowToken] = _isSupported;
        emit BorrowTokenUpdated(_borrowToken, _isSupported);
    }

    
    function updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) external onlyOwner {
        _updateSupportedCollateralTokens(_collateralToken, _isSupported);
    }

    function _updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) internal {
        isCollateralToken[_collateralToken] = _isSupported;
        emit CollateralTokenUpdated(_collateralToken, _isSupported);
    }

    
    function updatepoolInitFuncSelector(bytes4 _functionId) external onlyOwner {
        _updatepoolInitFuncSelector(_functionId);
    }

    function _updatepoolInitFuncSelector(bytes4 _functionId) internal {
        poolInitFuncSelector = _functionId;
        emit PoolInitSelectorUpdated(_functionId);
    }

    
    function updatePoolLogic(address _poolLogic) external onlyOwner {
        _updatePoolLogic(_poolLogic);
    }

    function _updatePoolLogic(address _poolLogic) internal {
        poolImpl = _poolLogic;
        emit PoolLogicUpdated(_poolLogic);
    }

    
    function updateUserRegistry(address _userRegistry) external onlyOwner {
        _updateUserRegistry(_userRegistry);
    }

    function _updateUserRegistry(address _userRegistry) internal {
        userRegistry = _userRegistry;
        emit UserRegistryUpdated(_userRegistry);
    }

    
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    
    function updateRepaymentImpl(address _repaymentImpl) external onlyOwner {
        _updateRepaymentImpl(_repaymentImpl);
    }

    function _updateRepaymentImpl(address _repaymentImpl) internal {
        repaymentImpl = _repaymentImpl;
        emit RepaymentImplUpdated(_repaymentImpl);
    }

    
    function updateNoStrategy(address _noStrategy) external onlyOwner {
        _updateNoStrategy(_noStrategy);
    }

    function _updateNoStrategy(address _noStrategy) internal {
        noStrategyAddress = _noStrategy;
        emit NoStrategyUpdated(_noStrategy);
    }

    
    function updatePriceoracle(address _priceOracle) external onlyOwner {
        _updatePriceoracle(_priceOracle);
    }

    function _updatePriceoracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    
    function updatedExtension(address _extension) external onlyOwner {
        _updatedExtension(_extension);
    }

    function _updatedExtension(address _extension) internal {
        extension = _extension;
        emit ExtensionImplUpdated(_extension);
    }

    
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    
    function updateCollectionPeriod(uint256 _collectionPeriod) external onlyOwner {
        _updateCollectionPeriod(_collectionPeriod);
    }

    function _updateCollectionPeriod(uint256 _collectionPeriod) internal {
        collectionPeriod = _collectionPeriod;
        emit CollectionPeriodUpdated(_collectionPeriod);
    }

    
    function updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) external onlyOwner {
        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);
    }

    function _updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) internal {
        loanWithdrawalDuration = _loanWithdrawalDuration;
        emit LoanWithdrawalDurationUpdated(_loanWithdrawalDuration);
    }

    
    function updateMarginCallDuration(uint256 _marginCallDuration) external onlyOwner {
        _updateMarginCallDuration(_marginCallDuration);
    }

    function _updateMarginCallDuration(uint256 _marginCallDuration) internal {
        marginCallDuration = _marginCallDuration;
        emit MarginCallDurationUpdated(_marginCallDuration);
    }

    
    function updateMinBorrowFraction(uint256 _minBorrowFraction) external onlyOwner {
        _updateMinBorrowFraction(_minBorrowFraction);
    }

    function _updateMinBorrowFraction(uint256 _minBorrowFraction) internal {
        minBorrowFraction = _minBorrowFraction;
        emit MinBorrowFractionUpdated(_minBorrowFraction);
    }

    
    function updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) internal {
        liquidatorRewardFraction = _liquidatorRewardFraction;
        emit LiquidatorRewardFractionUpdated(_liquidatorRewardFraction);
    }

    
    function updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) external onlyOwner {
        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);
    }

    function _updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) internal {
        poolCancelPenaltyMultiple = _poolCancelPenaltyMultiple;
        emit PoolCancelPenaltyMultipleUpdated(_poolCancelPenaltyMultiple);
    }

    
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    
    function updatePoolSizeLimit(uint256 _min, uint256 _max) external onlyOwner {
        poolSizeLimit = Limits(_min, _max);
        emit LimitsUpdated('PoolSize', _min, _max);
    }

    
    function updateidealCollateralRatioLimit(uint256 _min, uint256 _max) external onlyOwner {
        idealCollateralRatioLimit = Limits(_min, _max);
        emit LimitsUpdated('CollateralRatio', _min, _max);
    }

    
    function updateBorrowRateLimit(uint256 _min, uint256 _max) external onlyOwner {
        borrowRateLimit = Limits(_min, _max);
        emit LimitsUpdated('BorrowRate', _min, _max);
    }

    
    function updateRepaymentIntervalLimit(uint256 _min, uint256 _max) external onlyOwner {
        repaymentIntervalLimit = Limits(_min, _max);
        emit LimitsUpdated('RepaymentInterval', _min, _max);
    }

    
    function updateNoOfRepaymentIntervalsLimit(uint256 _min, uint256 _max) external onlyOwner {
        noOfRepaymentIntervalsLimit = Limits(_min, _max);
        emit LimitsUpdated('NoOfRepaymentIntervals', _min, _max);
    }

    
    function getProtocolFeeData() external view override returns (uint256, address) {
        return (protocolFeeFraction, protocolFeeCollector);
    }
}",3731,0,1,"{
  ""task_list"": [
    {
      ""Area"": ""CREATE2 Deployment and Predictable Addresses"",
      ""Tasks"": [
        ""Verify that the `SublimeProxy` contract's creation code is correct and secure."",
        ""Analyze the salt generation mechanism (`keccak256(abi.encodePacked(_salt, msg.sender))`) to ensure uniqueness and prevent address collisions. Test with various `_salt` values and multiple calls from the same `msg.sender`."",
        ""Confirm that the `poolImpl` address is a trusted and thoroughly audited contract."",
        ""Investigate why address(0x01) is hardcoded within the proxy deployment logic. This is non-standard and may indicate an issue."",
        ""Simulate pool deployments with different parameters to ensure the CREATE2 address calculation is accurate and predictable off-chain.""
      ]
    },
    {
      ""Area"": ""Initialization Logic and Upgradeability"",
      ""Tasks"": [
        ""Ensure the `initialize` function can only be called once using the `Initializer` contract from OpenZeppelin. Verify that re-initialization is impossible after deployment."",
        ""Examine the access control mechanisms for the `setImplementations` function. Confirm that only the owner can set the addresses of the implementation contracts."",
        ""Audit the upgrade process to ensure a malicious owner cannot upgrade to a vulnerable implementation. Consider potential state variable clashing during upgrades."",
        ""Verify that all critical parameters are properly initialized in the `initialize` function and that there are no uninitialized state variables that could lead to unexpected behavior."",
        ""Analyze the functions that update crucial addresses (e.g., `poolImpl`, `userRegistry`, `priceOracle`) to ensure these updates are carefully controlled and audited.""
      ]
    },
    {
      ""Area"": ""Input Validation and Limits"",
      ""Tasks"": [
        ""Thoroughly test the `isWithinLimits` function with various boundary and edge cases to ensure it functions correctly and prevents unintended values."",
        ""Verify that all limit parameters (pool size, collateral ratio, borrow rate, repayment intervals) are enforced correctly and prevent the creation of pools with undesirable characteristics."",
        ""Confirm that the `_collateralAmount` is correctly handled when `_collateralToken` is address(0) (ETH). Check for potential rounding errors or unexpected behavior."",
        ""Test the interaction between the `_transferFromSavingsAccount` flag and the collateral transfer logic. Ensure funds are transferred correctly and only when authorized."",
        ""Check for potential integer overflows or underflows in calculations involving `_poolSize`, `_borrowRate`, `_collateralAmount`, and other input parameters.""
      ]
    },
    {
      ""Area"": ""Token Whitelisting and Price Oracle Integrity"",
      ""Tasks"": [
        ""Ensure that the `isBorrowToken` and `isCollateralToken` mappings are properly maintained and that only whitelisted tokens can be used in pool creation. Prevent potential attacks with malicious or low-liquidity tokens."",
        ""Verify that the `IPriceOracle(priceOracle).doesFeedExist(_collateralToken, _borrowToken)` call is implemented correctly and that the price feed is reliable and resistant to manipulation."",
        ""Investigate the potential impact of stale or inaccurate price data from the price oracle on pool health and liquidation mechanisms."",
        ""Consider implementing circuit breakers or safeguards to mitigate risks associated with price oracle failures or attacks."",
        ""Analyze the potential for front-running attacks on the `createPool` function based on price oracle updates.""
      ]
    },
    {
      ""Area"": ""Access Control and Authorization"",
      ""Tasks"": [
        ""Audit the `onlyBorrower` modifier to ensure that the `IVerification(userRegistry).isUser()` call correctly verifies the borrower's identity and authorization."",
        ""Investigate the potential for unauthorized pool creation by manipulating the `_verifier` address or exploiting vulnerabilities in the `userRegistry` contract."",
        ""Verify that the `onlyPool` modifier is correctly implemented and prevents unauthorized access to sensitive pool functions."",
        ""Review the ownership transfer mechanism to ensure it is secure and cannot be exploited to gain unauthorized control of the PoolFactory contract."",
        ""Confirm that only the owner can update critical parameters and implementation addresses.""
      ]
    },
    {
      ""Area"": ""Fee Collection and Protocol Revenue"",
      ""Tasks"": [
        ""Verify the calculation and distribution of protocol fees based on the `protocolFeeFraction` parameter."",
        ""Ensure that the `protocolFeeCollector` address is a trusted and well-managed address."",
        ""Analyze the potential for fee manipulation or theft."",
        ""Investigate the accounting and reporting mechanisms for protocol revenue."",
        ""Consider adding safeguards to prevent excessive or unexpected fee collection.""
      ]
    },
    {
      ""Area"": ""External Interactions and Dependencies"",
      ""Tasks"": [
        ""Thoroughly audit all external contract calls to `IPool`, `IVerification`, `IPriceOracle`, `IStrategyRegistry`, `IRepayment`, and other external contracts to identify potential vulnerabilities or dependencies on untrusted code."",
        ""Analyze the potential impact of changes or upgrades to the external contracts on the functionality and security of the PoolFactory contract."",
        ""Implement robust error handling and fallback mechanisms to mitigate risks associated with external contract failures or attacks."",
        ""Verify that the interfaces for external contracts are correctly defined and that the expected behavior is enforced."",
        ""Investigate the potential for reentrancy attacks through external contract calls.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code represents a PoolFactory contract responsible for deploying and managing lending pools. It uses the Create2 opcode to deploy pools with predictable addresses. The contract implements an upgradeable pattern and manages various parameters related to pool creation and operation, including fees, limits, and whitelisting of tokens."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""PoolFactory"",
    ""Purpose"": ""Factory contract for deploying lending pools using CREATE2 with a proxy pattern. Manages pool parameters, token whitelisting, and fee collection."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Initializable"", ""OwnableUpgradeable"", ""IPoolFactory""],
      ""Imports"": [
        ""../Proxy.sol"",
        ""../interfaces/IPoolFactory.sol"",
        ""../interfaces/IPool.sol"",
        ""../interfaces/IVerification.sol"",
        ""../interfaces/IStrategyRegistry.sol"",
        ""../interfaces/IRepayment.sol"",
        ""../interfaces/IPriceOracle.sol"",
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""poolInitFuncSelector"",
        ""Type"": ""bytes4"",
        ""Purpose"": ""Function selector used when initializing a new pool""
      },
      {
        ""Name"": ""poolImpl"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the pool implementation contract""
      },
      {
        ""Name"": ""userRegistry"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the user registry contract""
      },
      {
        ""Name"": ""strategyRegistry"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the strategy registry contract""
      },
      {
        ""Name"": ""extension"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the extension contract""
      },
      {
        ""Name"": ""repaymentImpl"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the repayment implementation contract""
      },
      {
        ""Name"": ""priceOracle"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the price oracle contract""
      },
      {
        ""Name"": ""savingsAccount"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the savings account contract""
      },
      {
        ""Name"": ""collectionPeriod"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration of the collection period""
      },
      {
        ""Name"": ""loanWithdrawalDuration"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration for loan withdrawal""
      },
      {
        ""Name"": ""marginCallDuration"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration for margin call""
      },
      {
        ""Name"": ""minBorrowFraction"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Minimum fraction for borrowing""
      },
      {
        ""Name"": ""liquidatorRewardFraction"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Fraction of reward for liquidators""
      },
      {
        ""Name"": ""poolCancelPenaltyMultiple"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Multiple for pool cancellation penalty""
      },
      {
        ""Name"": ""noStrategyAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address for no strategy""
      },
      {
        ""Name"": ""protocolFeeFraction"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Fraction of fees taken as protocol fee""
      },
      {
        ""Name"": ""protocolFeeCollector"",
        ""Type"": ""address"",
        ""Purpose"": ""Address where protocol fees are collected""
      },
      {
        ""Name"": ""isBorrowToken"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Mapping to check if a token is a supported borrow token""
      },
      {
        ""Name"": ""isCollateralToken"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Mapping to check if a token is a supported collateral token""
      },
      {
        ""Name"": ""poolRegistry"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Mapping to register created pools""
      },
      {
        ""Name"": ""poolSizeLimit"",
        ""Type"": ""Limits"",
        ""Purpose"": ""Limits for pool size""
      },
      {
        ""Name"": ""idealCollateralRatioLimit"",
        ""Type"": ""Limits"",
        ""Purpose"": ""Limits for ideal collateral ratio""
      },
      {
        ""Name"": ""borrowRateLimit"",
        ""Type"": ""Limits"",
        ""Purpose"": ""Limits for borrow rate""
      },
      {
        ""Name"": ""repaymentIntervalLimit"",
        ""Type"": ""Limits"",
        ""Purpose"": ""Limits for repayment interval""
      },
      {
        ""Name"": ""noOfRepaymentIntervalsLimit"",
        ""Type"": ""Limits"",
        ""Purpose"": ""Limits for number of repayment intervals""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract, setting admin and various parameters."",
        ""Parameters"": [
          ""_admin"",
          ""_collectionPeriod"",
          ""_loanWithdrawalDuration"",
          ""_marginCallDuration"",
          ""_poolInitFuncSelector"",
          ""_liquidatorRewardFraction"",
          ""_poolCancelPenaltyMultiple"",
          ""_minBorrowFraction"",
          ""_protocolFeeFraction"",
          ""_protocolFeeCollector"",
          ""_noStrategy""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setImplementations"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets addresses for various implementation contracts."",
        ""Parameters"": [
          ""_poolImpl"",
          ""_repaymentImpl"",
          ""_userRegistry"",
          ""_strategyRegistry"",
          ""_priceOracle"",
          ""_savingsAccount"",
          ""_extension""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""createPool"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates a new pool using CREATE2."",
        ""Parameters"": [
          ""_poolSize"",
          ""_borrowRate"",
          ""_borrowToken"",
          ""_collateralToken"",
          ""_idealCollateralRatio"",
          ""_repaymentInterval"",
          ""_noOfRepaymentIntervals"",
          ""_poolSavingsStrategy"",
          ""_collateralAmount"",
          ""_transferFromSavingsAccount"",
          ""_salt"",
          ""_verifier"",
          ""_lenderVerifier""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_createPool"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to create the pool. Encodes initialization data and deploys proxy using Create2"",
        ""Parameters"": [
          ""_poolSize"",
          ""_borrowRate"",
          ""_borrowToken"",
          ""_collateralToken"",
          ""_idealCollateralRatio"",
          ""_repaymentInterval"",
          ""_noOfRepaymentIntervals"",
          ""_poolSavingsStrategy"",
          ""_collateralAmount"",
          ""_transferFromSavingsAccount"",
          ""_salt"",
          ""_lenderVerifier""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyPool"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Modifier to restrict function calls to registered pools.""
      },
      {
        ""Name"": ""onlyBorrower"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Modifier to restrict function calls to valid borrowers.""
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IPoolFactory"",
    ""IVerification(userRegistry).isUser()"",
    ""IPriceOracle(priceOracle).doesFeedExist()"",
    ""IStrategyRegistry(strategyRegistry).registry()"",
    ""IPool"",
    ""IRepayment""
  ],
  ""SpecialMechanisms"": [
    ""CREATE2 deployment for predictable pool addresses."",
    ""Proxy pattern using 'SublimeProxy' for upgradeability."",
    ""Upgradeable contract using OpenZeppelin's OwnableUpgradeable and Initializable."",
    ""Token whitelisting for borrow and collateral tokens."",
    ""Limits on various pool parameters (size, collateral ratio, borrow rate, repayment intervals).""
  ],
  ""Questions"": [
    ""What is the purpose of the `SublimeProxy` contract, and why is address(0x01) used in its initialization?  This seems unusual."",
    ""What validation occurs within the `IPool` contract's initialization function (referenced by `poolInitFuncSelector`)?  Understanding this is crucial for security."",
    ""How is the `_salt` value used in the `_createPool` function to derive unique pool addresses and prevent potential collisions?"",
    ""What are the specific security considerations related to the upgradeable nature of the contract and the potential for malicious upgrades?"",
    ""Is there a mechanism to prevent the same borrower from creating multiple pools with overlapping terms using the same collateral?  This could lead to vulnerabilities.""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Unprotected `_deploy` function"",
      ""Severity"": ""High"",
      ""Description"": ""The `_deploy` function uses inline assembly with `create2` to deploy new contracts. There is no access control on this function. Improper use in other internal functions which call `_deploy` could lead to unexpected contract deployment and potentially severe security risks if the salt and bytecode are not carefully controlled. Specifically, incorrect bytecode could lead to vulnerabilities in the deployed contract. Malicious bytecode could lead to arbitrary code execution within the proxy\'s context, allowing for bypassing the upgradeability pattern and taking control of the contract\'s state and logic."",
      ""Impact"": ""Potential deployment of malicious contracts, severe compromise of PoolFactory\'s functionality, denial of service, potential for theft of funds."",
      ""Location"": ""PoolFactory.sol:286, _deploy function""
    },
    {
      ""Issue"": ""Centralized Control: Missing Access Control for Critical Parameters and Reliance on External Contracts"",
      ""Severity"": ""High"",
      ""Description"": ""The contract relies heavily on the owner for critical configurations and updates, such as updating implementation addresses (poolImpl, repaymentImpl, userRegistry, strategyRegistry, priceOracle, savingsAccount, extension, noStrategyAddress), collectionPeriod, loanWithdrawalDuration, marginCallDuration, liquidatorRewardFraction, poolCancelPenaltyMultiple, minBorrowFraction, protocolFeeFraction, protocolFeeCollector, poolSizeLimit, idealCollateralRatioLimit, borrowRateLimit, repaymentIntervalLimit, noOfRepaymentIntervalsLimit, and supported tokens.  Additionally, the contract relies heavily on external contracts for crucial functionalities. A compromised or malicious owner can arbitrarily change parameters, potentially disrupting the entire lending platform’s functionality, causing financial losses to users, or manipulating the system for personal gain."",
      ""Impact"": ""Potential for rug pulls, manipulation of protocol parameters, and loss of user funds if the owner is malicious or compromised. Complete compromise of the system, including loss of funds, incorrect liquidations, and unauthorized actions."",
      ""Location"": ""Functions starting with `update...`, e.g., `updateCollectionPeriod`, `updateLoanWithdrawalDuration`, `updatePoolLogic`, `updateUserRegistry`, etc., All interactions with external contracts""
    },
    {
      ""Issue"": ""Potential Re-entrancy Vulnerability in Pool Contract Creation (Proxy Pattern)"",
      ""Severity"": ""High"",
      ""Description"": ""The contract deploys pools using `SublimeProxy` and initializes them using a delegatecall. If the `poolImpl` contract contains external calls that can potentially trigger a re-entrancy, then the PoolFactory and the deployed pools are vulnerable. The Pool implementation could potentially manipulate state or call back into the factory during initialization before the pool address is added to `poolRegistry`, creating unexpected side effects. It is possible to bypass the `onlyPool` modifier with this attack vector."",
      ""Impact"": ""A malicious borrower could exploit a re-entrancy vulnerability in the pool logic to drain funds or manipulate the pool's state. The state of the PoolFactory could be modified during the pool creation process through a reentrant call, possibly leading to the bypass of security checks or the incorrect initialization of the pool."",
      ""Location"": ""`_createPool` function, `_deploy` function, Pool’s logic itself (`poolImpl` contract). Also the `_encodePoolInitCall`""
    },
    {
      ""Issue"": ""Unchecked Return Value of `create2` Operation"",
      ""Severity"": ""High"",
      ""Description"": ""The `_deploy` function uses the `create2` opcode to deploy a new contract. While there is a check `require(addr != address(0), \'Create2: Failed on deploy\');`, the underlying assembly code could still fail due to out-of-gas errors or other reasons. The calling function `_createPool` doesn't handle this potential failure, leaving the caller unaware of the specific cause."",
      ""Impact"": ""Pool creation can fail silently if the `create2` operation fails."",
      ""Location"": ""Function: `_deploy`""
    },
    {
      ""Issue"": ""Missing Zero Address Check for Critical Addresses in `setImplementations`"",
      ""Severity"": ""High"",
      ""Description"": ""The `setImplementations` function allows the owner to set crucial contract addresses, including `_poolImpl`, `_repaymentImpl`, `_userRegistry`, `_strategyRegistry`, `_priceOracle`, `_savingsAccount`, and `_extension`, and `noStrategyAddress`. There are no checks to ensure that these addresses are not set to the zero address (address(0)). Setting any of these addresses to zero would likely break the contract's functionality and potentially render it unusable."",
      ""Impact"": ""Setting critical contract addresses to zero could render the PoolFactory and dependent pools unusable. This could lead to a complete loss of functionality and potentially locked funds, effectively bricking the pool factory."",
      ""Location"": ""Function `setImplementations`, _updatePoolLogic, _updateRepaymentImpl, _updateUserRegistry, _updateStrategyRegistry, _updatePriceoracle, _updateSavingsAccount, _updatedExtension, _updateNoStrategy""
    },
    {
      ""Issue"": ""Missing Input Validation for `_salt` in `createPool` and Predictable Salt Generation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `createPool` function takes a `_salt` parameter without validation. A malicious user can predict `msg.sender` and potentially predict the CREATE2 address. The contract uses `keccak256(abi.encodePacked(_salt, msg.sender))` as the salt for `CREATE2`.  While the `_salt` parameter itself is a user-provided input, the `msg.sender` makes the salt predictable for a given borrower and pool creation configuration. This could allow for front-running attacks and replay attacks."",
      ""Impact"": ""Predictable pool address, potential for denial-of-service or malicious pre-deployment, potential vulnerability if pool address predictability can be exploited by an attacker, replay attacks on pool creation."",
      ""Location"": ""PoolFactory.sol:262, Function: `_createPool`""
    },
    {
      ""Issue"": ""Missing Input Validation in `_createPool` function and Limits Update Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_createPool` function, which is called internally by `createPool`, doesn't perform any checks on the input parameters.  The functions `updatePoolSizeLimit`, `updateidealCollateralRatioLimit`, `updateBorrowRateLimit`, `updateRepaymentIntervalLimit`, and `updateNoOfRepaymentIntervalsLimit` allow the owner to set minimum and maximum values for various pool parameters. However, there is no check to ensure that `_min` is less than or equal to `_max`."",
      ""Impact"": ""Potential deployment of pools with invalid configurations if `_createPool` is ever called internally with bad values. Could potentially lead to DoS, could lead to denial of service if `_min` > `_max`, as pool creation would always fail."",
      ""Location"": ""_createPool function, Functions: `updatePoolSizeLimit`, `updateidealCollateralRatioLimit`, `updateBorrowRateLimit`, `updateRepaymentIntervalLimit`, `updateNoOfRepaymentIntervalsLimit`""
    },
    {
      ""Issue"": ""Lack of Access Control on Protocol Fee Parameters and Critical Parameter Update Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `updateProtocolFeeFraction` and `updateProtocolFeeCollector` functions allow the owner to modify the protocol fee fraction and the address that collects the fees.  Several functions are marked with `onlyOwner` modifier which restricts access to the owner. However, careful consideration should be given to whether these parameters should be updatable at all, or if more granular access control is needed. Updating `minBorrowFraction` or `liquidatorRewardFraction` could have significant financial implications."",
      ""Impact"": ""Setting an unreasonably high protocol fee could deter users from using the platform. A malicious owner could set an extremely high fee and drain funds, incorrect parameter updates by the owner can lead to financial losses or unexpected behavior."",
      ""Location"": ""Functions `updateProtocolFeeFraction`, `updateProtocolFeeCollector`, Functions: `updateCollectionPeriod`, `updateLoanWithdrawalDuration`, `updateMarginCallDuration`, `updateMinBorrowFraction`, `updateLiquidatorRewardFraction`, `updatePoolCancelPenaltyMultiple`, `updateProtocolFeeFraction`, `updateProtocolFeeCollector`, etc.""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `createPool`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `createPool` function checks if the `msg.value` matches `_collateralAmount` when `_collateralToken` is ETH. An attacker can monitor the mempool, observe a legitimate `createPool` transaction, and submit their own transaction with a slightly higher gas price. If the attacker's transaction is executed first, it could potentially drain funds if the amount and other parameters are manipulated to benefit the attacker."",
      ""Impact"": ""Potential loss of funds for legitimate users attempting to create pools."",
      ""Location"": ""`createPool` function""
    },
    {
      ""Issue"": ""Reliance on External Contracts and Potential for Malicious Implementations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies heavily on external contracts for crucial functionalities, including `IVerification`, `IStrategyRegistry`, `IPriceOracle`, `IPool`, and `IRepayment`. The addresses of these contracts are set by the owner. If the owner sets the address of a malicious contract, it could compromise the entire system. It depends on the correct validation from those contracts."",
      ""Impact"": ""Complete compromise of the system, including loss of funds, incorrect liquidations, and unauthorized actions."",
      ""Location"": ""All interactions with external contracts""
    },
    {
      ""Issue"": ""Missing Input Validation for Admin Address in `initialize` Function and Potential Replay Attack on Proxy Initialization"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `initialize` function takes an `_admin` address as input and transfers ownership to this address. However, there is no check to ensure that `_admin` is not the zero address. If `_admin` is the zero address, the contract will be effectively un-owned, leading to potential security risks. The contract uses an upgradeable proxy pattern. The `initialize` function is used to initialize the contract's state. If the proxy is not correctly initialized, it might be possible to call the `initialize` function again, leading to unexpected behavior."",
      ""Impact"": ""Contract can become un-owned if the admin address is set to zero during initialization. Contract state can be corrupted if the initialization function is called more than once."",
      ""Location"": ""Function: `initialize`, Modifier: `initializer` (defined in base contracts)""
    },
    {
      ""Issue"": ""Missing Checks on Implementation Addresses"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setImplementations` function allows the owner to set addresses for various implementation contracts (`poolImpl`, `repaymentImpl`, `userRegistry`, `strategyRegistry`, `priceOracle`, `savingsAccount`, `extension`). There are no checks to ensure that these addresses are actually contracts, or that they implement the expected interfaces. Setting an invalid address could break the contract."",
      ""Impact"": ""Contract functionality can be broken if implementation addresses are set to invalid values."",
      ""Location"": ""Function: `setImplementations`""
    },
    {
      ""Issue"": ""No emergency stop/circuit breaker"",
      ""Severity"": ""Medium"",
      ""Description"": ""There is no mechanism to pause the contract or stop pool creation in case of a critical vulnerability or exploit being discovered. This leaves the protocol vulnerable to ongoing attacks until the owner can manually intervene and update the relevant implementations."",
      ""Impact"": ""Prolonged exposure to exploits and potential for significant losses."",
      ""Location"": ""Overall contract structure""
    },
    {
      ""Issue"": ""Lack of Access Control on Pool Deletion/Closure"",
      ""Severity"": ""Medium"",
      ""Description"": ""While the `onlyPool` modifier restricts the caller to be a registered pool, the contract doesn't explicitly include a function to allow a pool to close or self-destruct. If the intention is to allow pools to eventually close/destroy themselves, a function with the `onlyPool` modifier should be present to handle this and appropriately handle balances, repayments and collateral. Also, no mechanism to deregister pool is present in the factory, therefore, the pool remains registered even after being destroyed via selfdestruct. The factory still considers the destroyed address a valid pool."",
      ""Impact"": ""Potentially, pools become perpetual and cannot be closed down gracefully, which would require intervention from the owner to manage abandoned pools.Unexpected pool self-destruction could disrupt the lending platform\'s operations and potentially result in financial losses for lenders and borrowers."",
      ""Location"": ""Absence of a 'closePool' or similar function, `onlyPool` modifier""
    },
    {
      ""Issue"": ""Lack of Upper Bound on Duration Parameters and Fractions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions `updateCollectionPeriod`, `updateLoanWithdrawalDuration`, and `updateMarginCallDuration` lack a maximum value. Setting very large values could lead to unexpected behavior or denial-of-service conditions. The `updateProtocolFeeFraction`, `updateLiquidatorRewardFraction`, and `updateMinBorrowFraction` functions allow the owner to set fractions. There is no check to ensure that these values are less than or equal to a reasonable maximum value. Setting extremely high values for these fractions could lead to unexpected behavior or even render the protocol unusable."",
      ""Impact"": ""Potential denial-of-service or unexpected contract behavior due to excessively long duration parameters. Setting an extremely high value for protocolFeeFraction, liquidatorRewardFraction, or minBorrowFraction could lead to unexpected behavior in calculations or prevent legitimate operations from being performed."",
      ""Location"": ""Functions `updateCollectionPeriod`, `updateLoanWithdrawalDuration`, `updateMarginCallDuration`, Functions: `updateProtocolFeeFraction`, `updateLiquidatorRewardFraction`, `updateMinBorrowFraction`""
    },
    {
      ""Issue"": ""Missing Input Validation for Critical Parameters"",
      ""Severity"": ""Medium"",
      ""Description"": ""While limits are enforced on some parameters like `poolSize`, `idealCollateralRatio`, `borrowRate`, `repaymentInterval`, and `noOfRepaymentIntervals`, there is a lack of validation on other critical parameters such as `_liquidatorRewardFraction`, `_poolCancelPenaltyMultiple`, `_minBorrowFraction`, and `_protocolFeeFraction`. These parameters, if set to extreme values, could significantly harm the protocol."",
      ""Impact"": ""Potential for protocol malfunction, unfair liquidations, and manipulation of fees."",
      ""Location"": ""`initialize` and the corresponding `_update...` functions""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `_encodePoolInitCall` when calculating the ABI encoded `data`, and Potential Integer Overflow/Underflow in Limit Checks"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `_encodePoolInitCall` uses `abi.encodeWithSelector` to encode the initialization parameters of the pool. If the parameters `_poolSize`, `_borrowRate`, `_collateralAmount`, `loanWithdrawalDuration` and `collectionPeriod` are sufficiently large, their combined size could lead to an integer overflow during the ABI encoding process, leading to unexpected values being passed during the pool initialization. The `isWithinLimits` function checks if a value is within a specified range. If the `_min` or `_max` values are close to the boundaries of the `uint256` type, and the `_value` is also close to the boundary, there is a potential risk of integer overflow or underflow during the comparison, leading to incorrect results. The code is using solidity 0.7.6."",
      ""Impact"": ""Potential incorrect initialization of pool parameters due to integer overflow in ABI encoding, Incorrect limit checks could allow values outside the intended range, leading to unexpected behavior and potential vulnerabilities, Unexpected behaviour can arise if calculations lead to integer overflow/underflow."",
      ""Location"": ""PoolFactory.sol:270-290, `isWithinLimits` function, Multiple locations involving arithmetic operations""
    },
    {
      ""Issue"": ""Unbounded loops within `isWithinLimits` function could lead to unexpected behavior"",
      ""Severity"": ""Low"",
      ""Description"": ""The `isWithinLimits` function checks if a value is within a specified range defined by `_min` and `_max`. It consists of a series of if/else if/else statements. If none of the conditional statements is met, it will return true, which might not be the intended behavior. This situation occurs when both `_min` and `_max` are set to 0, which can be considered a potential logical issue."",
      ""Impact"": ""Potential for unexpected behavior, bypass of intended limits if `_min` and `_max` are both set to 0"",
      ""Location"": ""PoolFactory.sol:303-315""
    },
    {
      ""Issue"": ""Inconsistent Use of `override` Keyword"",
      ""Severity"": ""Low"",
      ""Description"": ""The `owner()` function is correctly overridden, however, other public state variables also defined in interfaces are not explicitly declared as `override` in the contract, despite being defined in the implemented interfaces. This inconsistency reduces code clarity and maintainability."",
      ""Impact"": ""Reduced code clarity and potential confusion for developers maintaining the contract."",
      ""Location"": ""Declaration of public state variables""
    },
    {
      ""Issue"": ""Inconsistent Naming Convention in Events for Limits Updates"",
      ""Severity"": ""Low"",
      ""Description"": ""The event emitted when updating limits for various parameters (PoolSize, CollateralRatio, BorrowRate, RepaymentInterval, NoOfRepaymentIntervals) is generically named `LimitsUpdated`. This makes it difficult to filter logs for specific limit updates."",
      ""Impact"": ""Reduced clarity and increased difficulty in monitoring and debugging limit updates."",
      ""Location"": ""Functions: `updatePoolSizeLimit`, `updateidealCollateralRatioLimit`, `updateBorrowRateLimit`, `updateRepaymentIntervalLimit`, `updateNoOfRepaymentIntervalsLimit`""
    },
    {
      ""Issue"": ""Magic Number Usage in SublimeProxy Creation"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_createPool` function includes the magic number `0x01` in the bytecode for the `SublimeProxy` creation. It is not obvious what this value represents or why it is hardcoded. It should be replaced with a named constant or explained via comments."",
      ""Impact"": ""Reduced code readability and maintainability."",
      ""Location"": ""Function: `_createPool`""
    }
  ],
  ""IssueNumber"": 40,
  ""OutputList"": 18
}",176.7545461654663,3563.0,29.0,"### **[M-01] Ether can be locked in the PoolFactory contract without a way to retrieve it**

**Report Description**:
If a borrower calls the `createPool` function with a non-zero value but includes an ERC20 token address for `_collateralToken`, the Ether value sent will be locked in the `PoolFactory` contract forever. In the `_createPool` function, a `_collateralToken` address other than the zero address will set the `amount` variable to zero. This `amount` variable is passed to `create2`, which sends 0 wei to the newly created `Pool` contract. As a result, the Ether sent by the borrower remains in the `PoolFactory` contract with no mechanism to retrieve it.

```solidity
// _createPool L349
uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;
```

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. None of the responses in the `response_list` address the specific issue of Ether being locked in the `PoolFactory` contract due to the logic in the `_createPool` function. While some responses discuss issues related to `create2` and `_createPool`, none of them identify the problem of Ether being locked when `_collateralToken` is a non-zero address. This is a critical oversight, as it directly impacts the security and functionality of the contract.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-01] Ether can be locked in the PoolFactory contract without a way to retrieve it**

---

### **Conclusion**
The `response_list` does not adequately address the issue of Ether being locked in the `PoolFactory` contract. This is a significant vulnerability that should be highlighted and resolved to ensure the contract's security and functionality.","```
None.
```",0.0
