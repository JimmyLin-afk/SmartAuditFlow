nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
ExtraRewardsDistributor.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { IExtraRewardsDistributor, IAuraLocker } from ""./Interfaces.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";

/**
 * @title   ExtraRewardsDistributor
 * @author  adapted from ConvexFinance
 * @notice  Allows anyone to distribute rewards to the AuraLocker at a given epoch.
 */
contract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {
    using SafeERC20 for IERC20;

    IAuraLocker public immutable auraLocker;

    // token -> epoch -> amount
    mapping(address => mapping(uint256 => uint256)) public rewardData;
    // token -> epochList
    mapping(address => uint256[]) public rewardEpochs;
    // token -> account -> last claimed epoch index
    mapping(address => mapping(address => uint256)) public userClaims;

    /* ========== EVENTS ========== */

    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);
    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);
    event RewardForfeited(address indexed user, address indexed token, uint256 index);

    /**
     * @dev Simple constructoor
     * @param _auraLocker Aura Locker address
     */
    constructor(address _auraLocker) {
        auraLocker = IAuraLocker(_auraLocker);
    }

    /* ========== ADD REWARDS ========== */

    /**
     * @notice Add a reward to the current epoch. can be called multiple times for the same reward token
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokenπ
     */
    function addReward(address _token, uint256 _amount) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        _addReward(_token, _amount, latestEpoch);
    }

    /**
     * @notice Add reward token to a specific epoch
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokens to add
     * @param _epoch    Which epoch to add to (must be less than the previous epoch)
     */
    function addRewardToEpoch(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        require(_epoch <= latestEpoch, ""Cannot assign to the future"");

        if (_epoch == latestEpoch) {
            _addReward(_token, _amount, latestEpoch);
        } else {
            uint256 len = rewardEpochs[_token].length;
            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, ""Cannot backdate to this epoch"");

            _addReward(_token, _amount, _epoch);
        }
    }

    /**
     * @notice  Transfer reward tokens from sender to contract for vlCVX holders
     * @dev     Add reward token for specific epoch
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokens
     * @param _epoch    Epoch to add tokens to
     */
    function _addReward(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) internal nonReentrant {
        // Pull before reward accrual
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);

        //convert to reward per token
        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);
        uint256 rPerT = (_amount * 1e20) / supply;
        rewardData[_token][_epoch] += rPerT;

        //add epoch to list
        uint256 len = rewardEpochs[_token].length;
        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {
            rewardEpochs[_token].push(_epoch);
        }

        //event
        emit RewardAdded(_token, _epoch, _amount);
    }

    /* ========== GET REWARDS ========== */

    /**
     * @notice Claim rewards for a specific token since the first epoch.
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token address
     */
    function getReward(address _account, address _token) public {
        _getReward(_account, _token, 0);
    }

    /**
     * @notice Claim rewards for a specific token at a specific epoch
     * @param _account      Address of vlCVX holder
     * @param _token        Reward token address
     * @param _startIndex   Index of rewardEpochs[_token] to start checking for rewards from
     */
    function getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        _getReward(_account, _token, _startIndex);
    }

    /**
     * @notice Claim rewards for a specific token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from
     */
    function _getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        //get claimable tokens
        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);

        if (claimableTokens > 0) {
            //set claim checkpoint
            userClaims[_token][_account] = index;

            //send
            IERC20(_token).safeTransfer(_account, claimableTokens);

            //event
            emit RewardPaid(_account, _token, claimableTokens, index);
        }
    }

    /**
     * @notice  Allow a user to set their claimed index forward without claiming rewards
     *          Because claims cycle through all periods that a specific reward was given
     *          there becomes a situation where, for example, a new user could lock
     *          2 years from now and try to claim a token that was given out every week prior.
     *          This would result in a 2mil gas checkpoint.(about 20k gas * 52 weeks * 2 years)
     * @param _token  Reward token to forfeit
     * @param _index  Epoch index to forfeit from
     */
    function forfeitRewards(address _token, uint256 _index) external {
        require(_index > 0 && _index < rewardEpochs[_token].length - 1, ""!past"");
        require(_index >= userClaims[_token][msg.sender], ""already claimed"");

        //set claim checkpoint. next claim starts from index+1
        userClaims[_token][msg.sender] = _index + 1;

        emit RewardForfeited(msg.sender, _token, _index);
    }

    /* ========== VIEW REWARDS ========== */

    /**
     * @notice Get claimable rewards (rewardToken) for vlCVX holder
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token address
     */
    function claimableRewards(address _account, address _token) external view returns (uint256) {
        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);
        return rewards;
    }

    /**
     * @notice Get claimable rewards for a token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _epoch       The epoch to check for rewards
     */
    function claimableRewardsAtEpoch(
        address _account,
        address _token,
        uint256 _epoch
    ) external view returns (uint256) {
        return _claimableRewards(_account, _token, _epoch);
    }

    /**
     * @notice  Get all claimable rewards by looping through each epoch starting with the latest
     *          saved epoch the user last claimed from
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token
     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from
     */
    function _allClaimableRewards(
        address _account,
        address _token,
        uint256 _startIndex
    ) internal view returns (uint256, uint256) {
        uint256 latestEpoch = auraLocker.epochCount() - 1;
        // e.g. tokenEpochs = 31, 21
        uint256 tokenEpochs = rewardEpochs[_token].length;

        // e.g. epochIndex = 0
        uint256 epochIndex = userClaims[_token][_account];
        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27
        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;

        if (epochIndex >= tokenEpochs) {
            return (0, tokenEpochs);
        }

        uint256 claimableTokens = 0;

        for (uint256 i = epochIndex; i < tokenEpochs; i++) {
            //only claimable after rewards are ""locked in""
            if (rewardEpochs[_token][i] < latestEpoch) {
                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);
                //return index user claims should be set to
                epochIndex = i + 1;
            }
        }
        return (claimableTokens, epochIndex);
    }

    /**
     * @notice Get claimable rewards for a token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _epoch       The epoch to check for rewards
     */
    function _claimableRewards(
        address _account,
        address _token,
        uint256 _epoch
    ) internal view returns (uint256) {
        //get balance and calc share
        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);
        return (balance * rewardData[_token][_epoch]) / 1e20;
    }

    /**
     * @notice Simply gets the current epoch count for a given reward token
     * @param _token    Reward token address
     * @return _epochs  Number of epochs
     */
    function rewardEpochsCount(address _token) external view returns (uint256) {
        return rewardEpochs[_token].length;
    }
}",2365,268,"[H-01] User can forfeit other user rewards
User can forfeit other user rewards by giving a higher `_startIndex` in `getReward` function.
 
[M-05] Users can grief reward distribution
Users can grief reward distributions by spending dust.
If a reward is targeted for an epoch in the past, a user can front-run the txn in the mempool and call addRewardToEpoch() with a dust amount at an epoch after the one in question. This will cause the transaction in the mempool to revert
  [M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed
Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed. The platform then forced to reimburse reward to the user that got their reward locked. Causing huge economics loss.   [M-11] Users may lose rewards to other users if rewards are given as fee-on-transfer tokens
If rewards are given in fee-on-transfer tokens, users may get no rewards, breaking functionality.
",4,,"pragma solidity ^0.8.11;

import { IExtraRewardsDistributor, IAuraLocker } from ""./Interfaces.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";


contract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {
    using SafeERC20 for IERC20;

    IAuraLocker public immutable auraLocker;

    
    mapping(address => mapping(uint256 => uint256)) public rewardData;
    
    mapping(address => uint256[]) public rewardEpochs;
    
    mapping(address => mapping(address => uint256)) public userClaims;

    

    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);
    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);
    event RewardForfeited(address indexed user, address indexed token, uint256 index);

    
    constructor(address _auraLocker) {
        auraLocker = IAuraLocker(_auraLocker);
    }

    

    
    function addReward(address _token, uint256 _amount) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        _addReward(_token, _amount, latestEpoch);
    }

    
    function addRewardToEpoch(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        require(_epoch <= latestEpoch, ""Cannot assign to the future"");

        if (_epoch == latestEpoch) {
            _addReward(_token, _amount, latestEpoch);
        } else {
            uint256 len = rewardEpochs[_token].length;
            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, ""Cannot backdate to this epoch"");

            _addReward(_token, _amount, _epoch);
        }
    }

    
    function _addReward(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) internal nonReentrant {
        
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);

        
        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);
        uint256 rPerT = (_amount * 1e20) / supply;
        rewardData[_token][_epoch] += rPerT;

        
        uint256 len = rewardEpochs[_token].length;
        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {
            rewardEpochs[_token].push(_epoch);
        }

        
        emit RewardAdded(_token, _epoch, _amount);
    }

    

    
    function getReward(address _account, address _token) public {
        _getReward(_account, _token, 0);
    }

    
    function getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        _getReward(_account, _token, _startIndex);
    }

    
    function _getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        
        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);

        if (claimableTokens > 0) {
            
            userClaims[_token][_account] = index;

            
            IERC20(_token).safeTransfer(_account, claimableTokens);

            
            emit RewardPaid(_account, _token, claimableTokens, index);
        }
    }

    
    function forfeitRewards(address _token, uint256 _index) external {
        require(_index > 0 && _index < rewardEpochs[_token].length - 1, ""!past"");
        require(_index >= userClaims[_token][msg.sender], ""already claimed"");

        
        userClaims[_token][msg.sender] = _index + 1;

        emit RewardForfeited(msg.sender, _token, _index);
    }

    

    
    function claimableRewards(address _account, address _token) external view returns (uint256) {
        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);
        return rewards;
    }

    
    function claimableRewardsAtEpoch(
        address _account,
        address _token,
        uint256 _epoch
    ) external view returns (uint256) {
        return _claimableRewards(_account, _token, _epoch);
    }

    
    function _allClaimableRewards(
        address _account,
        address _token,
        uint256 _startIndex
    ) internal view returns (uint256, uint256) {
        uint256 latestEpoch = auraLocker.epochCount() - 1;
        
        uint256 tokenEpochs = rewardEpochs[_token].length;

        
        uint256 epochIndex = userClaims[_token][_account];
        
        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;

        if (epochIndex >= tokenEpochs) {
            return (0, tokenEpochs);
        }

        uint256 claimableTokens = 0;

        for (uint256 i = epochIndex; i < tokenEpochs; i++) {
            
            if (rewardEpochs[_token][i] < latestEpoch) {
                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);
                
                epochIndex = i + 1;
            }
        }
        return (claimableTokens, epochIndex);
    }

    
    function _claimableRewards(
        address _account,
        address _token,
        uint256 _epoch
    ) internal view returns (uint256) {
        
        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);
        return (balance * rewardData[_token][_epoch]) / 1e20;
    }

    
    function rewardEpochsCount(address _token) external view returns (uint256) {
        return rewardEpochs[_token].length;
    }
}",1352,1,3,"{
  ""task_list"": [
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Verify that the `nonReentrant` modifier on the `_addReward` function effectively prevents reentrancy attacks. Specifically, analyze potential reentrancy scenarios through calls to the `auraLocker` or ERC20 contracts within `_addReward`."",
        ""Analyze if any other functions, particularly those involving external calls or state updates based on external data, are susceptible to reentrancy attacks and require additional protection."",
        ""Confirm that the `ReentrancyGuard` is correctly initialized and used.""
      ]
    },
    {
      ""Area"": ""Arithmetic Over/Underflows"",
      ""Tasks"": [
        ""Examine all arithmetic operations, especially the reward calculation in `_addReward` and `_claimableRewards`, for potential over/underflows, considering the large numbers involved (1e20 scaling)."",
        ""Verify that the `SafeERC20` library is used consistently and correctly for all ERC20 interactions."",
        ""Analyze the potential for division by zero in `_addReward` where `(_amount * 1e20) / supply` is calculated. Investigate whether `auraLocker.totalSupplyAtEpoch(_epoch)` can ever return zero and add a check if necessary.""
      ]
    },
    {
      ""Area"": ""Reward Calculation and Distribution Logic"",
      ""Tasks"": [
        ""Thoroughly review the reward calculation logic in `_addReward` and `_claimableRewards` to ensure accuracy and fairness. Confirm that the 1e20 scaling factor is correctly applied and that integer division doesn't lead to significant loss of precision or dust amounts."",
        ""Analyze the loop in `_allClaimableRewards` and confirm that it correctly iterates through all relevant epochs. Specifically, investigate why the loop condition `rewardEpochs[_token][i] < latestEpoch` prevents claiming rewards for the current `latestEpoch` and if this is the intended behavior."",
        ""Verify that the `userClaims` mapping is updated correctly in `_getReward` and that users can only claim rewards for epochs they haven't already claimed."",
        ""Assess the impact of adding rewards to past epochs via `addRewardToEpoch` and ensure that the restriction on epoch ordering (`rewardEpochs[_token][len - 1] < _epoch`) doesn't prevent legitimate backdating scenarios. Consider the potential for out-of-order epoch addition and its consequences.""
      ]
    },
    {
      ""Area"": ""Access Control and Authorization"",
      ""Tasks"": [
        ""Verify that only authorized accounts can call `addReward` and `addRewardToEpoch`. Clarify the intended access control mechanism for these functions (e.g., ownership, role-based access control)."",
        ""Evaluate whether the `_getReward` function should be internal, as direct external calls could bypass intended logic or future modifications in the `getReward` wrappers. Consider the security implications of allowing external calls to `_getReward`.""
      ]
    },
    {
      ""Area"": ""External Interactions and Trust Assumptions"",
      ""Tasks"": [
        ""Audit the interactions with the `AuraLocker` contract (IAuraLocker). Verify the trust assumptions made about the `AuraLocker`'s behavior, particularly regarding `checkpointEpoch()`, `epochCount()`, `totalSupplyAtEpoch(uint256)`, and `balanceAtEpochOf(uint256, address)`. Consider potential vulnerabilities if the `AuraLocker`'s implementation is malicious or buggy."",
        ""Ensure that the contract can handle different types of ERC20 tokens with varying decimal places. Analyze the potential impact of token decimals on the reward calculation and distribution logic."",
        ""Check the handling of ERC20 token transfers using `safeTransferFrom` and `safeTransfer` in case the token does not adhere to the ERC20 standard. Specifically, what happens if `safeTransferFrom` or `safeTransfer` return false rather than revert?""
      ]
    },
    {
      ""Area"": ""Reward Forfeiture Logic"",
      ""Tasks"": [
        ""Analyze the logic in `forfeitRewards` and confirm that the restrictions on forfeiting epochs (excluding the first and last) are intentional and justified. Investigate the reasoning behind preventing forfeiture of the initial and latest epoch."",
        ""Verify that the `forfeitRewards` function correctly updates the `userClaims` mapping and prevents users from forfeiting already claimed rewards or future rewards."",
        ""Assess the potential for abuse or unintended consequences associated with reward forfeiture.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the gas costs of the key functions, particularly `addReward`, `addRewardToEpoch`, and `getReward`. Identify potential areas for gas optimization, such as reducing state variable reads/writes or optimizing loop iterations."",
        ""Consider using more gas-efficient data structures or algorithms where appropriate."",
        ""Profile the contract's gas usage under different scenarios to identify bottlenecks.""
      ]
    },
    {
      ""Area"": ""Event Emission"",
      ""Tasks"": [
        ""Verify that all relevant state changes are properly emitted as events. This includes reward additions, reward payments, and reward forfeitures."",
        ""Ensure that the event data is accurate and complete, providing sufficient information for off-chain monitoring and analysis.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `ExtraRewardsDistributor` is designed to distribute arbitrary ERC20 tokens as extra rewards to users who have staked tokens in an associated `AuraLocker` contract. Rewards are distributed based on epochs defined by the `AuraLocker`. Users can claim accumulated rewards, and new rewards can be added by external callers, potentially targeting specific past or current epochs. The contract utilizes OpenZeppelin's SafeERC20 for token transfers and ReentrancyGuard for protection on the reward addition function."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""ExtraRewardsDistributor"",
    ""Purpose"": ""To manage and distribute extra ERC20 rewards to AuraLocker stakers based on their balance per epoch."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ReentrancyGuard"", ""IExtraRewardsDistributor""],
      ""Imports"": [
        ""./Interfaces.sol => IExtraRewardsDistributor, IAuraLocker"",
        ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"",
        ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"",
        ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""auraLocker"",
        ""Type"": ""IAuraLocker"",
        ""Purpose"": ""Immutable reference to the AuraLocker contract, used to fetch epoch data and user balances.""
      },
      {
        ""Name"": ""rewardData"",
        ""Type"": ""mapping(address => mapping(uint256 => uint256))"",
        ""Purpose"": ""Stores the reward rate per token per epoch, scaled by 1e20. Maps token address -> epoch number -> reward rate.""
      },
      {
        ""Name"": ""rewardEpochs"",
        ""Type"": ""mapping(address => uint256[])"",
        ""Purpose"": ""Stores an array of epoch numbers for which rewards have been added for a specific token.""
      },
      {
        ""Name"": ""userClaims"",
        ""Type"": ""mapping(address => mapping(address => uint256))"",
        ""Purpose"": ""Tracks the progress of user claims. Maps token address -> user address -> index in the `rewardEpochs` array up to which the user has claimed.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract by setting the immutable `auraLocker` address."",
        ""Parameters"": [""address _auraLocker""],
        ""Returns"": []
      },
      {
        ""Name"": ""addReward"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds rewards for the latest epoch. Calls `_addReward` internally."",
        ""Parameters"": [""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""addRewardToEpoch"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds rewards for a specific epoch (current or past, with restrictions). Calls `_addReward` internally."",
        ""Parameters"": [""address _token"", ""uint256 _amount"", ""uint256 _epoch""],
        ""Returns"": []
      },
      {
        ""Name"": ""_addReward"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal logic to transfer reward tokens, calculate reward rate, update state, and emit event. Protected by `nonReentrant` modifier."",
        ""Parameters"": [""address _token"", ""uint256 _amount"", ""uint256 _epoch""],
        ""Returns"": []
      },
      {
        ""Name"": ""getReward (1)"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims all available rewards for a user and token, starting from the beginning or last claimed point. Calls `_getReward` with startIndex 0."",
        ""Parameters"": [""address _account"", ""address _token""],
        ""Returns"": []
      },
      {
        ""Name"": ""getReward (2)"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims available rewards for a user and token, starting from a specified index if it's later than the last claimed point. Calls `_getReward`."",
        ""Parameters"": [""address _account"", ""address _token"", ""uint256 _startIndex""],
        ""Returns"": []
      },
      {
        ""Name"": ""_getReward"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Internal logic to calculate claimable tokens using `_allClaimableRewards`, update claim index, transfer tokens, and emit event."",
        ""Parameters"": [""address _account"", ""address _token"", ""uint256 _startIndex""],
        ""Returns"": []
      },
      {
        ""Name"": ""forfeitRewards"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to skip claiming rewards up to a certain epoch index (excluding the first and last epoch index)."",
        ""Parameters"": [""address _token"", ""uint256 _index""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimableRewards"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the total claimable reward amount for a user and token."",
        ""Parameters"": [""address _account"", ""address _token""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""claimableRewardsAtEpoch"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the claimable reward amount for a user and token at a specific epoch."",
        ""Parameters"": [""address _account"", ""address _token"", ""uint256 _epoch""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_allClaimableRewards"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Calculates the total claimable rewards for epochs before the current one, starting from a given index."",
        ""Parameters"": [""address _account"", ""address _token"", ""uint256 _startIndex""],
        ""Returns"": [""uint256 claimableTokens"", ""uint256 nextIndex""]
      },
      {
        ""Name"": ""_claimableRewards"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Calculates the reward amount for a specific user, token, and epoch based on their balance and the epoch's reward rate."",
        ""Parameters"": [""address _account"", ""address _token"", ""uint256 _epoch""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""rewardEpochsCount"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the total number of epochs for which a specific token has rewards."",
        ""Parameters"": [""address _token""],
        ""Returns"": [""uint256""]
      },
       {
        ""Name"": ""nonReentrant"",
        ""Visibility"": ""modifier (inherited)"",
        ""Purpose"": ""Prevents reentrant calls into the function it modifies (used on `_addReward`)."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IAuraLocker contract (`auraLocker`): Calls `checkpointEpoch()`, `epochCount()`, `totalSupplyAtEpoch(uint256)`, `balanceAtEpochOf(uint256, address)`."",
    ""IERC20 contract (reward tokens): Calls `safeTransferFrom(address, address, uint256)` to receive rewards, `safeTransfer(address, uint256)` to pay out rewards.""
  ],
  ""SpecialMechanisms"": [
    ""Epoch-based reward calculation: Rewards are tied to specific epochs defined by the external AuraLocker."",
    ""Reward Rate Scaling: Uses a scaling factor of 1e20 (`_amount * 1e20 / supply`) to store reward rates, likely to handle fractional rewards per base token."",
    ""Reward Claim Tracking: Uses `userClaims` mapping to track the index in the `rewardEpochs` array, allowing users to claim incrementally."",
    ""Reward Forfeiture: Allows users to skip claiming rewards for certain past epochs."",
    ""Reentrancy Protection: Uses OpenZeppelin's `ReentrancyGuard` on the `_addReward` function."",
    ""Safe ERC20 Usage: Employs `SafeERC20` for token transfers."",
    ""Backdating Rewards: Allows adding rewards to past epochs via `addRewardToEpoch`, but only if the target epoch is later than the last epoch added for that token in the `rewardEpochs` array.""
  ],
  ""Questions"": [
    ""The `_getReward` function is marked `public`. Should it be `internal` since it's called by the public `getReward` wrappers and handles token transfers? Direct external calls could potentially bypass future logic added to the wrappers."",
    ""In `_allClaimableRewards`, the loop condition `rewardEpochs[_token][i] < latestEpoch` prevents claiming rewards for the current `latestEpoch`. Is this intended? How are rewards for the final epoch claimed if the loop always stops short?"",
    ""In `forfeitRewards`, the requirement `_index > 0 && _index < rewardEpochs[_token].length - 1` prevents forfeiting the very first epoch (index 0) and the most recently added epoch. What is the reasoning for this specific range?"",
    ""In `_addReward`, division by `supply` occurs: `(_amount * 1e20) / supply`. If `auraLocker.totalSupplyAtEpoch(_epoch)` can return 0 for a valid epoch, this would cause a revert. Is a zero supply guaranteed not to happen for epochs where rewards are added, or should a check be added?"",
    ""The check in `addRewardToEpoch` (`rewardEpochs[_token][len - 1] < _epoch`) prevents adding rewards for an epoch chronologically *before* the latest epoch *already recorded* in the `rewardEpochs` array for that token. Is this strict ordering always desired? Could it prevent legitimate backdating scenarios if epochs were initially added out of order?"",
    ""Does the `1e20` scaling factor provide sufficient precision for all expected reward token decimals and balance ranges? Could significant dust amounts be lost due to integer division in `_claimableRewards`?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in Reward Claiming/Adding"",
      ""Severity"": ""High"",
      ""Description"": ""The `_getReward` function transfers tokens to the user *after* updating the `userClaims` mapping, which is vulnerable to reentrancy attacks. Additionally, `_addReward` uses `safeTransferFrom` to transfer tokens, potentially allowing a malicious token contract to call back into `ExtraRewardsDistributor` before state updates, leading to manipulation of rewards or draining of funds."",
      ""Impact"": ""Loss of funds for the contract due to multiple reward claims or manipulation of reward distribution."",
      ""Location"": ""ExtraRewardsDistributor.sol:_getReward, ExtraRewardsDistributor.sol:_addReward""
    },
    {
      ""Issue"": ""Potential Division by Zero in `_addReward` Calculation"",
      ""Severity"": ""High"",
      ""Description"": ""The `_addReward` function calculates `rPerT` using `(_amount * 1e20) / supply`. If `supply` (which is `auraLocker.totalSupplyAtEpoch(_epoch)`) is zero, this will result in a division by zero, causing the transaction to revert. This can happen if the AuraLocker has not had any tokens deposited at the specified epoch."",
      ""Impact"": ""Denial of service; no rewards can be added for the epoch."",
      ""Location"": ""ExtraRewardsDistributor.sol:_addReward""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `_addReward` Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_addReward` function, the reward per token (rPerT) is calculated as `(_amount * 1e20) / supply`. If `_amount` is sufficiently large, the multiplication `_amount * 1e20` could result in an integer overflow. If `supply` is very small, the division might lead to a very large `rPerT` value, potentially overflowing later calculations.  If `supply` is very large, then `rPerT` could underflow to zero."",
      ""Impact"": ""Users receive smaller rewards than expected due to the inaccurate `rPerT` calculation. Rewards could be zeroed out. In extreme overflow cases, rewards for an epoch could be rendered negligible."",
      ""Location"": ""ExtraRewardsDistributor.sol:_addReward""
    },
    {
      ""Issue"": ""Potential Denial of Service in Reward Epochs due to Unbounded Loop and Array Growth"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `rewardEpochs[_token].push(_epoch)` operation in `_addReward` could lead to a denial of service if a large number of epochs are created for a specific token. Iterating through `rewardEpochs[_token]` in functions like `_allClaimableRewards` could become very gas intensive, potentially exceeding the block gas limit and preventing users from claiming rewards. Also, inside the loop, epochIndex is only updated inside the `if` condition, it is possible for the loop to iterate multiple times for the same `epochIndex`."",
      ""Impact"": ""Inability for users to claim rewards due to high gas costs, contract unusable."",
      ""Location"": ""ExtraRewardsDistributor.sol:_addReward, ExtraRewardsDistributor.sol:_allClaimableRewards""
    },
    {
      ""Issue"": ""Lack of Access Control for `addRewardToEpoch`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `addRewardToEpoch` function allows adding rewards to a specific epoch. Currently, there are no access controls on this function, meaning anyone can call it. This could lead to malicious actors manipulating reward distribution by adding rewards to arbitrary epochs."",
      ""Impact"": ""Potential for unfair reward distribution and manipulation of the reward system."",
      ""Location"": ""ExtraRewardsDistributor.sol:addRewardToEpoch""
    },
    {
      ""Issue"": ""Inconsistent Epoch Handling and Potential Stale Data/Front Running"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies on `auraLocker.epochCount()` and `auraLocker.totalSupplyAtEpoch(_epoch)` for determining the current epoch and calculating reward distribution. Additionally, `addReward` and `addRewardToEpoch` call `auraLocker.checkpointEpoch()`. There's a risk of using stale data if `AuraLocker` updates with delay and potential front-running vulnerability where attackers can manipulate reward distribution. The forfeitRewards function doesn't handle epochs properly."",
      ""Impact"": ""Incorrect reward distribution, unfair allocation of rewards to users, potential loss of funds, limited forfeiture functionality."",
      ""Location"": ""Multiple locations, including `addReward`, `addRewardToEpoch`, `_addReward`, `_claimableRewards`, `forfeitRewards`""
    },
    {
      ""Issue"": ""Incorrect `require` statement in `forfeitRewards` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `require` statement `require(_index > 0 && _index < rewardEpochs[_token].length - 1, \\""!past\\"");` in the `forfeitRewards` function imposes a restriction on the `_index` that is not intuitive and prevents forfeiting the first or last reward epoch. The lower bound check `_index > 0` might be too strict. The last reward is likely not claimable. Additionally, there is no check to verify that the _index exists in `rewardEpochs[_token]` meaning a malicious user could forfeit an invalid index. Also, `rewardEpochs[_token].length -1 ` can underflow if `rewardEpochs[_token]` is empty."",
      ""Impact"": ""Limits the user’s ability to forfeit rewards for specific epochs, potential for integer underflow and unexpected behavior."",
      ""Location"": ""forfeitRewards function""
    },
    {
      ""Issue"": ""Potential rounding errors in reward calculation in _claimableRewards"",
      ""Severity"": ""Low"",
      ""Description"": ""The reward calculation involves multiplication and division, `(balance * rewardData[_token][_epoch]) / 1e20`. This can lead to rounding errors, especially if balance or rewardData are small. Although 1e20 provides sufficient precision, carefully consider the implications of rounding errors, particularly for large-scale deployments. It is theoretically possible if `balance` and `rewardData` are sufficiently large."",
      ""Impact"": ""Slightly inaccurate reward distribution."",
      ""Location"": ""ExtraRewardsDistributor.sol:_claimableRewards""
    },
    {
      ""Issue"": ""Unnecessary `checkpointEpoch` calls"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `addReward` and `addRewardToEpoch` both call `auraLocker.checkpointEpoch()`. Calling checkpointEpoch every time a reward is added can be inefficient, as it triggers a new epoch even if unnecessary. The checkpointing logic within the auraLocker should be analyzed to understand the frequency it needs to be called. Consider refactoring to only checkpoint when strictly necessary to minimize gas costs."",
      ""Impact"": ""Increased gas costs for adding rewards due to unnecessary epoch checkpointing."",
      ""Location"": ""addReward and addRewardToEpoch functions""
    },
    {
      ""Issue"": ""Lack of Input Validation on `_amount` in `addReward` and `addRewardToEpoch`"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `addReward` and `addRewardToEpoch` do not have explicit checks to ensure that the `_amount` being transferred is greater than zero. While `safeTransferFrom` will revert if the amount is zero, adding an explicit check would improve code clarity and potentially save gas."",
      ""Impact"": ""Unnecessary transaction if `_amount` is zero. Although the `safeTransferFrom` function mitigates any funds related consequences."",
      ""Location"": ""`addReward` and `addRewardToEpoch` functions.""
    }
  ],
  ""IssueNumber"": 38,
  ""OutputList"": 10
}",210.4189391136169,3721.0,32.0,"### **[H-01] User can forfeit other user rewards**

**Report Description**:  
The `getReward` function allows a user to forfeit another user's rewards by providing a higher `_startIndex`. This could lead to unfair reward distribution and potential exploitation by malicious users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of users being able to forfeit other users' rewards by manipulating the `_startIndex` parameter. This is a critical oversight, as it directly impacts the fairness and security of the reward distribution mechanism.

---

### **[M-05] Users can grief reward distribution**

**Report Description**:  
Users can grief reward distributions by spending dust amounts. If a reward is targeted for an epoch in the past, a user can front-run the transaction in the mempool and call `addRewardToEpoch()` with a dust amount at an epoch after the one in question. This will cause the transaction in the mempool to revert, disrupting the reward distribution process.

**Match in Response List**:  
Matches with the issue titled **""Inconsistent Epoch Handling and Potential Stale Data/Front Running""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of front-running and stale data in the context of reward distribution. However, it does not specifically address the issue of griefing through dust amounts, which is a critical aspect of the reported vulnerability.

---

### **[M-07] Reward may be locked forever if user doesn't claim reward for a very long time**

**Report Description**:  
If a user does not claim their reward for a very long time, and too many epochs have passed, the reward may be locked forever. The platform would then be forced to reimburse the user, causing significant economic loss.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of rewards being locked indefinitely due to users not claiming them over a long period. This is a significant oversight, as it could lead to substantial financial losses for the platform.

---

### **[M-11] Users may lose rewards to other users if rewards are given as fee-on-transfer tokens**

**Report Description**:  
If rewards are given in fee-on-transfer tokens, users may receive no rewards, breaking the functionality of the reward system. This could lead to unfair distribution and potential exploitation by malicious users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of fee-on-transfer tokens causing users to lose rewards. This is a critical oversight, as it directly impacts the functionality and fairness of the reward distribution mechanism.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-05] Users can grief reward distribution**

**Missed Issues from Issue Report**:  
- **[H-01] User can forfeit other user rewards**  
- **[M-07] Reward may be locked forever if user doesn't claim reward for a very long time**  
- **[M-11] Users may lose rewards to other users if rewards are given as fee-on-transfer tokens**

---

### **Conclusion**

The response list partially addresses one of the issues ([M-05]) but fails to cover the other three critical vulnerabilities ([H-01], [M-07], [M-11]). This indicates significant gaps in the response list's coverage of the reported issues, particularly in areas related to reward distribution fairness, long-term reward locking, and fee-on-transfer token handling.","```
None.
```",0.0
AuraLocker.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;
pragma experimental ABIEncoderV2;

import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts-0.8/access/Ownable.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";
import { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from ""./AuraMath.sol"";
import ""./Interfaces.sol"";

interface IRewardStaking {
    function stakeFor(address, uint256) external;
}

/**
 * @title   AuraLocker
 * @author  ConvexFinance
 * @notice  Effectively allows for rolling 16 week lockups of CVX, and provides balances available
 *          at each epoch (1 week). Also receives cvxCrv from `CvxStakingProxy` and redistributes
 *          to depositors.
 * @dev     Invdividual and delegatee vote power lookups both use independent accounting mechanisms.
 */
contract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {
    using AuraMath for uint256;
    using AuraMath224 for uint224;
    using AuraMath112 for uint112;
    using AuraMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ==========     STRUCTS     ========== */

    struct RewardData {
        /// Timestamp for current period finish
        uint32 periodFinish;
        /// Last time any user took action
        uint32 lastUpdateTime;
        /// RewardRate for the rest of the period
        uint96 rewardRate;
        /// Ever increasing rewardPerToken rate, based on % of total supply
        uint96 rewardPerTokenStored;
    }
    struct UserData {
        uint128 rewardPerTokenPaid;
        uint128 rewards;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Balances {
        uint112 locked;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint32 unlockTime;
    }
    struct Epoch {
        uint224 supply;
        uint32 date; //epoch start date
    }
    struct DelegateeCheckpoint {
        uint224 votes;
        uint32 epochStart;
    }

    /* ========== STATE VARIABLES ========== */

    // Rewards
    address[] public rewardTokens;
    uint256 public queuedCvxCrvRewards = 0;
    uint256 public constant newRewardRatio = 830;
    //     Core reward data
    mapping(address => RewardData) public rewardData;
    //     Reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;
    //     User -> reward token -> amount
    mapping(address => mapping(address => UserData)) public userData;
    //     Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;
    //     Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // Balances
    //     Supplies and historic supply
    uint256 public lockedSupply;
    //     Epochs contains only the tokens that were locked at that epoch, not a cumulative supply
    Epoch[] public epochs;
    //     Mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    // Voting
    //     Stored delegations
    mapping(address => address) private _delegates;
    //     Checkpointed votes
    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;
    //     Delegatee balances (user -> unlock timestamp -> amount)
    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;

    // Config
    //     Tokens
    IERC20 public immutable stakingToken;
    address public immutable cvxCrv;
    //     Denom for calcs
    uint256 public constant denominator = 10000;
    //     Staking cvxCrv
    address public immutable cvxcrvStaking;
    //     Incentives
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 3;
    //     Shutdown
    bool public isShutdown = false;

    // Basic token data
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== EVENTS ========== */

    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateCheckpointed(address indexed delegate);

    event Recovered(address _token, uint256 _amount);
    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);
    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);
    event RewardAdded(address indexed _token, uint256 _reward);

    event KickIncentiveSet(uint256 rate, uint256 delay);
    event Shutdown();

    /***************************************
                    CONSTRUCTOR
    ****************************************/

    /**
     * @param _nameArg          Token name, simples
     * @param _symbolArg        Token symbol
     * @param _stakingToken     CVX (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)
     * @param _cvxCrv           cvxCRV (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)
     * @param _cvxCrvStaking    cvxCRV rewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e)
     */
    constructor(
        string memory _nameArg,
        string memory _symbolArg,
        address _stakingToken,
        address _cvxCrv,
        address _cvxCrvStaking
    ) Ownable() {
        _name = _nameArg;
        _symbol = _symbolArg;
        _decimals = 18;

        stakingToken = IERC20(_stakingToken);
        cvxCrv = _cvxCrv;
        cvxcrvStaking = _cvxCrvStaking;

        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));
    }

    /***************************************
                    MODIFIER
    ****************************************/

    modifier updateReward(address _account) {
        {
            Balances storage userBalance = balances[_account];
            uint256 rewardTokensLength = rewardTokens.length;
            for (uint256 i = 0; i < rewardTokensLength; i++) {
                address token = rewardTokens[i];
                uint256 newRewardPerToken = _rewardPerToken(token);
                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();
                if (_account != address(0)) {
                    userData[_account][token] = UserData({
                        rewardPerTokenPaid: newRewardPerToken.to128(),
                        rewards: _earned(_account, token, userBalance.locked).to128()
                    });
                }
            }
        }
        _;
    }

    /***************************************
                    ADMIN
    ****************************************/

    // Add a new reward token to be distributed to stakers
    function addReward(address _rewardsToken, address _distributor) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0, ""Reward already exists"");
        require(_rewardsToken != address(stakingToken), ""Cannot add StakingToken as reward"");
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0, ""Reward does not exist"");
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {
        require(_rate <= 500, ""over max rate""); //max 5% per epoch
        require(_delay >= 2, ""min delay""); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;

        emit KickIncentiveSet(_rate, _delay);
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        isShutdown = true;
        emit Shutdown();
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {
        require(_tokenAddress != address(stakingToken), ""Cannot withdraw staking token"");
        require(rewardData[_tokenAddress].lastUpdateTime == 0, ""Cannot withdraw reward token"");
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    // Set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);
    }

    /***************************************
                    ACTIONS
    ****************************************/

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount);
    }

    //lock tokens
    function _lock(address _account, uint256 _amount) internal {
        require(_amount > 0, ""Cannot stake 0"");
        require(!isShutdown, ""shutdown"");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //add user balances
        uint112 lockAmount = _amount.to112();
        bal.locked = bal.locked.add(lockAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(_amount);

        //add user lock records or add to current
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
        }

        address delegatee = delegates(_account);
        if (delegatee != address(0)) {
            delegateeUnlocks[delegatee][unlockTime] += lockAmount;
            _checkpointDelegate(delegatee, lockAmount, 0);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(lockAmount);

        emit Staked(_account, lockAmount, lockAmount);
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {
        uint256 rewardTokensLength = rewardTokens.length;
        for (uint256 i; i < rewardTokensLength; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = userData[_account][_rewardsToken].rewards;
            if (reward > 0) {
                userData[_account][_rewardsToken].rewards = 0;
                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length
        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps until the next epoch date.
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);
                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));
            }
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));
    }

    // Withdraw without checkpointing or accruing any rewards, providing system is shutdown
    function emergencyWithdraw() external nonReentrant {
        require(isShutdown, ""Must be shutdown"");

        LockedBalance[] memory locks = userLocks[msg.sender];
        Balances storage userBalance = balances[msg.sender];

        uint256 amt = userBalance.locked;
        require(amt > 0, ""Nothing locked"");

        userBalance.locked = 0;
        userBalance.nextUnlockIndex = locks.length.to32();
        lockedSupply -= amt;

        emit Withdrawn(msg.sender, amt, false);

        stakingToken.safeTransfer(msg.sender, amt);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint256 length = locks.length;
        uint256 reward = 0;
        uint256 expiryTime = _checkDelay == 0 && _relock
            ? block.timestamp.add(rewardsDuration)
            : block.timestamp.sub(_checkDelay);
        require(length > 0, ""no locks"");
        // e.g. now = 16
        // if contract is shutdown OR latest lock unlock time (e.g. 17) <= now - (1)
        // e.g. 17 <= (16 + 1)
        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);
                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > expiryTime) break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);
                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, ""no exp locks"");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        lockedSupply = lockedSupply.sub(locked);

        //checkpoint the delegatee
        _checkpointDelegate(delegates(_account), 0, 0);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            stakingToken.safeTransfer(_rewardAddress, reward);
            emit KickReward(_rewardAddress, _account, reward);
        }

        //relock or return to user
        if (_relock) {
            _lock(_account, locked);
        } else {
            stakingToken.safeTransfer(_account, locked);
        }
    }

    /***************************************
            DELEGATION & VOTE BALANCE
    ****************************************/

    /**
     * @dev Delegate votes from the sender to `newDelegatee`.
     */
    function delegate(address newDelegatee) external virtual nonReentrant {
        // Step 1: Get lock data
        LockedBalance[] storage locks = userLocks[msg.sender];
        uint256 len = locks.length;
        require(len > 0, ""Nothing to delegate"");
        require(newDelegatee != address(0), ""Must delegate to someone"");

        // Step 2: Update delegatee storage
        address oldDelegatee = delegates(msg.sender);
        require(newDelegatee != oldDelegatee, ""Must choose new delegatee"");
        _delegates[msg.sender] = newDelegatee;

        emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);

        // Step 3: Move balances around
        //         Delegate for the upcoming epoch
        uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
        uint256 i = len - 1;
        uint256 futureUnlocksSum = 0;
        LockedBalance memory currentLock = locks[i];
        // Step 3.1: Add future unlocks and sum balances
        while (currentLock.unlockTime > upcomingEpoch) {
            futureUnlocksSum += currentLock.amount;

            if (oldDelegatee != address(0)) {
                delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;
            }
            delegateeUnlocks[newDelegatee][currentLock.unlockTime] += currentLock.amount;

            if (i > 0) {
                i--;
                currentLock = locks[i];
            } else {
                break;
            }
        }

        // Step 3.2: Checkpoint old delegatee
        _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);

        // Step 3.3: Checkpoint new delegatee
        _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);
    }

    function _checkpointDelegate(
        address _account,
        uint256 _upcomingAddition,
        uint256 _upcomingDeduction
    ) internal {
        // This would only skip on first checkpointing
        if (_account != address(0)) {
            uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
            DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];
            if (ckpts.length > 0) {
                DelegateeCheckpoint memory prevCkpt = ckpts[ckpts.length - 1];
                // If there has already been a record for the upcoming epoch, no need to deduct the unlocks
                if (prevCkpt.epochStart == upcomingEpoch) {
                    ckpts[ckpts.length - 1] = DelegateeCheckpoint({
                        votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    });
                }
                // else if it has been over 16 weeks since the previous checkpoint, all locks have since expired
                // e.g. week 1 + 17 <= 18
                else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (_upcomingAddition - _upcomingDeduction).to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                } else {
                    uint256 nextEpoch = upcomingEpoch;
                    uint256 unlocksSinceLatestCkpt = 0;
                    // Should be maximum 18 iterations
                    while (nextEpoch > prevCkpt.epochStart) {
                        unlocksSinceLatestCkpt += delegateeUnlocks[_account][nextEpoch];
                        nextEpoch -= rewardsDuration;
                    }
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)
                                .to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                }
            } else {
                ckpts.push(
                    DelegateeCheckpoint({
                        votes: (_upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    })
                );
            }
            emit DelegateCheckpointed(_account);
        }
    }

    /**
     * @dev Get the address `account` is currently delegating to.
     */
    function delegates(address account) public view virtual returns (address) {
        return _delegates[account];
    }

    /**
     * @dev Gets the current votes balance for `account`
     */
    function getVotes(address account) external view returns (uint256) {
        return getPastVotes(account, block.timestamp);
    }

    /**
     * @dev Get the `pos`-th checkpoint for `account`.
     */
    function checkpoints(address account, uint32 pos) external view virtual returns (DelegateeCheckpoint memory) {
        return _checkpointedVotes[account][pos];
    }

    /**
     * @dev Get number of checkpoints for `account`.
     */
    function numCheckpoints(address account) external view virtual returns (uint32) {
        return _checkpointedVotes[account].length.to32();
    }

    /**
     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.
     */
    function getPastVotes(address account, uint256 timestamp) public view returns (uint256 votes) {
        require(timestamp <= block.timestamp, ""ERC20Votes: block not yet mined"");
        uint256 epoch = timestamp.div(rewardsDuration).mul(rewardsDuration);
        DelegateeCheckpoint memory ckpt = _checkpointsLookup(_checkpointedVotes[account], epoch);
        votes = ckpt.votes;
        if (votes == 0 || ckpt.epochStart + lockDuration <= epoch) {
            return 0;
        }
        while (epoch > ckpt.epochStart) {
            votes -= delegateeUnlocks[account][epoch];
            epoch -= rewardsDuration;
        }
    }

    /**
     * @dev Retrieve the `totalSupply` at the end of `timestamp`. Note, this value is the sum of all balances.
     * It is but NOT the sum of all the delegated votes!
     */
    function getPastTotalSupply(uint256 timestamp) external view returns (uint256) {
        require(timestamp < block.timestamp, ""ERC20Votes: block not yet mined"");
        return totalSupplyAtEpoch(findEpochId(timestamp));
    }

    /**
     * @dev Lookup a value in a list of (sorted) checkpoints.
     *      Copied from oz/ERC20Votes.sol
     */
    function _checkpointsLookup(DelegateeCheckpoint[] storage ckpts, uint256 epochStart)
        private
        view
        returns (DelegateeCheckpoint memory)
    {
        uint256 high = ckpts.length;
        uint256 low = 0;
        while (low < high) {
            uint256 mid = AuraMath.average(low, high);
            if (ckpts[mid].epochStart > epochStart) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        return high == 0 ? DelegateeCheckpoint(0, 0) : ckpts[high - 1];
    }

    /***************************************
                VIEWS - BALANCES
    ****************************************/

    // Balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        return balanceAtEpochOf(findEpochId(block.timestamp), _user);
    }

    // Balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);

        LockedBalance[] storage locks = userLocks[_user];

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        uint256 locksLength = locks.length;
        for (uint256 i = locksLength; i > 0; i--) {
            uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch < epochStart) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i - 1].amount);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    // Supply of all properly locked balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        return totalSupplyAtEpoch(findEpochId(block.timestamp));
    }

    // Supply of all properly locked balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch) public view returns (uint256 supply) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 lastIndex = epochs.length - 1;

        uint256 epochIndex = _epoch > lastIndex ? lastIndex : _epoch;

        for (uint256 i = epochIndex + 1; i > 0; i--) {
            Epoch memory e = epochs[i - 1];
            if (e.date == epochStart) {
                continue;
            } else if (e.date <= cutoffEpoch) {
                break;
            } else {
                supply += e.supply;
            }
        }
    }

    // Get an epoch index based on timestamp
    function findEpochId(uint256 _time) public view returns (uint256 epoch) {
        return _time.sub(epochs[0].date).div(rewardsDuration);
    }

    /***************************************
                VIEWS - GENERAL
    ****************************************/

    // Number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    function decimals() external view returns (uint8) {
        return _decimals;
    }

    function name() external view returns (string memory) {
        return _name;
    }

    function symbol() external view returns (string memory) {
        return _symbol;
    }

    /***************************************
                VIEWS - REWARDS
    ****************************************/

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account) external view returns (EarnedData[] memory userRewards) {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 userRewardsLength = userRewards.length;
        for (uint256 i = 0; i < userRewardsLength; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(_account, token, userBalance.locked);
        }
        return userRewards;
    }

    function lastTimeRewardApplicable(address _rewardsToken) external view returns (uint256) {
        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken) external view returns (uint256) {
        return _rewardPerToken(_rewardsToken);
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        UserData memory data = userData[_user][_rewardsToken];
        return _balance.mul(_rewardPerToken(_rewardsToken).sub(data.rewardPerTokenPaid)).div(1e18).add(data.rewards);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {
        return AuraMath.min(block.timestamp, _finishTime);
    }

    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {
        if (lockedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(lockedSupply)
            );
    }

    /***************************************
                REWARD FUNDING
    ****************************************/

    function queueNewRewards(uint256 _rewards) external nonReentrant {
        require(rewardDistributors[cvxCrv][msg.sender], ""!authorized"");
        require(_rewards > 0, ""No reward"");

        RewardData storage rdata = rewardData[cvxCrv];

        IERC20(cvxCrv).safeTransferFrom(msg.sender, address(this), _rewards);

        _rewards = _rewards.add(queuedCvxCrvRewards);
        if (block.timestamp >= rdata.periodFinish) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
            return;
        }

        //et = now - (finish-duration)
        uint256 elapsedTime = block.timestamp.sub(rdata.periodFinish.sub(rewardsDuration.to32()));
        //current at now: rewardRate * elapsedTime
        uint256 currentAtNow = rdata.rewardRate * elapsedTime;
        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);
        if (queuedRatio < newRewardRatio) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
        } else {
            queuedCvxCrvRewards = _rewards;
        }
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward) external {
        require(_rewardsToken != cvxCrv, ""Use queueNewRewards"");
        require(rewardDistributors[_rewardsToken][msg.sender], ""Must be rewardsDistributor"");
        require(_reward > 0, ""No reward"");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), _reward);
    }

    function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {
        RewardData storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to96();
        } else {
            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();
        }

        rdata.lastUpdateTime = block.timestamp.to32();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();

        emit RewardAdded(_rewardsToken, _reward);
    }
}",7734,876,"[M-03] Improperly Skewed Governance Mechanism
The balance checkpointing system exposed by the contract for governance purposes is flawed as it does not maintain voting balances properly. In detail, the total supply of votes is tracked as the sum of all locked balances, however, the total voting power of an individual only tracks delegated balances. As a result, governance percentage thresholds will be significantly affected and potentially unmet.   [M-04] AuraLocker kick reward only takes last locked amount into consideration, instead of whole balance
The issue occurs in AuraLocker, when expired locks are processed via kicking, and if all the user locks have expired. In this scenario, to calculate the kick reward, `_processExpiredLocks` multiplies the last locked amount by the number of epochs between the last lock's unlock time and the current epoch.
  [M-06] Rewards distribution can be delayed/never distributed on AuraLocker.sol#L848
Rewards distribution can be delayed/never distributed on the function `_rewardPerToken()`
  [M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed
Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed. The platform then forced to reimburse reward to the user that got their reward locked. Causing huge economics loss.   [M-08] Locking up AURA Token does not increase voting power of individual
Per the documentation, AURA tokens can be locked in the AuraLocker to recieve vlAURA. vlAURA is voting power in the AURA ecosystem.
It is also possible for the users to delegate their voting power to a specific address by calling the `AuraLocker.delegate(address account)` function.
However, after users locked up their AURA tokens in exchange for vlAURA tokens, their voting power did not increase.
  [M-10] Increase voting power by tokenizing the address that locks the token
Without restriction on the type of address that lock the token in function `_lock`, a bad actor could lock the token through the smart contract.
  [M-14] Integer overflow will lock all rewards in AuraLocker
There is a potential overflow in the rewards calculations which would lead to `updateReward()` always reverting.
",7,,"pragma solidity ^0.8.11;
pragma experimental ABIEncoderV2;

import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts-0.8/access/Ownable.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";
import { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from ""./AuraMath.sol"";
import ""./Interfaces.sol"";

interface IRewardStaking {
    function stakeFor(address, uint256) external;
}


contract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {
    using AuraMath for uint256;
    using AuraMath224 for uint224;
    using AuraMath112 for uint112;
    using AuraMath32 for uint32;
    using SafeERC20 for IERC20;

    

    struct RewardData {
        
        uint32 periodFinish;
        
        uint32 lastUpdateTime;
        
        uint96 rewardRate;
        
        uint96 rewardPerTokenStored;
    }
    struct UserData {
        uint128 rewardPerTokenPaid;
        uint128 rewards;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Balances {
        uint112 locked;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint32 unlockTime;
    }
    struct Epoch {
        uint224 supply;
        uint32 date; 
    }
    struct DelegateeCheckpoint {
        uint224 votes;
        uint32 epochStart;
    }

    

    
    address[] public rewardTokens;
    uint256 public queuedCvxCrvRewards = 0;
    uint256 public constant newRewardRatio = 830;
    
    mapping(address => RewardData) public rewardData;
    
    mapping(address => mapping(address => bool)) public rewardDistributors;
    
    mapping(address => mapping(address => UserData)) public userData;
    
    uint256 public constant rewardsDuration = 86400 * 7;
    
    uint256 public constant lockDuration = rewardsDuration * 17;

    
    
    uint256 public lockedSupply;
    
    Epoch[] public epochs;
    
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    
    
    mapping(address => address) private _delegates;
    
    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;
    
    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;

    
    
    IERC20 public immutable stakingToken;
    address public immutable cvxCrv;
    
    uint256 public constant denominator = 10000;
    
    address public immutable cvxcrvStaking;
    
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 3;
    
    bool public isShutdown = false;

    
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    

    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateCheckpointed(address indexed delegate);

    event Recovered(address _token, uint256 _amount);
    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);
    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);
    event RewardAdded(address indexed _token, uint256 _reward);

    event KickIncentiveSet(uint256 rate, uint256 delay);
    event Shutdown();

    

    
    constructor(
        string memory _nameArg,
        string memory _symbolArg,
        address _stakingToken,
        address _cvxCrv,
        address _cvxCrvStaking
    ) Ownable() {
        _name = _nameArg;
        _symbol = _symbolArg;
        _decimals = 18;

        stakingToken = IERC20(_stakingToken);
        cvxCrv = _cvxCrv;
        cvxcrvStaking = _cvxCrvStaking;

        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));
    }

    

    modifier updateReward(address _account) {
        {
            Balances storage userBalance = balances[_account];
            uint256 rewardTokensLength = rewardTokens.length;
            for (uint256 i = 0; i < rewardTokensLength; i++) {
                address token = rewardTokens[i];
                uint256 newRewardPerToken = _rewardPerToken(token);
                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();
                if (_account != address(0)) {
                    userData[_account][token] = UserData({
                        rewardPerTokenPaid: newRewardPerToken.to128(),
                        rewards: _earned(_account, token, userBalance.locked).to128()
                    });
                }
            }
        }
        _;
    }

    

    
    function addReward(address _rewardsToken, address _distributor) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0, ""Reward already exists"");
        require(_rewardsToken != address(stakingToken), ""Cannot add StakingToken as reward"");
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0, ""Reward does not exist"");
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    
    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {
        require(_rate <= 500, ""over max rate""); 
        require(_delay >= 2, ""min delay""); 
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;

        emit KickIncentiveSet(_rate, _delay);
    }

    
    function shutdown() external onlyOwner {
        isShutdown = true;
        emit Shutdown();
    }

    
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {
        require(_tokenAddress != address(stakingToken), ""Cannot withdraw staking token"");
        require(rewardData[_tokenAddress].lastUpdateTime == 0, ""Cannot withdraw reward token"");
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);
    }

    

    
    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {
        
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        
        _lock(_account, _amount);
    }

    
    function _lock(address _account, uint256 _amount) internal {
        require(_amount > 0, ""Cannot stake 0"");
        require(!isShutdown, ""shutdown"");

        Balances storage bal = balances[_account];

        
        _checkpointEpoch();

        
        uint112 lockAmount = _amount.to112();
        bal.locked = bal.locked.add(lockAmount);

        
        lockedSupply = lockedSupply.add(_amount);

        
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
        }

        address delegatee = delegates(_account);
        if (delegatee != address(0)) {
            delegateeUnlocks[delegatee][unlockTime] += lockAmount;
            _checkpointDelegate(delegatee, lockAmount, 0);
        }

        
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(lockAmount);

        emit Staked(_account, lockAmount, lockAmount);
    }

    
    function getReward(address _account) external {
        getReward(_account, false);
    }

    
    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {
        uint256 rewardTokensLength = rewardTokens.length;
        for (uint256 i; i < rewardTokensLength; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = userData[_account][_rewardsToken].rewards;
            if (reward > 0) {
                userData[_account][_rewardsToken].rewards = 0;
                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    
    function _checkpointEpoch() internal {
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        
        
        if (epochs[epochindex - 1].date < currentEpoch) {
            
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);
                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));
            }
        }
    }

    
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        
        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));
    }

    
    function emergencyWithdraw() external nonReentrant {
        require(isShutdown, ""Must be shutdown"");

        LockedBalance[] memory locks = userLocks[msg.sender];
        Balances storage userBalance = balances[msg.sender];

        uint256 amt = userBalance.locked;
        require(amt > 0, ""Nothing locked"");

        userBalance.locked = 0;
        userBalance.nextUnlockIndex = locks.length.to32();
        lockedSupply -= amt;

        emit Withdrawn(msg.sender, amt, false);

        stakingToken.safeTransfer(msg.sender, amt);
    }

    
    function _processExpiredLocks(
        address _account,
        bool _relock,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint256 length = locks.length;
        uint256 reward = 0;
        uint256 expiryTime = _checkDelay == 0 && _relock
            ? block.timestamp.add(rewardsDuration)
            : block.timestamp.sub(_checkDelay);
        require(length > 0, ""no locks"");
        
        
        
        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {
            
            locked = userBalance.locked;

            
            userBalance.nextUnlockIndex = length.to32();

            
            
            
            
            if (_checkDelay > 0) {
                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);
                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);
            }
        } else {
            
            
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                
                if (locks[i].unlockTime > expiryTime) break;

                
                locked = locked.add(locks[i].amount);

                
                
                if (_checkDelay > 0) {
                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);
                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));
                }
                
                nextUnlockIndex++;
            }
            
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, ""no exp locks"");

        
        userBalance.locked = userBalance.locked.sub(locked);
        lockedSupply = lockedSupply.sub(locked);

        
        _checkpointDelegate(delegates(_account), 0, 0);

        emit Withdrawn(_account, locked, _relock);

        
        if (reward > 0) {
            
            locked = locked.sub(reward.to112());

            
            stakingToken.safeTransfer(_rewardAddress, reward);
            emit KickReward(_rewardAddress, _account, reward);
        }

        
        if (_relock) {
            _lock(_account, locked);
        } else {
            stakingToken.safeTransfer(_account, locked);
        }
    }

    

    
    function delegate(address newDelegatee) external virtual nonReentrant {
        
        LockedBalance[] storage locks = userLocks[msg.sender];
        uint256 len = locks.length;
        require(len > 0, ""Nothing to delegate"");
        require(newDelegatee != address(0), ""Must delegate to someone"");

        
        address oldDelegatee = delegates(msg.sender);
        require(newDelegatee != oldDelegatee, ""Must choose new delegatee"");
        _delegates[msg.sender] = newDelegatee;

        emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);

        
        
        uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
        uint256 i = len - 1;
        uint256 futureUnlocksSum = 0;
        LockedBalance memory currentLock = locks[i];
        
        while (currentLock.unlockTime > upcomingEpoch) {
            futureUnlocksSum += currentLock.amount;

            if (oldDelegatee != address(0)) {
                delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;
            }
            delegateeUnlocks[newDelegatee][currentLock.unlockTime] += currentLock.amount;

            if (i > 0) {
                i--;
                currentLock = locks[i];
            } else {
                break;
            }
        }

        
        _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);

        
        _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);
    }

    function _checkpointDelegate(
        address _account,
        uint256 _upcomingAddition,
        uint256 _upcomingDeduction
    ) internal {
        
        if (_account != address(0)) {
            uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
            DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];
            if (ckpts.length > 0) {
                DelegateeCheckpoint memory prevCkpt = ckpts[ckpts.length - 1];
                
                if (prevCkpt.epochStart == upcomingEpoch) {
                    ckpts[ckpts.length - 1] = DelegateeCheckpoint({
                        votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    });
                }
                
                
                else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (_upcomingAddition - _upcomingDeduction).to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                } else {
                    uint256 nextEpoch = upcomingEpoch;
                    uint256 unlocksSinceLatestCkpt = 0;
                    
                    while (nextEpoch > prevCkpt.epochStart) {
                        unlocksSinceLatestCkpt += delegateeUnlocks[_account][nextEpoch];
                        nextEpoch -= rewardsDuration;
                    }
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)
                                .to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                }
            } else {
                ckpts.push(
                    DelegateeCheckpoint({
                        votes: (_upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    })
                );
            }
            emit DelegateCheckpointed(_account);
        }
    }

    
    function delegates(address account) public view virtual returns (address) {
        return _delegates[account];
    }

    
    function getVotes(address account) external view returns (uint256) {
        return getPastVotes(account, block.timestamp);
    }

    
    function checkpoints(address account, uint32 pos) external view virtual returns (DelegateeCheckpoint memory) {
        return _checkpointedVotes[account][pos];
    }

    
    function numCheckpoints(address account) external view virtual returns (uint32) {
        return _checkpointedVotes[account].length.to32();
    }

    
    function getPastVotes(address account, uint256 timestamp) public view returns (uint256 votes) {
        require(timestamp <= block.timestamp, ""ERC20Votes: block not yet mined"");
        uint256 epoch = timestamp.div(rewardsDuration).mul(rewardsDuration);
        DelegateeCheckpoint memory ckpt = _checkpointsLookup(_checkpointedVotes[account], epoch);
        votes = ckpt.votes;
        if (votes == 0 || ckpt.epochStart + lockDuration <= epoch) {
            return 0;
        }
        while (epoch > ckpt.epochStart) {
            votes -= delegateeUnlocks[account][epoch];
            epoch -= rewardsDuration;
        }
    }

    
    function getPastTotalSupply(uint256 timestamp) external view returns (uint256) {
        require(timestamp < block.timestamp, ""ERC20Votes: block not yet mined"");
        return totalSupplyAtEpoch(findEpochId(timestamp));
    }

    
    function _checkpointsLookup(DelegateeCheckpoint[] storage ckpts, uint256 epochStart)
        private
        view
        returns (DelegateeCheckpoint memory)
    {
        uint256 high = ckpts.length;
        uint256 low = 0;
        while (low < high) {
            uint256 mid = AuraMath.average(low, high);
            if (ckpts[mid].epochStart > epochStart) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        return high == 0 ? DelegateeCheckpoint(0, 0) : ckpts[high - 1];
    }

    

    
    function balanceOf(address _user) external view returns (uint256 amount) {
        return balanceAtEpochOf(findEpochId(block.timestamp), _user);
    }

    
    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);

        LockedBalance[] storage locks = userLocks[_user];

        
        
        uint256 locksLength = locks.length;
        for (uint256 i = locksLength; i > 0; i--) {
            uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);
            
            
            if (lockEpoch < epochStart) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i - 1].amount);
                } else {
                    
                    break;
                }
            }
        }

        return amount;
    }

    
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    
    function totalSupply() external view returns (uint256 supply) {
        return totalSupplyAtEpoch(findEpochId(block.timestamp));
    }

    
    function totalSupplyAtEpoch(uint256 _epoch) public view returns (uint256 supply) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 lastIndex = epochs.length - 1;

        uint256 epochIndex = _epoch > lastIndex ? lastIndex : _epoch;

        for (uint256 i = epochIndex + 1; i > 0; i--) {
            Epoch memory e = epochs[i - 1];
            if (e.date == epochStart) {
                continue;
            } else if (e.date <= cutoffEpoch) {
                break;
            } else {
                supply += e.supply;
            }
        }
    }

    
    function findEpochId(uint256 _time) public view returns (uint256 epoch) {
        return _time.sub(epochs[0].date).div(rewardsDuration);
    }

    

    
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    function decimals() external view returns (uint8) {
        return _decimals;
    }

    function name() external view returns (string memory) {
        return _name;
    }

    function symbol() external view returns (string memory) {
        return _symbol;
    }

    

    
    function claimableRewards(address _account) external view returns (EarnedData[] memory userRewards) {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 userRewardsLength = userRewards.length;
        for (uint256 i = 0; i < userRewardsLength; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(_account, token, userBalance.locked);
        }
        return userRewards;
    }

    function lastTimeRewardApplicable(address _rewardsToken) external view returns (uint256) {
        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken) external view returns (uint256) {
        return _rewardPerToken(_rewardsToken);
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        UserData memory data = userData[_user][_rewardsToken];
        return _balance.mul(_rewardPerToken(_rewardsToken).sub(data.rewardPerTokenPaid)).div(1e18).add(data.rewards);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {
        return AuraMath.min(block.timestamp, _finishTime);
    }

    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {
        if (lockedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(lockedSupply)
            );
    }

    

    function queueNewRewards(uint256 _rewards) external nonReentrant {
        require(rewardDistributors[cvxCrv][msg.sender], ""!authorized"");
        require(_rewards > 0, ""No reward"");

        RewardData storage rdata = rewardData[cvxCrv];

        IERC20(cvxCrv).safeTransferFrom(msg.sender, address(this), _rewards);

        _rewards = _rewards.add(queuedCvxCrvRewards);
        if (block.timestamp >= rdata.periodFinish) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
            return;
        }

        
        uint256 elapsedTime = block.timestamp.sub(rdata.periodFinish.sub(rewardsDuration.to32()));
        
        uint256 currentAtNow = rdata.rewardRate * elapsedTime;
        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);
        if (queuedRatio < newRewardRatio) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
        } else {
            queuedCvxCrvRewards = _rewards;
        }
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward) external {
        require(_rewardsToken != cvxCrv, ""Use queueNewRewards"");
        require(rewardDistributors[_rewardsToken][msg.sender], ""Must be rewardsDistributor"");
        require(_reward > 0, ""No reward"");

        _notifyReward(_rewardsToken, _reward);

        
        
        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), _reward);
    }

    function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {
        RewardData storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to96();
        } else {
            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();
        }

        rdata.lastUpdateTime = block.timestamp.to32();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();

        emit RewardAdded(_rewardsToken, _reward);
    }
}",6073,0,7,"{
  ""task_list"": [
    {
      ""Area"": ""Reward Distribution and Accounting"",
      ""Tasks"": [
        ""Verify the accuracy of reward calculations in `_rewardPerToken` and `_earned`, particularly focusing on potential rounding errors and integer division issues."",
        ""Analyze the `updateReward` modifier to ensure it correctly updates reward data for all users and reward tokens, and assess its gas cost implications."",
        ""Confirm that the `queueNewRewards` function correctly handles the `newRewardRatio` and queued rewards, preventing manipulation of the cvxCrv reward distribution."",
        ""Check the `notifyRewardAmount` function to ensure that reward distributors are properly authorized and that rewards are distributed fairly."",
        ""Test the interaction between reward claiming (`getReward`) and cvxCrv staking in `cvxcrvStaking` to ensure rewards are correctly staked and accounted for."",
        ""Investigate potential attack vectors related to manipulating `lockedSupply` to inflate reward rates."",
        ""Analyze how the contract handles scenarios where `rewardRate` is very small or very large.""
      ]
    },
    {
      ""Area"": ""Locking and Unlocking Mechanics"",
      ""Tasks"": [
        ""Thoroughly test the `lock` and `_lock` functions to ensure tokens are correctly locked, balances are updated, and epochs are tracked accurately."",
        ""Analyze the `processExpiredLocks` and `kickExpiredLocks` functions, focusing on the logic that determines which locks are processed and the calculation of kick rewards. Consider edge cases and potential vulnerabilities."",
        ""Verify that the `emergencyWithdraw` function functions correctly when the contract is in shutdown mode and prevents withdrawals when it is not."",
        ""Assess the potential for griefing attacks in `kickExpiredLocks`, where an attacker could repeatedly kick locks to drain a user's rewards."",
        ""Ensure the `_processExpiredLocks` function correctly handles relocking and transferring tokens, preventing loss of funds."",
        ""Check for any unintended consequences of calling `processExpiredLocks` or `kickExpiredLocks` multiple times for the same user or lock.""
      ]
    },
    {
      ""Area"": ""Voting and Delegation"",
      ""Tasks"": [
        ""Verify the correctness of the delegation logic in `delegate`, `_checkpointDelegate`, and related functions, ensuring voting power is accurately transferred and tracked."",
        ""Analyze the `getPastVotes` and `getPastTotalSupply` functions to ensure they correctly retrieve historical voting power and total supply, considering epoch boundaries and lock durations."",
        ""Investigate potential vulnerabilities in the delegation checkpoint system, such as denial-of-service attacks by creating a large number of checkpoints or manipulating unlock times."",
        ""Check for edge cases related to delegating to the zero address or delegating to the same address."",
        ""Examine the gas costs associated with delegation and checkpoint updates, ensuring they are reasonable and do not create excessive overhead."",
        ""Assess how voting power is affected by users processing or kicking expired locks.""
      ]
    },
    {
      ""Area"": ""Epoch Management and Historical Data"",
      ""Tasks"": [
        ""Analyze the `_checkpointEpoch` function to ensure it correctly creates new epochs and prevents duplicate or incorrect epoch entries."",
        ""Verify the accuracy of the `balanceAtEpochOf` and `totalSupplyAtEpoch` functions, ensuring they correctly retrieve historical balances and total supply at specific epochs."",
        ""Assess the potential for denial-of-service attacks by creating a large number of epochs, potentially exhausting gas limits."",
        ""Check how the contract handles edge cases related to epoch boundaries and lock durations when calculating historical data."",
        ""Confirm that the epoch ID calculation in `findEpochId` is accurate and consistent."",
        ""Verify correct handling of first epoch creation and zero epoch id handling.""
      ]
    },
    {
      ""Area"": ""Access Control and Ownership"",
      ""Tasks"": [
        ""Verify that only the owner can call the `addReward`, `approveRewardDistributor`, `setKickIncentive`, `shutdown`, and `recoverERC20` functions."",
        ""Check for any unintended consequences of shutting down the contract using the `shutdown` function, ensuring that users can still withdraw their funds."",
        ""Analyze the `recoverERC20` function to ensure that it cannot be used to withdraw the staking token or reward tokens."",
        ""Ensure that the `setApprovals` function correctly approves the `cvxcrvStaking` contract to spend cvxCrv."",
        ""Confirm proper initialization of the `Ownable` contract during constructor execution.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas-intensive operations, such as loops in `updateReward`, `processExpiredLocks`, `getPastVotes`, `totalSupplyAtEpoch`, `balanceAtEpochOf`, and `claimableRewards`."",
        ""Assess the gas costs associated with storage reads and writes, particularly in functions that update user balances, reward data, and epoch information."",
        ""Explore opportunities to reduce gas costs by using more efficient data structures or algorithms."",
        ""Check for any redundant or unnecessary operations that can be removed to save gas."",
        ""Review the use of different integer sizes (uint32, uint96, uint112, uint128, uint224) to ensure they are used efficiently and minimize gas costs."",
        ""Use gas profiling tools to identify the most gas-consuming functions and lines of code.""
      ]
    },
    {
      ""Area"": ""External Interactions and Dependencies"",
      ""Tasks"": [
        ""Verify that all external contract calls are handled safely using `SafeERC20` and other appropriate mechanisms."",
        ""Assess the potential risks associated with interacting with the `cvxcrvStaking` contract, such as failures or unexpected behavior in the external contract."",
        ""Ensure that the contract correctly handles potential failures when transferring tokens to users or other contracts."",
        ""Check for any vulnerabilities related to untrusted input data from external sources."",
        ""Review all external interfaces to ensure they are properly defined and implemented."",
        ""If possible, perform static analysis of the `cvxcrvStaking` contract to assess potential integration risks.""
      ]
    },
    {
      ""Area"": ""Denial of Service (DoS)"",
      ""Tasks"": [
        ""Analyze potential DoS attack vectors, such as griefing attacks against `kickExpiredLocks` or exceeding gas limits in functions like `updateReward` and `processExpiredLocks`."",
        ""Verify that the contract can handle a large number of users, locks, and reward tokens without becoming unresponsive."",
        ""Assess the potential for attackers to manipulate storage variables or contract logic to prevent legitimate users from accessing their funds or claiming rewards."",
        ""Implement mitigation strategies to prevent DoS attacks, such as limiting the number of operations that can be performed in a single transaction or using pagination for large data sets.""
      ]
    },
    {
      ""Area"": ""Integer Overflow/Underflow"",
      ""Tasks"": [
          ""Although SafeMath is used, review all arithmetic operations within custom math libraries (AuraMath) for potential overflow/underflow issues, especially when dealing with large numbers or different uint sizes."",
          ""Carefully examine the conversions between different uint sizes (e.g., to32(), to96(), to112()) to ensure no data loss or unexpected behavior occurs.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The AuraLocker contract implements a complex locking and rewards mechanism, similar to the veCRV (Voting Escrow Curve) model. Users lock a specific `stakingToken` (presumably AURA) for a fixed duration (17 weeks) to receive multiple reward tokens and gain voting power. The contract manages reward distribution, delegation of voting power, epoch tracking for historical balances/supply, and processing of expired locks (including a 'kick' mechanism). It uses OpenZeppelin contracts for security (ReentrancyGuard, Ownable, SafeERC20) and custom math libraries (AuraMath) for handling specific integer sizes."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""AuraLocker"",
    ""Purpose"": ""To allow users to lock `stakingToken` for a fixed duration to earn multiple reward tokens, receive voting power based on locked amount and duration, and delegate this voting power. It manages reward distribution, lock expiry, and historical supply/balance tracking."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""ReentrancyGuard"",
        ""Ownable"",
        ""IAuraLocker""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"",
        ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"",
        ""@openzeppelin/contracts-0.8/access/Ownable.sol"",
        ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"",
        ""./AuraMath"",
        ""./Interfaces"",
        ""IRewardStaking (Interface definition within the contract)""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""rewardTokens"",
        ""Type"": ""address[]"",
        ""Purpose"": ""Array storing the addresses of reward tokens distributed by the contract.""
      },
      {
        ""Name"": ""queuedCvxCrvRewards"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Stores cvxCrv rewards that are waiting to be added to the distribution, subject to a ratio check.""
      },
      {
        ""Name"": ""newRewardRatio"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Threshold ratio used in `queueNewRewards` logic for cvxCrv.""
      },
      {
        ""Name"": ""rewardData"",
        ""Type"": ""mapping(address => RewardData)"",
        ""Purpose"": ""Maps reward token addresses to their distribution data (rate, period finish, etc.).""
      },
      {
        ""Name"": ""rewardDistributors"",
        ""Type"": ""mapping(address => mapping(address => bool))"",
        ""Purpose"": ""Maps reward token addresses to authorized distributor addresses.""
      },
      {
        ""Name"": ""userData"",
        ""Type"": ""mapping(address => mapping(address => UserData))"",
        ""Purpose"": ""Maps user addresses to their reward data per reward token (rewards earned, paid marker).""
      },
      {
        ""Name"": ""rewardsDuration"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""The duration of a reward distribution period (1 week).""
      },
      {
        ""Name"": ""lockDuration"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""The fixed duration for which tokens are locked (17 weeks).""
      },
      {
        ""Name"": ""lockedSupply"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The total amount of `stakingToken` currently locked in the contract.""
      },
      {
        ""Name"": ""epochs"",
        ""Type"": ""Epoch[]"",
        ""Purpose"": ""Array storing historical supply data per epoch start date.""
      },
      {
        ""Name"": ""balances"",
        ""Type"": ""mapping(address => Balances)"",
        ""Purpose"": ""Maps user addresses to their total locked balance and the index of the next lock to potentially unlock.""
      },
      {
        ""Name"": ""userLocks"",
        ""Type"": ""mapping(address => LockedBalance[])"",
        ""Purpose"": ""Maps user addresses to an array of their individual lock entries (amount, unlock time).""
      },
      {
        ""Name"": ""_delegates"",
        ""Type"": ""mapping(address => address)"",
        ""Purpose"": ""Maps delegator addresses to their chosen delegatee address.""
      },
      {
        ""Name"": ""_checkpointedVotes"",
        ""Type"": ""mapping(address => DelegateeCheckpoint[])"",
        ""Purpose"": ""Maps delegatee addresses to an array of vote checkpoints for historical voting power.""
      },
      {
        ""Name"": ""delegateeUnlocks"",
        ""Type"": ""mapping(address => mapping(uint256 => uint256))"",
        ""Purpose"": ""Maps delegatee addresses to unlock times to the amount unlocking at that time.""
      },
      {
        ""Name"": ""stakingToken"",
        ""Type"": ""IERC20 immutable"",
        ""Purpose"": ""The ERC20 token that users lock (e.g., AURA).""
      },
      {
        ""Name"": ""cvxCrv"",
        ""Type"": ""address immutable"",
        ""Purpose"": ""The address of the cvxCRV token, treated as a special reward token.""
      },
      {
        ""Name"": ""denominator"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Denominator used for percentage calculations (10000 = 100%).""
      },
      {
        ""Name"": ""cvxcrvStaking"",
        ""Type"": ""address immutable"",
        ""Purpose"": ""The address of the contract where earned cvxCrv rewards can optionally be staked.""
      },
      {
        ""Name"": ""kickRewardPerEpoch"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Percentage reward (scaled by `denominator`) given per epoch delay for kicking expired locks.""
      },
      {
        ""Name"": ""kickRewardEpochDelay"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Number of epochs a lock must be expired before it can be kicked.""
      },
      {
        ""Name"": ""isShutdown"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to indicate if the contract is in shutdown mode, allowing emergency withdrawals.""
      },
      {
        ""Name"": ""_name"",
        ""Type"": ""string"",
        ""Purpose"": ""The name of the locked token representation (e.g., \""vlAURA\"").""
      },
      {
        ""Name"": ""_symbol"",
        ""Type"": ""string"",
        ""Purpose"": ""The symbol of the locked token representation (e.g., \""vlAURA\"").""
      },
      {
        ""Name"": ""_decimals"",
        ""Type"": ""uint8 immutable"",
        ""Purpose"": ""The decimals of the locked token representation (usually 18).""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""updateReward"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Updates reward calculations for a given account before executing the modified function."",
        ""Parameters"": [""address _account""],
        ""Returns"": []
      },
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes contract state including name, symbol, immutable addresses, and the first epoch."",
        ""Parameters"": [""string memory _nameArg"", ""string memory _symbolArg"", ""address _stakingToken"", ""address _cvxCrv"", ""address _cvxCrvStaking""],
        ""Returns"": []
      },
      {
        ""Name"": ""addReward"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to add a new reward token and its initial distributor."",
        ""Parameters"": [""address _rewardsToken"", ""address _distributor""],
        ""Returns"": []
      },
      {
        ""Name"": ""approveRewardDistributor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to approve or revoke a reward distributor for a specific token."",
        ""Parameters"": [""address _rewardsToken"", ""address _distributor"", ""bool _approved""],
        ""Returns"": []
      },
      {
        ""Name"": ""setKickIncentive"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to set the rate and delay for the kick reward mechanism."",
        ""Parameters"": [""uint256 _rate"", ""uint256 _delay""],
        ""Returns"": []
      },
      {
        ""Name"": ""shutdown"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to trigger the shutdown mode."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""recoverERC20"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to recover non-essential/non-reward ERC20 tokens sent to the contract."",
        ""Parameters"": [""address _tokenAddress"", ""uint256 _tokenAmount""],
        ""Returns"": []
      },
      {
        ""Name"": ""setApprovals"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Approves the `cvxcrvStaking` contract to spend the Locker's cvxCrv."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""lock"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user (or someone on their behalf) to lock `stakingToken` for the fixed duration."",
        ""Parameters"": [""address _account"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_lock"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal logic for handling token locking, updating balances, supply, epochs, and delegation."",
        ""Parameters"": [""address _account"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""getReward (1 param)"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Claims all pending rewards for the caller."",
        ""Parameters"": [""address _account""],
        ""Returns"": []
      },
      {
        ""Name"": ""getReward (2 params)"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Claims all pending rewards for a specified account, with an option to stake claimed cvxCrv."",
        ""Parameters"": [""address _account"", ""bool _stake""],
        ""Returns"": []
      },
      {
        ""Name"": ""checkpointEpoch"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Public function to trigger the creation of a new epoch checkpoint if necessary."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_checkpointEpoch"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal logic to create new epoch entries if the current time has moved past the latest epoch date."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""processExpiredLocks"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to process their own expired locks, either withdrawing or relocking them."",
        ""Parameters"": [""bool _relock""],
        ""Returns"": []
      },
      {
        ""Name"": ""kickExpiredLocks"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows anyone to process another user's expired locks (after a delay), receiving a kick reward."",
        ""Parameters"": [""address _account""],
        ""Returns"": []
      },
      {
        ""Name"": ""_processExpiredLocks"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal logic for handling expired locks, calculating kick rewards, updating balances, and transferring/relocking tokens."",
        ""Parameters"": [""address _account"", ""bool _relock"", ""address _rewardAddress"", ""uint256 _checkDelay""],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to withdraw their total locked balance immediately if the contract is shut down."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""delegate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to delegate their voting power to another address."",
        ""Parameters"": [""address newDelegatee""],
        ""Returns"": []
      },
      {
        ""Name"": ""_checkpointDelegate"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Updates the vote checkpoints for a delegatee when their voting power changes."",
        ""Parameters"": [""address _account"", ""uint256 _upcomingAddition"", ""uint256 _upcomingDeduction""],
        ""Returns"": []
      },
      {
        ""Name"": ""delegates"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the delegatee for a given account."",
        ""Parameters"": [""address account""],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""getVotes"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the current voting power of an account."",
        ""Parameters"": [""address account""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""checkpoints"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns a specific vote checkpoint for an account."",
        ""Parameters"": [""address account"", ""uint32 pos""],
        ""Returns"": [""DelegateeCheckpoint memory""]
      },
      {
        ""Name"": ""numCheckpoints"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the number of vote checkpoints for an account."",
        ""Parameters"": [""address account""],
        ""Returns"": [""uint32""]
      },
      {
        ""Name"": ""getPastVotes"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the voting power of an account at a specific past timestamp."",
        ""Parameters"": [""address account"", ""uint256 timestamp""],
        ""Returns"": [""uint256 votes""]
      },
      {
        ""Name"": ""getPastTotalSupply"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the total locked supply eligible for voting at a specific past timestamp."",
        ""Parameters"": [""uint256 timestamp""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_checkpointsLookup"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal helper function to find the relevant vote checkpoint for a given epoch start time using binary search."",
        ""Parameters"": [""DelegateeCheckpoint[] storage ckpts"", ""uint256 epochStart""],
        ""Returns"": [""DelegateeCheckpoint memory""]
      },
      {
        ""Name"": ""balanceOf"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the current locked balance of a user (acting like an ERC20 balance)."",
        ""Parameters"": [""address _user""],
        ""Returns"": [""uint256 amount""]
      },
      {
        ""Name"": ""balanceAtEpochOf"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the locked balance of a user at a specific past epoch."",
        ""Parameters"": [""uint256 _epoch"", ""address _user""],
        ""Returns"": [""uint256 amount""]
      },
      {
        ""Name"": ""lockedBalances"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns detailed information about a user's locks: total, unlockable, currently locked, and details of future locks."",
        ""Parameters"": [""address _user""],
        ""Returns"": [""uint256 total"", ""uint256 unlockable"", ""uint256 locked"", ""LockedBalance[] memory lockData""]
      },
      {
        ""Name"": ""totalSupply"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the current total locked supply (acting like an ERC20 totalSupply)."",
        ""Parameters"": [],
        ""Returns"": [""uint256 supply""]
      },
      {
        ""Name"": ""totalSupplyAtEpoch"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the total locked supply at a specific past epoch."",
        ""Parameters"": [""uint256 _epoch""],
        ""Returns"": [""uint256 supply""]
      },
      {
        ""Name"": ""findEpochId"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the epoch ID corresponding to a given timestamp."",
        ""Parameters"": [""uint256 _time""],
        ""Returns"": [""uint256 epoch""]
      },
      {
        ""Name"": ""epochCount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the total number of epochs created."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""decimals"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the decimals for the locked token representation."",
        ""Parameters"": [],
        ""Returns"": [""uint8""]
      },
      {
        ""Name"": ""name"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the name of the locked token representation."",
        ""Parameters"": [],
        ""Returns"": [""string memory""]
      },
      {
        ""Name"": ""symbol"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the symbol of the locked token representation."",
        ""Parameters"": [],
        ""Returns"": [""string memory""]
      },
      {
        ""Name"": ""claimableRewards"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the amount of each reward token currently claimable by an account."",
        ""Parameters"": [""address _account""],
        ""Returns"": [""EarnedData[] memory userRewards""]
      },
      {
        ""Name"": ""lastTimeRewardApplicable"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the timestamp until which rewards have been effectively distributed for a given token."",
        ""Parameters"": [""address _rewardsToken""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""rewardPerToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the current cumulative reward per locked token for a given reward token."",
        ""Parameters"": [""address _rewardsToken""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_earned"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates the total rewards earned (including pending) for a user and a specific reward token."",
        ""Parameters"": [""address _user"", ""address _rewardsToken"", ""uint256 _balance""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_lastTimeRewardApplicable"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Helper to determine the time boundary for reward calculations."",
        ""Parameters"": [""uint256 _finishTime""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_rewardPerToken"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates the cumulative reward per token up to the current moment."",
        ""Parameters"": [""address _rewardsToken""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""queueNewRewards"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds cvxCrv rewards to the contract, potentially queuing them based on timing and amount."",
        ""Parameters"": [""uint256 _rewards""],
        ""Returns"": []
      },
      {
        ""Name"": ""notifyRewardAmount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds rewards for tokens other than cvxCrv, updating the distribution rate."",
        ""Parameters"": [""address _rewardsToken"", ""uint256 _reward""],
        ""Returns"": []
      },
      {
        ""Name"": ""_notifyReward"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal logic to update reward data (rate, period finish) when new rewards are added."",
        ""Parameters"": [""address _rewardsToken"", ""uint256 _reward""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20 `stakingToken`: Transfers tokens from users (`lock`) and back to users (`_processExpiredLocks`, `emergencyWithdraw`)."",
    ""IERC20 `cvxCrv`: Transfers tokens from distributors (`queueNewRewards`), potentially to users (`getReward`), and approves `cvxcrvStaking` (`setApprovals`)."",
    ""IRewardStaking `cvxcrvStaking`: Stakes cvxCrv rewards on behalf of users (`getReward`)."",
    ""IERC20 `rewardTokens` (other than cvxCrv): Transfers tokens from distributors (`notifyRewardAmount`) and to users (`getReward`)."",
    ""Owner Address: Receives recovered ERC20 tokens (`recoverERC20`).""
  ],
  ""SpecialMechanisms"": [
    ""Voting Escrow Model: Fixed-term locking (`lockDuration`) for rewards and voting power."",
    ""Multi-Reward Distribution: Handles multiple reward tokens using a `rewardPerToken` calculation similar to Synthetix/Uniswap."",
    ""Epoch System: Divides time into weeks (`rewardsDuration`) to track historical balances and total supply (`epochs`, `balanceAtEpochOf`, `totalSupplyAtEpoch`)."",
    ""Delegation: ERC20Votes-like delegation (`delegate`, `getPastVotes`) adapted for locked balances, using checkpoints (`_checkpointDelegate`, `_checkpointedVotes`)."",
    ""Lock Kicking: Incentive mechanism (`kickRewardPerEpoch`, `kickExpiredLocks`) for processing expired locks."",
    ""Special `cvxCrv` Handling: Uses `queueNewRewards` with a ratio check (`newRewardRatio`) to potentially smooth out cvxCrv reward distribution."",
    ""Custom Math Libraries (`AuraMath*`): Used for safe arithmetic and type conversions between various uint sizes."",
    ""Reentrancy Guard: Protects key state-changing functions (`lock`, `getReward`, `processExpiredLocks`, `kickExpiredLocks`, `emergencyWithdraw`, `delegate`, `queueNewRewards`)."",
    ""Ownership Control (`Ownable`): Restricts administrative functions."",
    ""Safe ERC20 Wrappers (`SafeERC20`): Used for safer interaction with ERC20 tokens.""
  ],
  ""Questions"": [
    ""How are potential precision issues handled with the extensive use of different fixed-size uint types (uint32, uint96, uint112, uint128, uint224) and divisions, especially within `AuraMath` and reward calculations?"",
    ""Are there gas limits associated with loops in functions like `updateReward` (over `rewardTokens`), `processExpiredLocks` (over `userLocks`), `getPastVotes` (over time), `totalSupplyAtEpoch` (over `epochs`), `balanceAtEpochOf` (over `userLocks`), and `claimableRewards` (over `rewardTokens`)? Could these become prohibitively expensive?"",
    ""Is the delegation checkpoint logic (`_checkpointDelegate`, `getPastVotes`, `_checkpointsLookup`) robust against edge cases, such as frequent delegate changes or a very large number of checkpoints?"",
    ""What is the precise mechanism and rationale behind the `newRewardRatio` check in `queueNewRewards` for cvxCrv?"",
    ""What are the full implications of `isShutdown`? Does it halt reward accrual or only locking and withdrawal processes? (Code suggests `processExpiredLocks` might still run)."",
    ""How does the contract handle potential failures or unexpected behavior in the external `cvxcrvStaking` contract?"",
    ""Is the binary search implementation in `_checkpointsLookup` correct for all edge cases (empty array, exact match, value before first checkpoint)?"",
    ""Could the `kickExpiredLocks` reward calculation (`rRate`) potentially exceed the locked amount due to accumulated epochs, despite the `AuraMath.min` check against `denominator`? (Seems unlikely as `rRate` is applied to the amount, but worth confirming)."",
    ""How is the initial epoch `epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));` handled in calculations like `totalSupplyAtEpoch` if the requested epoch is 0?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `getReward` Function when staking cvxCrv"",
      ""Severity"": ""High"",
      ""Description"": ""The `getReward` function allows users to claim rewards, and when staking `cvxCrv` rewards, the contract calls `stakeFor` on the `cvxcrvStaking` contract. If this external contract has a reentrancy vulnerability, it can be exploited to manipulate state and steal funds, even with the `ReentrancyGuard` in AuraLocker."",
      ""Impact"": ""Potential theft of funds due to reentrancy vulnerability."",
      ""Location"": ""getReward function""
    },
    {
      ""Issue"": ""Potential Reentrancy Risk in `_processExpiredLocks` due to External Transfer"",
      ""Severity"": ""High"",
      ""Description"": ""The `_processExpiredLocks` function performs an external token transfer which, if malicious, could re-enter the `AuraLocker` contract and potentially manipulate state variables before the original function completes, even with `ReentrancyGuard`. This is because state updates related to locked balances are completed *before* the external transfer."",
      ""Impact"": ""Significant risk of state manipulation during the transfer leading to potentially draining tokens or other unexpected behaviors."",
      ""Location"": ""_processExpiredLocks function""
    },
    {
      ""Issue"": ""Potential Vulnerability: Front-Running in `queueNewRewards` leading to reward draining"",
      ""Severity"": ""High"",
      ""Description"": ""An attacker can front-run a call to `queueNewRewards` to manipulate the `lockedSupply` to increase their reward share, potentially stealing rewards intended for other stakers."",
      ""Impact"": ""Unauthorized draining of rewards intended for other stakers."",
      ""Location"": ""queueNewRewards function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Reward and Epoch Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Calculations in `_earned`, `_processExpiredLocks`, and related functions involving `rewardRate`, `lockedSupply`, time differences (`epochsover`), and the use of `AuraMath` libraries for smaller uint types, lack sufficient overflow/underflow checks, potentially leading to incorrect reward distribution or denial of service. Calculations involving `epochsover` in `_processExpiredLocks` could also lead to incorrect reward amounts. `_earned` subtracts `data.rewardPerTokenPaid` from `_rewardPerToken`, which may lead to unexpected payouts."",
      ""Impact"": ""Incorrect reward calculation, potentially leading to loss of funds for users or the contract owner. Denial of service if calculations revert due to overflows or underflows. High reward amounts or draining funds."",
      ""Location"": ""_earned, _rewardPerToken, _processExpiredLocks functions""
    },
    {
      ""Issue"": ""Potential Denial of Service in `processExpiredLocks` and `kickExpiredLocks` due to unbounded loop"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_processExpiredLocks` function, used by `processExpiredLocks` and `kickExpiredLocks`, iterates through `userLocks[_account]` to find expired locks. A user with a large number of expired locks could consume excessive gas, potentially exceeding the block gas limit and causing a denial of service."",
      ""Impact"": ""Denial of service by making it impossible or prohibitively expensive to process expired locks. Also prevents users from withdrawing tokens."",
      ""Location"": ""_processExpiredLocks function""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `queueNewRewards` and Delegate Changes"",
      ""Severity"": ""Medium"",
      ""Description"": ""A front-runner could manipulate reward distribution timing in `queueNewRewards` by observing transactions and altering conditions to influence whether rewards are immediately distributed or queued. Delegate changes also rely on `block.timestamp` making it possible for miners to adjust the timestamp to impact the upcomingEpoch."",
      ""Impact"": ""Disruption of intended reward distribution schedule, potentially benefiting front-runners and vote manipulation."",
      ""Location"": ""queueNewRewards function, delegate function, _checkpointDelegate function""
    },
    {
      ""Issue"": ""Inconsistent handling of unlock times during delegation can lead to incorrect voting power"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `delegate` function calculates unlocks based on future unlocks. If locks are not sorted by `unlockTime` or expired locks are processed before delegating, the unlock information might not accurately reflect actual unlock times, and the logic may skip unlocks leading to incorrect voting power calculation."",
      ""Impact"": ""Inaccurate voting power, potentially manipulating governance decisions."",
      ""Location"": ""delegate function""
    },
    {
      ""Issue"": ""Centralization Risk via `Ownable` Contract"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract inherits from `Ownable`, meaning a single address has privileged control over critical functions such as `addReward`, `approveRewardDistributor`, etc. This creates a centralization risk, as the owner could potentially act maliciously or be compromised, leading to a loss of funds or disruption of the contract’s functionality."",
      ""Impact"": ""Risk of malicious actions or compromise of the owner account leading to fund loss or contract malfunction."",
      ""Location"": ""AuraLocker.sol:constructor, AuraLocker.sol:addReward, AuraLocker.sol:approveRewardDistributor, AuraLocker.sol:setKickIncentive, AuraLocker.sol:shutdown, AuraLocker.sol:recoverERC20""
    },
    {
      ""Issue"": ""Potential for Incorrect Vote Calculation in `getPastVotes` due to Integer Underflow"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `getPastVotes` function, the `votes` are decremented. If the initial value of `votes` is smaller than the cumulative sum of unlocks, an integer underflow will occur, potentially resulting in a very large value for votes."",
      ""Impact"": ""Incorrect vote calculation, potentially leading to manipulation of governance or other voting-related functionalities."",
      ""Location"": ""getPastVotes function""
    },
    {
      ""Issue"": ""Potential Griefing Attack on `kickExpiredLocks` due to Front Running"",
      ""Severity"": ""Medium"",
      ""Description"": ""An attacker could front-run the transaction of the actual owner calling `processExpiredLocks` by calling `kickExpiredLocks` before them. This can lead to the attacker receiving the kick reward instead of the owner, and potentially affect the owner's claimable rewards."",
      ""Impact"": ""An attacker can steal kick rewards intended for the owner of the locks. Can also potentially alter the owner's state and rewards."",
      ""Location"": ""kickExpiredLocks function""
    },
    {
      ""Issue"": ""Integer Truncation Vulnerability in Time-Related Operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses `uint32` to represent timestamps and epoch dates.  The contract's long-term functionality could face issues in the future (beyond 2106) when `block.timestamp` exceeds the maximum value of `uint32`. This can cause unexpected behavior in time sensitive functions."",
      ""Impact"": ""Contract malfunction and incorrect reward distribution after 2106."",
      ""Location"": ""AuraLocker.sol (multiple locations using uint32 for time-related fields)""
    },
    {
      ""Issue"": ""Race condition in `delegate` function leading to inconsistent vote accounting"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `delegate` function calculates `futureUnlocksSum` by iterating through `userLocks` while concurrently, other users might be staking, withdrawing or processing expired locks, which could modify the `userLocks` array while the delegation process is in progress."",
      ""Impact"": ""Inaccurate vote delegation can skew governance decisions."",
      ""Location"": ""AuraLocker.sol:delegate""
    },
    {
      ""Issue"": ""Lack of Access Control on `setApprovals` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setApprovals` function, which approves `cvxcrvStaking` to spend `cvxCrv`, lacks any access control, allowing anyone to call it. Checks for `kickRewardPerEpoch` and `kickRewardEpochDelay` may not be sufficient to prevent unintended consequences. There is also no verification of minimum value of `kickRewardPerEpoch`, which could lead to unexpected behavior."",
      ""Impact"": ""Potential for gas griefing or minor disruption of contract functionality and  kick reward might become ineffective if `kickRewardPerEpoch` is set too low."",
      ""Location"": ""setApprovals function, setKickIncentive function""
    },
    {
      ""Issue"": ""Improper Handling of Epoch Supply after Shutdown and Inconsistency Between Balances and Locked Values After Emergency Withdraw"",
      ""Severity"": ""Low"",
      ""Description"": ""The `shutdown` function doesn't prevent `processExpiredLocks` from being called, potentially causing discrepancies in historical supply data.  After an emergency withdraw, user locks are not cleared, resulting in unused storage."",
      ""Impact"": ""Inconsistent historical data regarding total supply after the contract is shut down and storage not being cleaned up."",
      ""Location"": ""shutdown, _processExpiredLocks, totalSupplyAtEpoch, getPastTotalSupply, emergencyWithdraw""
    },
    {
      ""Issue"": ""DelegateeUnlock Checkpoint Calculation Inaccuracy and Delegatee Checkpoint Logic"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_checkpointDelegate` function's loop can lead to vote calculation inaccuracies if multiple unlocks occur in the same epoch. The logic of `_checkpointDelegate` can lead to unexpected results if delegate is frequently changed when near end of the lock duration or the upcoming epoch."",
      ""Impact"": ""Inaccurate vote calculation and ranking, and voting power changes unpredictably due to frequent delegate changes."",
      ""Location"": ""_checkpointDelegate""
    },
    {
      ""Issue"": ""Potential Inconsistency Between `delegateeUnlocks` and Actual Lock Data"",
      ""Severity"": ""Low"",
      ""Description"": ""The `delegate` function updates `delegateeUnlocks` based on *future* unlocks. If a user processes expired locks before delegating, the `delegateeUnlocks` mapping may not accurately reflect the actual unlock times as some have already been processed."",
      ""Impact"": ""Slight inaccuracies in vote calculation in specific scenarios, mainly concerning delegated votes and unlock times."",
      ""Location"": ""delegate function and its interactions with _checkpointDelegate and delegateeUnlocks""
    },
    {
      ""Issue"": ""Unnecessary Check in `recoverERC20` and Incorrect check in `recoverERC20` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The check `rewardData[_tokenAddress].lastUpdateTime == 0` in `recoverERC20` is redundant. The `recoverERC20` function has a check that logic is reversed preventing recovery of any other token."",
      ""Impact"": ""Code clarity, removing the redundant check makes the function slightly more efficient and owner can recover reward tokens. Owner can not recover other tokens."",
      ""Location"": ""recoverERC20 function""
    },
    {
      ""Issue"": ""Use of `AuraMath.min` in `_lastTimeRewardApplicable` may introduce rounding errors and Imprecise Calculation of Epochs Over and Imprecise Calculation of Expired Lock Kick Reward"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_lastTimeRewardApplicable` function uses `AuraMath.min`, which might introduce slight rounding errors. The calculation of epochsover uses integer division, potentially truncating results. Imprecise calculations in the kick reward and `kickRewardPerEpoch` may lead to the user claiming more kick rewards."",
      ""Impact"": ""Slight inaccuracies in reward distribution and lower kick rewards than anticipated in certain edge cases."",
      ""Location"": ""_lastTimeRewardApplicable function, _processExpiredLocks, calculation of epochsover.""
    },
    {
      ""Issue"": ""Unbounded array `rewardTokens` can cause gas issues when iterating"",
      ""Severity"": ""Low"",
      ""Description"": ""The `rewardTokens` array can grow indefinitely, increasing the gas cost of iterating through it in `updateReward` and `claimableRewards`."",
      ""Impact"": ""Increased gas costs for transactions involving reward calculations."",
      ""Location"": ""Functions that iterate through the `rewardTokens` array""
    },
    {
      ""Issue"": ""Limited precision when calculating the kick reward"",
      ""Severity"": ""Low"",
      ""Description"": ""The kick reward calculation in `_processExpiredLocks` divides `locks[i].amount` by `denominator` which is equal to 10000. If `locks[i].amount` is significantly smaller than `denominator`, the result will be rounded down to zero, effectively nullifying the kick reward."",
      ""Impact"": ""Reduced effectiveness of the kick incentive mechanism."",
      ""Location"": ""AuraLocker.sol:_processExpiredLocks""
    },
    {
      ""Issue"": ""Use of `unsafe` Subtraction"",
      ""Severity"": ""Informational"",
      ""Description"": ""The `AuraMath` library uses 'unsafe' subtraction that reverts when an underflow occurs."",
      ""Impact"": ""Code readabilty, potential future updates"",
      ""Location"": ""AuraMath libary, the sub function""
    }
  ],
  ""IssueNumber"": 52,
  ""OutputList"": 20
}",254.99519300460813,4428.0,32.0,"### **Summary of Matches and Gaps**

---

#### **[M-03] Improperly Skewed Governance Mechanism**

**Report Description**:  
The balance checkpointing system for governance is flawed because it does not properly maintain voting balances. The total supply of votes is tracked as the sum of all locked balances, but individual voting power only tracks delegated balances. This discrepancy can significantly affect governance percentage thresholds, potentially causing them to be unmet.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of improperly skewed governance mechanisms or the discrepancy between total voting supply and individual voting power. This is a critical governance issue that is entirely missed.

---

#### **[M-04] AuraLocker kick reward only takes last locked amount into consideration, instead of whole balance**

**Report Description**:  
When expired locks are processed via kicking in `AuraLocker`, the kick reward calculation only considers the last locked amount instead of the entire balance. This can lead to incorrect reward distribution, especially if all user locks have expired.

**Match in Response List**:  
Matches with the issue titled **""Limited precision when calculating the kick reward""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with kick reward calculation but focuses on precision and rounding errors rather than the core problem of using only the last locked amount instead of the entire balance. The response partially addresses the issue but misses the critical detail.

---

#### **[M-06] Rewards distribution can be delayed/never distributed on AuraLocker.sol#L848**

**Report Description**:  
Rewards distribution can be delayed or never distributed in the `_rewardPerToken()` function, potentially leading to users not receiving their rewards in a timely manner or at all.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of delayed or failed rewards distribution in the `_rewardPerToken()` function. This is a significant oversight.

---

#### **[M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed**

**Report Description**:  
If a user does not claim their reward for a very long time, the reward may be locked forever due to the passage of too many epochs. This could force the platform to reimburse the user, causing significant economic loss.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of rewards being locked forever due to the passage of too many epochs. This is a critical economic risk that is entirely missed.

---

#### **[M-08] Locking up AURA Token does not increase voting power of individual**

**Report Description**:  
Per the documentation, locking AURA tokens should grant voting power (vlAURA). However, after users lock their tokens, their voting power does not increase, which contradicts the intended functionality.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of locked AURA tokens not increasing voting power. This is a significant governance issue that is entirely missed.

---

#### **[M-10] Increase voting power by tokenizing the address that locks the token**

**Report Description**:  
The `_lock` function does not restrict the type of address that can lock tokens, allowing a bad actor to lock tokens through a smart contract, potentially increasing their voting power unfairly.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unrestricted token locking by smart contracts, which could lead to unfair voting power increases. This is a critical governance issue that is entirely missed.

---

#### **[M-14] Integer overflow will lock all rewards in AuraLocker**

**Report Description**:  
There is a potential integer overflow in the rewards calculations, which could cause `updateReward()` to always revert, effectively locking all rewards.

**Match in Response List**:  
Matches with the issue titled **""Potential Integer Overflow/Underflow in Reward and Epoch Calculation""**.

**Validation**:  
**Correct**. The response accurately identifies the risk of integer overflow in reward calculations, which aligns with the issue described in the report. The response correctly explains the potential impact of this vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-14] Integer overflow will lock all rewards in AuraLocker**

**Partially Correct Matches**:

- **[M-04] AuraLocker kick reward only takes last locked amount into consideration, instead of whole balance**

**Missed Issues from Issue Report**:

- **[M-03] Improperly Skewed Governance Mechanism**
- **[M-06] Rewards distribution can be delayed/never distributed on AuraLocker.sol#L848**
- **[M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed**
- **[M-08] Locking up AURA Token does not increase voting power of individual**
- **[M-10] Increase voting power by tokenizing the address that locks the token**

--- 

The response list covers some issues but misses several critical vulnerabilities, particularly those related to governance and reward distribution. Improvements are needed to address these gaps comprehensively.","```
1. Potential Integer Overflow/Underflow in Reward and Epoch Calculation
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Potential Integer Overflow/Underflow in Reward and Epoch Calculation"".
   - This issue appears at **rank 4** in the ranked list of predictions.

2. **Calculate the precision at rank 4**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Up to rank 4, there is **1 true positive**.
   - \( P@4 = \frac{1}{4} = 0.25 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - \( AP = 0.25 \).

**Output**:
```
0.25
```"
ConvexMasterChef.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Context.sol"";
import ""@openzeppelin/contracts-0.6/access/Ownable.sol"";
import ""./interfaces/IRewarder.sol"";

/**
 * @title   ConvexMasterChef
 * @author  ConvexFinance
 * @notice  Masterchef can distribute rewards to n pools over x time
 * @dev     There are some caveats with this usage - once it's turned on it can't be turned off,
 *          and thus it can over complicate the distribution of these rewards.
 *          To kick things off, just transfer CVX here and add some pools - rewards will be distributed
 *          pro-rata based on the allocation points in each pool vs the total alloc.
 */
contract ConvexMasterChef is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    // Info of each user.
    struct UserInfo {
        uint256 amount; // How many LP tokens the user has provided.
        uint256 rewardDebt; // Reward debt. See explanation below.
        //
        // We do some fancy math here. Basically, any point in time, the amount of CVXs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accCvxPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. The pool's `accCvxPerShare` (and `lastRewardBlock`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. User's `amount` gets updated.
        //   4. User's `rewardDebt` gets updated.
    }

    // Info of each pool.
    struct PoolInfo {
        IERC20 lpToken; // Address of LP token contract.
        uint256 allocPoint; // How many allocation points assigned to this pool. CVX to distribute per block.
        uint256 lastRewardBlock; // Last block number that CVXs distribution occurs.
        uint256 accCvxPerShare; // Accumulated CVXs per share, times 1e12. See below.
        IRewarder rewarder;
    }

    //cvx
    IERC20 public immutable cvx;
    // CVX tokens created per block.
    uint256 public immutable rewardPerBlock;
    // Bonus muliplier for early cvx makers.
    uint256 public constant BONUS_MULTIPLIER = 2;

    // Info of each pool.
    PoolInfo[] public poolInfo;
    // Info of each user that stakes LP tokens.
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    // Total allocation points. Must be the sum of all allocation points in all pools.
    uint256 public totalAllocPoint = 0;
    // The block number when CVX mining starts.
    uint256 public immutable startBlock;
    uint256 public immutable endBlock;

    // Events
    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);
    event EmergencyWithdraw(
        address indexed user,
        uint256 indexed pid,
        uint256 amount
    );

    constructor(
        IERC20 _cvx,
        uint256 _rewardPerBlock,
        uint256 _startBlock,
        uint256 _endBlock
    ) public {
        cvx = _cvx;
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
        endBlock = _endBlock;
    }

    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    // Add a new lp to the pool. Can only be called by the owner.
    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.
    function add(
        uint256 _allocPoint,
        IERC20 _lpToken,
        IRewarder _rewarder,
        bool _withUpdate
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        uint256 lastRewardBlock = block.number > startBlock
            ? block.number
            : startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocPoint);
        poolInfo.push(
            PoolInfo({
                lpToken: _lpToken,
                allocPoint: _allocPoint,
                lastRewardBlock: lastRewardBlock,
                accCvxPerShare: 0,
                rewarder: _rewarder
            })
        );
    }

    // Update the given pool's CVX allocation point. Can only be called by the owner.
    function set(
        uint256 _pid,
        uint256 _allocPoint,
        IRewarder _rewarder,
        bool _withUpdate,
        bool _updateRewarder
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(
            _allocPoint
        );
        poolInfo[_pid].allocPoint = _allocPoint;
        if(_updateRewarder){
            poolInfo[_pid].rewarder = _rewarder;
        }
    }

    // Return reward multiplier over the given _from to _to block.
    function getMultiplier(uint256 _from, uint256 _to)
        public
        view
        returns (uint256)
    {
        uint256 clampedTo = _to > endBlock ? endBlock : _to;
        uint256 clampedFrom = _from > endBlock ? endBlock : _from;
        return clampedTo.sub(clampedFrom);
    }

    // View function to see pending CVXs on frontend.
    function pendingCvx(uint256 _pid, address _user)
        external
        view
        returns (uint256)
    {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint256 accCvxPerShare = pool.accCvxPerShare;
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint256 multiplier = getMultiplier(
                pool.lastRewardBlock,
                block.number
            );
            uint256 cvxReward = multiplier
                .mul(rewardPerBlock)
                .mul(pool.allocPoint)
                .div(totalAllocPoint);
            accCvxPerShare = accCvxPerShare.add(
                cvxReward.mul(1e12).div(lpSupply)
            );
        }
        return user.amount.mul(accCvxPerShare).div(1e12).sub(user.rewardDebt);
    }

    // Update reward vairables for all pools. Be careful of gas spending!
    function massUpdatePools() public {
        uint256 length = poolInfo.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            updatePool(pid);
        }
    }

    // Update reward variables of the given pool to be up-to-date.
    function updatePool(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (lpSupply == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint256 cvxReward = multiplier
            .mul(rewardPerBlock)
            .mul(pool.allocPoint)
            .div(totalAllocPoint);
        //cvx.mint(address(this), cvxReward);
        pool.accCvxPerShare = pool.accCvxPerShare.add(
            cvxReward.mul(1e12).div(lpSupply)
        );
        pool.lastRewardBlock = block.number;
    }

    // Deposit LP tokens to MasterChef for CVX allocation.
    function deposit(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid);
        if (user.amount > 0) {
            uint256 pending = user
                .amount
                .mul(pool.accCvxPerShare)
                .div(1e12)
                .sub(user.rewardDebt);
            safeRewardTransfer(msg.sender, pending);
        }
        pool.lpToken.safeTransferFrom(
            address(msg.sender),
            address(this),
            _amount
        );
        user.amount = user.amount.add(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);
        }

        emit Deposit(msg.sender, _pid, _amount);
    }

    // Withdraw LP tokens from MasterChef.
    function withdraw(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""withdraw: not good"");
        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(msg.sender, pending);
        user.amount = user.amount.sub(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);
        pool.lpToken.safeTransfer(address(msg.sender), _amount);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);
        }

        emit RewardPaid(msg.sender, _pid, pending);
        emit Withdraw(msg.sender, _pid, _amount);
    }

    function claim(uint256 _pid, address _account) external{
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_account];

        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(_account, pending);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, _account, _account, pending, user.amount);
        }

        emit RewardPaid(_account, _pid, pending);
    }

    // Withdraw without caring about rewards. EMERGENCY ONLY.
    function emergencyWithdraw(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        pool.lpToken.safeTransfer(address(msg.sender), user.amount);
        emit EmergencyWithdraw(msg.sender, _pid, user.amount);
        user.amount = 0;
        user.rewardDebt = 0;

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);
        }
    }

    // Safe cvx transfer function, just in case if rounding error causes pool to not have enough CVXs.
    function safeRewardTransfer(address _to, uint256 _amount) internal {
        uint256 cvxBal = cvx.balanceOf(address(this));
        if (_amount > cvxBal) {
            cvx.safeTransfer(_to, cvxBal);
        } else {
            cvx.safeTransfer(_to, _amount);
        }
    }

}",2667,308,"[M-13] ConvexMasterChef: When `_lpToken` is cvx, reward calculation is incorrect
In the ConvexMasterChef contract, a new staking pool can be added using the `add()` function. The staking token for the new pool is defined using the _lpToken variable. However, there is no additional checking whether the `_lpToken` is the same as the reward token (cvx) or not.
  [M-15] ConvexMasterChef: `safeRewardTransfer` can cause loss of funds
All calculations are rounded down, since a lack of tokens in the contracts cannot be rounding errors' fault. So the function is redundant. On the other hand, if the contract is undersupplied with cvx tokens, this will cause depositors to be sent less tokens than needed (or none). This is especially unsafe because the tokens that were lacking are not resembled in accountings at all. Thus a depositor may invoke the safeRewardTransfer and not receive tokens they were supposed to.
  [M-17] ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control
Reward token accounting update in `deposit()` and `withdraw()` happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future (i.e. have or can introduce the _beforetokentransfer, _afterTokenTransfer type of hooks; or, say, can be upgraded to ERC777), the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount.
  [M-20] massUpdatePools() is susceptible to DoS with block gas limit
`massUpdatePools()` is a public function and it calls the updatePool() function for the length of poolInfo. Hence, it is an unbounded loop, depending on the length of poolInfo. If poolInfo.length is big enough, block gas limit may be hit.   [M-21] ConvexMasterChef: When using `add()` and `set()`, it should always call `massUpdatePools()` to update all pools
  [M-22] Duplicate LP token could lead to incorrect reward distribution
It was observed that add function is not checking for duplicate lpToken which allows 2 or more pools to have exact same lpToken. This can cause issue with reward distribution

",6,,"pragma solidity 0.6.12;

import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Context.sol"";
import ""@openzeppelin/contracts-0.6/access/Ownable.sol"";
import ""./interfaces/IRewarder.sol"";


contract ConvexMasterChef is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    
    struct UserInfo {
        uint256 amount; 
        uint256 rewardDebt; 
        
        
        
        
        
        
        
        
        
        
        
    }

    
    struct PoolInfo {
        IERC20 lpToken; 
        uint256 allocPoint; 
        uint256 lastRewardBlock; 
        uint256 accCvxPerShare; 
        IRewarder rewarder;
    }

    
    IERC20 public immutable cvx;
    
    uint256 public immutable rewardPerBlock;
    
    uint256 public constant BONUS_MULTIPLIER = 2;

    
    PoolInfo[] public poolInfo;
    
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    
    uint256 public totalAllocPoint = 0;
    
    uint256 public immutable startBlock;
    uint256 public immutable endBlock;

    
    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);
    event EmergencyWithdraw(
        address indexed user,
        uint256 indexed pid,
        uint256 amount
    );

    constructor(
        IERC20 _cvx,
        uint256 _rewardPerBlock,
        uint256 _startBlock,
        uint256 _endBlock
    ) public {
        cvx = _cvx;
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
        endBlock = _endBlock;
    }

    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    
    
    function add(
        uint256 _allocPoint,
        IERC20 _lpToken,
        IRewarder _rewarder,
        bool _withUpdate
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        uint256 lastRewardBlock = block.number > startBlock
            ? block.number
            : startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocPoint);
        poolInfo.push(
            PoolInfo({
                lpToken: _lpToken,
                allocPoint: _allocPoint,
                lastRewardBlock: lastRewardBlock,
                accCvxPerShare: 0,
                rewarder: _rewarder
            })
        );
    }

    
    function set(
        uint256 _pid,
        uint256 _allocPoint,
        IRewarder _rewarder,
        bool _withUpdate,
        bool _updateRewarder
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(
            _allocPoint
        );
        poolInfo[_pid].allocPoint = _allocPoint;
        if(_updateRewarder){
            poolInfo[_pid].rewarder = _rewarder;
        }
    }

    
    function getMultiplier(uint256 _from, uint256 _to)
        public
        view
        returns (uint256)
    {
        uint256 clampedTo = _to > endBlock ? endBlock : _to;
        uint256 clampedFrom = _from > endBlock ? endBlock : _from;
        return clampedTo.sub(clampedFrom);
    }

    
    function pendingCvx(uint256 _pid, address _user)
        external
        view
        returns (uint256)
    {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint256 accCvxPerShare = pool.accCvxPerShare;
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint256 multiplier = getMultiplier(
                pool.lastRewardBlock,
                block.number
            );
            uint256 cvxReward = multiplier
                .mul(rewardPerBlock)
                .mul(pool.allocPoint)
                .div(totalAllocPoint);
            accCvxPerShare = accCvxPerShare.add(
                cvxReward.mul(1e12).div(lpSupply)
            );
        }
        return user.amount.mul(accCvxPerShare).div(1e12).sub(user.rewardDebt);
    }

    
    function massUpdatePools() public {
        uint256 length = poolInfo.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            updatePool(pid);
        }
    }

    
    function updatePool(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (lpSupply == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint256 cvxReward = multiplier
            .mul(rewardPerBlock)
            .mul(pool.allocPoint)
            .div(totalAllocPoint);
        
        pool.accCvxPerShare = pool.accCvxPerShare.add(
            cvxReward.mul(1e12).div(lpSupply)
        );
        pool.lastRewardBlock = block.number;
    }

    
    function deposit(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid);
        if (user.amount > 0) {
            uint256 pending = user
                .amount
                .mul(pool.accCvxPerShare)
                .div(1e12)
                .sub(user.rewardDebt);
            safeRewardTransfer(msg.sender, pending);
        }
        pool.lpToken.safeTransferFrom(
            address(msg.sender),
            address(this),
            _amount
        );
        user.amount = user.amount.add(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);
        }

        emit Deposit(msg.sender, _pid, _amount);
    }

    
    function withdraw(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""withdraw: not good"");
        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(msg.sender, pending);
        user.amount = user.amount.sub(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);
        pool.lpToken.safeTransfer(address(msg.sender), _amount);

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);
        }

        emit RewardPaid(msg.sender, _pid, pending);
        emit Withdraw(msg.sender, _pid, _amount);
    }

    function claim(uint256 _pid, address _account) external{
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_account];

        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(_account, pending);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, _account, _account, pending, user.amount);
        }

        emit RewardPaid(_account, _pid, pending);
    }

    
    function emergencyWithdraw(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        pool.lpToken.safeTransfer(address(msg.sender), user.amount);
        emit EmergencyWithdraw(msg.sender, _pid, user.amount);
        user.amount = 0;
        user.rewardDebt = 0;

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);
        }
    }

    
    function safeRewardTransfer(address _to, uint256 _amount) internal {
        uint256 cvxBal = cvx.balanceOf(address(this));
        if (_amount > cvxBal) {
            cvx.safeTransfer(_to, cvxBal);
        } else {
            cvx.safeTransfer(_to, _amount);
        }
    }

}",2047,0,6,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify that the SafeMath library is consistently used for all arithmetic operations to prevent potential overflows and underflows."",
        ""Analyze the `safeRewardTransfer` function for potential vulnerabilities. If `_amount` exceeds the contract's `cvx` balance, it sends the entire balance to `_to`. Investigate if this scenario allows users to claim more rewards than entitled if the contract balance is temporarily low, potentially unfairly distributing rewards and/or griefing other users expecting to claim later."",
        ""Examine the `claim` function. It permits anyone to call it on behalf of any `_account`. Evaluate whether this is the intended behavior and whether it introduces any unexpected consequences or vulnerabilities, such as denial of service (DoS) or griefing."",
        ""Assess the potential for reentrancy attacks, especially in the `deposit`, `withdraw`, and `claim` functions, considering the external calls to `safeRewardTransfer` and the `IRewarder.onReward` function.  If the `IRewarder` contract calls back into ConvexMasterChef, can the state be manipulated unexpectedly?"",
        ""Review the `emergencyWithdraw` function to confirm it correctly handles the edge case where a user has a large amount of staked tokens and the token transfer fails due to insufficient gas or other issues. Ensure this function correctly resets the user's `amount` and `rewardDebt` even if the transfer fails.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Confirm that the `onlyOwner` modifier is appropriately used on sensitive functions (`add`, `set`) to prevent unauthorized modification of pool parameters."",
        ""Verify the contract owner can add pools with zero allocation points and review the effects on reward distribution."",
        ""Check if there are any potential vulnerabilities related to the owner's ability to set arbitrary `allocPoint` values, which could unfairly favor certain pools or starve others of rewards.""
      ]
    },
    {
      ""Area"": ""Reward Distribution Logic"",
      ""Tasks"": [
        ""Analyze the `getMultiplier` function to ensure it correctly calculates the reward multiplier based on the `startBlock` and `endBlock`. Verify that the reward distribution stops precisely at the `endBlock` and doesn't continue beyond it."",
        ""Review the formula for calculating `accCvxPerShare` and pending rewards (`pendingCvx`, `deposit`, `withdraw`, `claim`) to confirm its accuracy and prevent any rounding errors or unintended biases."",
        ""Investigate the interaction between `updatePool` and `massUpdatePools`. If a large number of pools exists, `massUpdatePools` could exceed the gas limit.  How will this be handled?"",
        ""Analyze the `IRewarder.onReward` calls within the `deposit`, `withdraw`, `claim`, and `emergencyWithdraw` functions. Determine if the state passed to `IRewarder.onReward` (specifically `user.amount` and the `pending` reward), is consistent with what the `IRewarder` expects, given that user state is updated *before* the `IRewarder.onReward` call in `deposit` but has already been updated in `withdraw` and `claim`.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Thoroughly analyze the potential risks associated with the external `IRewarder` contract. Since the `ConvexMasterChef` contract interacts with it, any vulnerabilities in the `IRewarder` could be exploited. Determine if the `ConvexMasterChef` contract has any mechanism to handle a malicious or faulty `IRewarder` contract, such as the ability to remove or disable it."",
        ""Verify that the `lpToken.safeTransferFrom` and `lpToken.safeTransfer` calls correctly handle ERC20 tokens that might not conform fully to the ERC20 standard (e.g., tokens that don't return a boolean value on transfer). SafeERC20 library functions should mitigate this issue, but review nonetheless."",
        ""Examine the potential consequences if the `cvx` token contract is upgraded or modified in a way that breaks compatibility with the `ConvexMasterChef` contract. Consider the impact of changes to the `balanceOf` and `safeTransfer` functions.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Profile the gas consumption of the main functions (`deposit`, `withdraw`, `claim`, `updatePool`) and identify potential areas for optimization. For example, can storage reads/writes be minimized or reordered to reduce gas costs?"",
        ""Review the use of loops (`massUpdatePools`) for potential gas limit issues and consider alternative implementations, such as pagination or off-chain computation."",
        ""If `BONUS_MULTIPLIER` is not intended for use, remove it to reduce deployment cost.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `ConvexMasterChef` is a staking rewards contract, heavily inspired by the SushiSwap MasterChef design. It allows users to deposit LP tokens into various pools and earn rewards in the form of a specific token (CVX). Rewards are distributed based on allocation points per pool and the amount staked by the user, calculated per block within a defined reward period (`startBlock` to `endBlock`). It supports adding/modifying pools, depositing/withdrawing stake, claiming rewards, and an emergency withdrawal function. It also integrates an optional external `IRewarder` contract per pool for potentially distributing additional rewards."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""ConvexMasterChef"",
    ""Purpose"": ""To distribute CVX rewards to users staking specific LP tokens in designated pools over a defined block range."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Ownable""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-0.6/math/SafeMath.sol"",
        ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"",
        ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"",
        ""@openzeppelin/contracts-0.6/utils/Context.sol"",
        ""@openzeppelin/contracts-0.6/access/Ownable.sol"",
        ""./interfaces/IRewarder.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""cvx"",
        ""Type"": ""IERC20 immutable"",
        ""Purpose"": ""The ERC20 token distributed as rewards.""
      },
      {
        ""Name"": ""rewardPerBlock"",
        ""Type"": ""uint256 immutable"",
        ""Purpose"": ""The total amount of CVX rewards distributed across all pools per block.""
      },
      {
        ""Name"": ""BONUS_MULTIPLIER"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""A constant multiplier (value 2), currently unused in the provided code.""
      },
      {
        ""Name"": ""poolInfo"",
        ""Type"": ""PoolInfo[]"",
        ""Purpose"": ""An array storing information about each reward pool.""
      },
      {
        ""Name"": ""userInfo"",
        ""Type"": ""mapping(uint256 => mapping(address => UserInfo))"",
        ""Purpose"": ""Stores user-specific data (staked amount, reward debt) for each pool.""
      },
      {
        ""Name"": ""totalAllocPoint"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The sum of allocation points of all active pools, used to calculate reward distribution.""
      },
      {
        ""Name"": ""startBlock"",
        ""Type"": ""uint256 immutable"",
        ""Purpose"": ""The block number at which reward distribution begins.""
      },
      {
        ""Name"": ""endBlock"",
        ""Type"": ""uint256 immutable"",
        ""Purpose"": ""The block number at which reward distribution ends.""
      },
      {
        ""Name"": ""PoolInfo (struct)"",
        ""Type"": ""struct"",
        ""Purpose"": ""Contains details for a specific pool: LP token contract, allocation points, last reward block, accumulated CVX per share, and an optional external rewarder contract.""
      },
      {
        ""Name"": ""UserInfo (struct)"",
        ""Type"": ""struct"",
        ""Purpose"": ""Contains details for a user within a specific pool: amount of LP tokens staked and the reward debt (to calculate pending rewards).""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with immutable parameters: reward token, reward rate, start block, and end block."",
        ""Parameters"": [
          ""IERC20 _cvx"",
          ""uint256 _rewardPerBlock"",
          ""uint256 _startBlock"",
          ""uint256 _endBlock""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""poolLength"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the total number of reward pools."",
        ""Parameters"": [],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""add"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adds a new reward pool (onlyOwner). Updates total allocation points."",
        ""Parameters"": [
          ""uint256 _allocPoint"",
          ""IERC20 _lpToken"",
          ""IRewarder _rewarder"",
          ""bool _withUpdate""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""set"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the allocation points and optionally the rewarder of an existing pool (onlyOwner)."",
        ""Parameters"": [
          ""uint256 _pid"",
          ""uint256 _allocPoint"",
          ""IRewarder _rewarder"",
          ""bool _withUpdate"",
          ""bool _updateRewarder""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""getMultiplier"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates the number of blocks between two block numbers, respecting the `endBlock` limit."",
        ""Parameters"": [
          ""uint256 _from"",
          ""uint256 _to""
        ],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""pendingCvx"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Calculates the amount of pending CVX rewards for a user in a specific pool without updating state."",
        ""Parameters"": [
          ""uint256 _pid"",
          ""address _user""
        ],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""massUpdatePools"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the reward variables for all pools."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""updatePool"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the reward variables (like `accCvxPerShare`) for a specific pool."",
        ""Parameters"": [
          ""uint256 _pid""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""deposit"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a user to deposit LP tokens into a pool, claim pending rewards, and start earning new rewards."",
        ""Parameters"": [
          ""uint256 _pid"",
          ""uint256 _amount""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a user to withdraw LP tokens from a pool and claim pending rewards."",
        ""Parameters"": [
          ""uint256 _pid"",
          ""uint256 _amount""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""claim"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows anyone to trigger a reward claim for a specified account in a specific pool."",
        ""Parameters"": [
          ""uint256 _pid"",
          ""address _account""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a user to withdraw their staked LP tokens immediately without receiving any pending rewards."",
        ""Parameters"": [
          ""uint256 _pid""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""safeRewardTransfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Safely transfers CVX rewards to a user, sending the contract's entire balance if it's less than the calculated reward amount."",
        ""Parameters"": [
          ""address _to"",
          ""uint256 _amount""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""Ownable Modifiers"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Standard OpenZeppelin `onlyOwner` modifier restricting `add` and `set` functions to the contract owner."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Interacts with the `cvx` ERC20 token contract (implements `IERC20`) for checking balance (`balanceOf`) and transferring rewards (`safeTransfer`)."",
    ""Interacts with various LP token contracts (implement `IERC20`) for depositing (`safeTransferFrom`), withdrawing (`safeTransfer`), and checking the contract's balance (`balanceOf`)."",
    ""Optionally interacts with external `IRewarder` contracts via the `onReward` function during deposit, withdrawal, claim, and emergency withdrawal operations.""
  ],
  ""SpecialMechanisms"": [
    ""MasterChef Pattern: Implements the core logic of distributing rewards based on staked amount and time, using `accCvxPerShare` and `rewardDebt` for efficient calculation."",
    ""Allocation Points: Uses `allocPoint` per pool and `totalAllocPoint` to weigh reward distribution among different pools."",
    ""Time-Limited Rewards: Rewards are calculated based on blocks elapsed (`getMultiplier`) only between `startBlock` and `endBlock`."",
    ""External Rewarder Interface: Allows integration with other reward systems via the `IRewarder` interface."",
    ""SafeMath and SafeERC20: Utilizes OpenZeppelin libraries for preventing arithmetic overflows/underflows and ensuring safe token transfers."",
    ""Ownership Control: Uses `Ownable` pattern for administrative functions."",
    ""Immutability: Core parameters (`cvx`, `rewardPerBlock`, `startBlock`, `endBlock`) are set at deployment and cannot be changed, enhancing predictability.""
  ],
  ""Questions"": [
    ""The `BONUS_MULTIPLIER` constant is defined but appears unused throughout the contract. Is this intentional, legacy code, or planned for future use?"",
    ""The `safeRewardTransfer` function sends the entire contract CVX balance if the calculated reward amount exceeds it. Could this allow a user to claim more than their fair share if the contract is temporarily underfunded, potentially draining funds intended for later claimants?"",
    ""The `claim` function allows `msg.sender` to claim rewards for any `_account`. Is this intended, or should it be restricted to the `_account` itself?"",
    ""In `deposit`, `withdraw`, `claim`, and `emergencyWithdraw`, the call to `_rewarder.onReward` happens after user state updates (`user.amount`, `user.rewardDebt`). Does the `IRewarder` interface logic rely on the state *before* or *after* these updates? (Noting that `withdraw` and `claim` pass the `pending` reward calculated *before* the reward debt update, but `user.amount` reflects the state *after* the update).""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Re-entrancy vulnerability in Rewarder Interactions"",
      ""Severity"": ""High"",
      ""Description"": ""The `deposit`, `withdraw`, `claim`, and `emergencyWithdraw` functions interact with an external `IRewarder` contract. A malicious or compromised rewarder contract could re-enter the `ConvexMasterChef` contract within the `onReward` callback, potentially leading to unexpected state changes, double withdrawals, draining funds or manipulating contract state."",
      ""Impact"": ""Possible theft of funds, denial of service, or unexpected contract behavior, allowing an attacker to potentially drain the contract's reward tokens."",
      ""Location"": ""`deposit`, `withdraw`, `claim`, `emergencyWithdraw` functions, specifically where `_rewarder.onReward` is called.""
    },
    {
      ""Issue"": ""Rewarder Contract Can Be Malicious"",
      ""Severity"": ""High"",
      ""Description"": ""The contract interacts with an external `IRewarder` contract. If the `IRewarder` contract is malicious, it could perform arbitrary actions, including stealing funds, manipulating state, or causing the `ConvexMasterChef` contract to become unusable. The `onReward` function in the Rewarder contract is called after both deposit and withdraw. The `add` and `set` functions use `IRewarder`. The owner must be extremely careful when adding or setting a rewarder contract address. It also does not validate the rewarder contract’s functionality or security."",
      ""Impact"": ""Total compromise of the contract is possible. A malicious rewarder contract could compromise the security of the MasterChef contract and its users."",
      ""Location"": ""Calls to `_rewarder.onReward` in `deposit`, `withdraw`, `claim` and `emergencyWithdraw`; usage of `IRewarder` in `add` and `set`.""
    },
    {
      ""Issue"": ""Lack of access control for claim function"",
      ""Severity"": ""High"",
      ""Description"": ""The `claim` function allows any external caller to claim rewards for *any* account (`_account`). While the rewards are still calculated based on the user\'s staked amount, this could be abused in some way (e.g., griefing, DoS).  There is no access control to prevent any user from claiming rewards for another user. This is especially critical because the Rewarder is also triggered, which could allow a malicious claimer to DoS a rewarder contract or exfiltrate data from it."",
      ""Impact"": ""Rewards of other users can be claimed by anyone, which is a direct loss of funds. Potential for abuse and griefing, allows anyone to trigger rewarder contracts for any account."",
      ""Location"": ""claim function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `getMultiplier` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `getMultiplier` function calculates the reward multiplier based on the difference between two block numbers. While `SafeMath` is used elsewhere, it's not directly applied within `getMultiplier` which calculates `clampedTo.sub(clampedFrom)`. If `_to` and `_from` are manipulated maliciously, there's a possibility of underflow if the clamping to `endBlock` doesn't prevent it, even after clamping."",
      ""Impact"": ""Incorrect reward calculation, potentially leading to unintended distribution of CVX tokens. Incorrect multiplier calculation can lead to incorrect reward distribution, potentially benefiting or disadvantaging specific users or pools."",
      ""Location"": ""function `getMultiplier`""
    },
    {
      ""Issue"": ""Unbounded Mass Update Gas Costs"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `massUpdatePools` function iterates through all pools and calls `updatePool`. The gas cost of this function scales linearly with the number of pools. If the number of pools grows large enough, the gas cost of `massUpdatePools` could exceed the block gas limit, causing the function to revert and potentially halting reward distribution. The function `add` and `set` with `_withUpdate=true` will also be affected. While this is a general problem with iterating over unbounded loops, it\'s important to be aware of this limitation."",
      ""Impact"": ""Denial of service; reward distribution can be halted."",
      ""Location"": ""function `massUpdatePools`""
    },
    {
      ""Issue"": ""Centralized Control Over Reward Distribution"",
      ""Severity"": ""Medium"",
      ""Description"": ""The owner can change the `rewarder` contract for each pool using the `set` function and can set `allocPoint` to any value arbitrarily, This can disproportionately affect rewards given to different pools. A malicious or compromised owner could set the `rewarder` to a contract that steals funds or otherwise harms users or set `allocPoint` to 0 and halt distribution."",
      ""Impact"": ""Potential for theft of funds or other malicious actions by a compromised owner, loss of user funds due to arbitrary rewards redistribution, and unintentional or malicious disabling of reward distribution for a specific pool."",
      ""Location"": ""Function: `set`""
    },
    {
      ""Issue"": ""Potential Division by Zero in `pendingCvx` and `updatePool`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `pendingCvx` and `updatePool` calculate `accCvxPerShare` by dividing `cvxReward.mul(1e12)` by `lpSupply`. If `lpSupply` is zero, this will result in a division by zero, causing the transaction to revert. While the code checks `lpSupply != 0` in `updatePool`, a race condition might exist. If a large withdraw happens between checking and division the `lpSupply` can become zero."",
      ""Impact"": ""A division by zero error will halt reward distribution for the affected pool and potentially disrupt the functionality of the contract. Users will be unable to claim rewards. Transaction reverts and prevents reward distribution."",
      ""Location"": ""`pendingCvx` function, `updatePool` function""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `add` and `set` functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `add` and `set` functions update the `totalAllocPoint`, which directly affects the reward distribution. A malicious actor could monitor the transaction pool for calls to `add` or `set` and front-run these transactions with their own deposit to take advantage of the change in reward allocation.  For example, if a new pool is added with a significant `_allocPoint`, front-running it and depositing into that pool just after the `add` transaction is mined will allow the attacker to accumulate more rewards before others can react."",
      ""Impact"": ""An attacker can gain an unfair advantage in reward distribution by front-running `add` and `set` transactions."",
      ""Location"": ""Functions `add` and `set`""
    },
    {
      ""Issue"": ""Potential Re-entrancy vulnerability in `safeRewardTransfer` function."",
      ""Severity"": ""Medium"",
      ""Description"": ""The `safeRewardTransfer` function transfers CVX tokens to the recipient. If the recipient is a malicious contract, it could potentially trigger a re-entrancy attack by calling back into the ConvexMasterChef contract before the `safeRewardTransfer` function completes. This could lead to unexpected behavior, such as draining the contract\'s CVX balance or manipulating the state of the pools."",
      ""Impact"": ""Draining of CVX tokens from the contract, state manipulation."",
      ""Location"": ""safeRewardTransfer function""
    },
    {
      ""Issue"": ""Inconsistent reward calculation in claim function when compared to deposit and withdraw"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `claim` function updates the `user.rewardDebt` immediately after sending the pending rewards. In contrast, `deposit` and `withdraw` update the `user.rewardDebt` *before* checking the balance and calling `safeRewardTransfer`. While this might not be a critical bug, it introduces inconsistency in the accounting logic. If safeRewardTransfer reverts, the `claim` function would have already updated the rewardDebt, leading to a loss of rewards for the user."",
      ""Impact"": ""Potential loss of rewards for user if safeRewardTransfer fails in the claim function. Inconsistency in reward distribution mechanism compared to deposit and withdraw methods."",
      ""Location"": ""ConvexMasterChef.sol:188-193""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Reward Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""While SafeMath is used for most arithmetic operations, there’s a potential for integer overflow/underflow in the reward calculation within the `pendingCvx`, `updatePool`, `deposit`, `withdraw`, and `claim` functions, specifically in the `accCvxPerShare` calculation. Although `SafeMath` is employed for addition and subtraction, the intermediate multiplication steps (e.g., `cvxReward.mul(1e12)`) could result in values exceeding the maximum representable value for `uint256` before the division occurs. This could lead to incorrect `accCvxPerShare` values and, consequently, inaccurate reward distributions."",
      ""Impact"": ""Incorrect reward distribution, potentially leading to users receiving less or more CVX than they should. This could erode trust in the platform and create opportunities for exploitation."",
      ""Location"": ""Functions: `pendingCvx`, `updatePool`, `deposit`, `withdraw`, and `claim`. Specifically, lines calculating `accCvxPerShare`""
    },
    {
      ""Issue"": ""Missing Input Validation for `_pid` in multiple functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract doesn\'t check if the `_pid` (pool ID) provided in functions like `set`, `pendingCvx`, `deposit`, `withdraw`, `claim`, and `emergencyWithdraw` is within the valid range of existing pools (i.e., less than `poolInfo.length`).  If an invalid `_pid` is supplied, the code will attempt to access an out-of-bounds array element in `poolInfo`, leading to unexpected behavior, a revert, or potential denial of service."",
      ""Impact"": ""Denial of service, potential contract malfunction if an invalid `_pid` is supplied leading to out-of-bounds access in poolInfo array. "",
      ""Location"": ""Functions: set, pendingCvx, deposit, withdraw, claim, emergencyWithdraw.  Anywhere `poolInfo[_pid]` is accessed.""
    },
    {
      ""Issue"": ""Potential Front-Running in `deposit` and `withdraw`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `deposit` and `withdraw` functions first update the pool (`updatePool`) and then transfer rewards (`safeRewardTransfer`).  A malicious actor could potentially front-run the reward transfer after the pool has been updated but before the intended user receives their rewards. The impact is likely minimal because it would only affect a very short time window and require high gas prices."",
      ""Impact"": ""Possible, although unlikely, to slightly benefit a malicious actor at the expense of another user."",
      ""Location"": ""function `deposit`, function `withdraw`""
    },
    {
      ""Issue"": ""Possible rounding error in reward calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The reward calculation involves multiple divisions and multiplications, which could lead to rounding errors. While `SafeMath` prevents overflows/underflows, it does not address the potential for loss of precision due to integer division. The use of `1e12` likely mitigates this, but the accumulated error could still be significant over time, especially with small deposit amounts."",
      ""Impact"": ""Slightly inaccurate reward distribution."",
      ""Location"": ""Calculations involving `accCvxPerShare` in `pendingCvx`, `deposit`, and `withdraw`""
    },
    {
      ""Issue"": ""Unnecessary `_account` Parameter in `claim` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `claim` function takes an external `_account` parameter, but then fetches user information using `userInfo[_pid][_account]`. Furthermore, the `safeRewardTransfer` function sends the rewards to `_account`, and the `RewardPaid` event emits `_account`. This is functional, but it's unusual for a claim function, which typically operates on `msg.sender`. Allowing an arbitrary `_account` to be specified allows any user to claim rewards for any other user, but the only requirement is that the user already has a balance in the pool. This may not be the intended behaviour.  The function could simply use `msg.sender` and avoid the parameter altogether unless delegation is supported."",
      ""Impact"": ""It is unclear if this behavior is intentional. If delegation is not supported the parameter should be removed."",
      ""Location"": ""Function `claim`""
    },
    {
      ""Issue"": ""Missing Event for Setting Alloc Point"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract emits events for deposits, withdrawals, reward payments, and emergency withdrawals. However, there is no event emitted when the `allocPoint` is changed in the `set` function. This makes it difficult to track changes to the reward distribution scheme off-chain."",
      ""Impact"": ""Lack of transparency in reward distribution changes."",
      ""Location"": ""Function `set`""
    },
    {
      ""Issue"": ""Lack of Input Validation for `_allocPoint` in `add` and `set` functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The `add` and `set` functions allow the owner to set the `_allocPoint` for pools. There is no explicit validation to prevent setting `_allocPoint` to zero. Setting `_allocPoint` to zero for a pool would effectively disable reward distribution for that pool but could be done accidentally or maliciously."",
      ""Impact"": ""Unintentional or malicious disabling of reward distribution for a specific pool."",
      ""Location"": ""Functions: `add`, `set`""
    },
    {
      ""Issue"": ""Incorrect event emission on `withdraw`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `withdraw` function emits a `RewardPaid` event with the pending reward *before* the user withdraws. This is misleading as the reward event occurs before the actual withdraw. The `IRewarder.onReward` is also called after the pending reward amount has been calculated, and before the actual transfer of the pending amount occurs. This is inconsistent with `deposit` which calls `IRewarder.onReward` after the transfer."",
      ""Impact"": ""Incorrect event log, inconsistent rewarder invocation."",
      ""Location"": ""function `withdraw`""
    },
    {
      ""Issue"": ""Lack of zero-address check for Rewarder address."",
      ""Severity"": ""Low"",
      ""Description"": ""The `add` and `set` functions for managing pools accept an `IRewarder` address. There isn't an explicit check to prevent setting the `_rewarder` address to the zero address (0x0). Although there's a check later (`if (address(_rewarder) != address(0))`), setting it to zero initially and then interacting with it would likely cause a revert, potentially disrupting contract functionality.  While a revert prevents further execution, it's better to prevent the zero address from being set in the first place for clarity and to avoid unexpected behavior."",
      ""Impact"": ""Potential contract malfunction due to reverts when calling `onReward` on a zero address."",
      ""Location"": ""add and set functions""
    },
    {
      ""Issue"": ""Front-Running vulnerability when adding pools with `_withUpdate = true`"",
      ""Severity"": ""Low"",
      ""Description"": ""When adding new pools with `_withUpdate` set to `true`, `massUpdatePools()` is called, updating the reward accrual for all existing pools. A malicious actor could front-run the `add` transaction by depositing into existing pools just before the `add` transaction is executed. This would effectively dilute the rewards that other users would receive in those pools after the new pool is added, allowing the attacker to claim a larger share of the rewards."",
      ""Impact"": ""Reward dilution for existing users due to front-running."",
      ""Location"": ""add function when _withUpdate is true""
    },
    {
      ""Issue"": ""Reward calculation dependent on block.number"",
      ""Severity"": ""Info"",
      ""Description"": ""The reward calculation is based on `block.number`. This is generally discouraged as block numbers are predictable by miners and can be manipulated within certain bounds. Furthermore, it makes the contract state dependent on block production, potentially affecting its behavior across different chains or if block production is halted."",
      ""Impact"": ""Potential for miner manipulation to influence rewards, reduced predictability and portability of the contract."",
      ""Location"": ""getMultiplier, pendingCvx, and updatePool functions""
    }
  ],
  ""IssueNumber"": 40,
  ""OutputList"": 21
}",221.0008292198181,3527.0,32.0,"### **Comparison of Issue Report and Response List**

---

#### **[M-13] ConvexMasterChef: When `_lpToken` is cvx, reward calculation is incorrect**

**Report Description**:  
In the ConvexMasterChef contract, the `add()` function allows adding a new staking pool with `_lpToken` as the staking token. However, there is no check to ensure that `_lpToken` is not the same as the reward token (cvx). This oversight could lead to incorrect reward calculations if `_lpToken` is set to cvx.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect reward calculation when `_lpToken` is set to cvx. This is a specific vulnerability that is not covered in the response list.

---

#### **[M-15] ConvexMasterChef: `safeRewardTransfer` can cause loss of funds**

**Report Description**:  
The `safeRewardTransfer` function rounds down calculations, which could lead to users receiving fewer tokens than expected if the contract is undersupplied with cvx tokens. This is unsafe because the lack of tokens is not accounted for, potentially causing users to lose funds.

**Match in Response List**:  
Matches with the issue titled **""Potential Re-entrancy vulnerability in `safeRewardTransfer` function.""**

**Validation**:  
**Partially Correct**. The response identifies a re-entrancy vulnerability in `safeRewardTransfer`, but it does not address the core issue of rounding down and potential loss of funds due to undersupply. The response focuses on re-entrancy, which is not the primary concern in the issue report.

---

#### **[M-17] ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control**

**Report Description**:  
The `deposit()` and `withdraw()` functions update reward token accounting after the reward transfer. If the reward token allows for transfer flow control (e.g., ERC777 hooks), an attacker could reenter these functions and drain all reward funds from the contract.

**Match in Response List**:  
Matches with the issue titled **""Potential Re-entrancy vulnerability in Rewarder Interactions.""**

**Validation**:  
**Correct**. The response accurately identifies the re-entrancy vulnerability in `deposit` and `withdraw` functions, particularly when interacting with reward tokens that allow transfer flow control. The impact of draining reward funds is also correctly described.

---

#### **[M-20] `massUpdatePools()` is susceptible to DoS with block gas limit**

**Report Description**:  
The `massUpdatePools()` function iterates over all pools and calls `updatePool()`. If the number of pools is large, the function could exceed the block gas limit, causing a denial of service (DoS).

**Match in Response List**:  
Matches with the issue titled **""Unbounded Mass Update Gas Costs.""**

**Validation**:  
**Correct**. The response correctly identifies the issue of unbounded gas costs in `massUpdatePools()` and the potential for DoS if the number of pools grows too large. The impact and location are accurately described.

---

#### **[M-21] ConvexMasterChef: When using `add()` and `set()`, it should always call `massUpdatePools()` to update all pools**

**Report Description**:  
The `add()` and `set()` functions should always call `massUpdatePools()` to ensure all pools are updated and reward calculations are accurate. Failure to do so could lead to incorrect reward distributions.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the need for `massUpdatePools()` to be called in `add()` and `set()` functions. This is a specific recommendation that is not covered.

---

#### **[M-22] Duplicate LP token could lead to incorrect reward distribution**

**Report Description**:  
The `add()` function does not check for duplicate `lpToken`, allowing multiple pools to have the same `lpToken`. This could lead to incorrect reward distribution.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of duplicate `lpToken` and its impact on reward distribution. This is a specific vulnerability that is not covered.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-17] ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control**
- **[M-20] `massUpdatePools()` is susceptible to DoS with block gas limit**

**Partially Correct Matches**:

- **[M-15] ConvexMasterChef: `safeRewardTransfer` can cause loss of funds**

**Missed Issues from Issue Report**:

- **[M-13] ConvexMasterChef: When `_lpToken` is cvx, reward calculation is incorrect**
- **[M-21] ConvexMasterChef: When using `add()` and `set()`, it should always call `massUpdatePools()` to update all pools**
- **[M-22] Duplicate LP token could lead to incorrect reward distribution**

---

The response list covers some critical issues like re-entrancy and gas limit vulnerabilities but misses specific issues related to reward calculation, duplicate `lpToken`, and the need for `massUpdatePools()` in `add()` and `set()` functions.","```
1. Potential Re-entrancy vulnerability in Rewarder Interactions
2. Unbounded Mass Update Gas Costs
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives**:
   - ""Potential Re-entrancy vulnerability in Rewarder Interactions"" appears at rank 1.
   - ""Unbounded Mass Update Gas Costs"" appears at rank 5.

2. **Calculate the precision at each rank**:
   - For rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - For rank 5: \( P@5 = \frac{2}{5} = 0.4 \)

3. **Compute the Average Precision (AP)**:
   - AP = \( \frac{1.0 + 0.4}{2} = 0.7 \)

**Output**:
```
0.7
```"
