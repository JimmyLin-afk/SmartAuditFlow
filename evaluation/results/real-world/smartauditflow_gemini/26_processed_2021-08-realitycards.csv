nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
RCOrderbook.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";

/// @title Reality Cards Orderbook
/// @author Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCOrderbook is NativeMetaTransaction, IRCOrderbook {
    /*╔═════════════════════════════════╗
      ║            VARIABLES            ║
      ╚═════════════════════════════════╝*/

    /// @dev a record of a users single bid.
    /// @dev now declared in the interface, left here for reference
    // struct Bid {
    //     address market;
    //     address next;
    //     address prev;
    //     uint64 card;
    //     uint128 price;
    //     uint64 timeHeldLimit;
    // }

    /// @dev maps a user address to an array of their bids
    mapping(address => Bid[]) public user;
    /// @dev index of a bid record in the user array, User|Market|Token->Index
    mapping(address => mapping(address => mapping(uint256 => uint256)))
        public
        override index;

    /// @dev record of market specific variables
    struct Market {
        uint64 mode;
        uint64 cardCount;
        uint64 minimumPriceIncreasePercent;
        uint64 minimumRentalDuration;
    }
    /// @dev map a market address to a market record
    mapping(address => Market) public market;
    /// @dev find the current owner of a card in a given market. Market -> Card -> Owner
    mapping(address => mapping(uint256 => address)) public override ownerOf;
    /// @dev store the oldOwner and oldPrice in the event we can't find a new owner
    mapping(address => mapping(uint256 => address)) public oldOwner;
    mapping(address => mapping(uint256 => uint256)) public oldPrice;
    /// @dev an array of closed markets, used to reduce user bid rates
    address[] public override closedMarkets;
    /// @dev how far through the array a given user is, saves iterating the whole array every time.
    mapping(address => uint256) public override userClosedMarketIndex;

    ///// GOVERNANCE VARIABLES /////
    /// @dev the current treasury
    IRCTreasury public override treasury;
    /// @dev max number of searches to place an order in the book
    /// @dev current estimates place limit around 2000 but 1000 is sufficient
    uint256 public override maxSearchIterations = 1000;
    /// @dev max number of records to delete in one transaction
    uint256 public override maxDeletions = 70;
    /// @dev number of bids a user should clean when placing a new bid
    uint256 public override cleaningLoops = 2;
    /// @dev max number of market records to put into the waste pile in one go
    uint256 public override marketCloseLimit = 70;
    /// @dev nonce emitted with orderbook insertions, for frontend sorting
    uint256 public override nonce;

    /*╔═════════════════════════════════╗
      ║          Access Control         ║
      ╚═════════════════════════════════╝*/
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");

    /*╔═════════════════════════════════╗
      ║          MODIFIERS              ║
      ╚═════════════════════════════════╝*/

    /// @notice only allow markets to call certain functions
    modifier onlyMarkets() {
        require(
            treasury.checkPermission(MARKET, msgSender()),
            ""Not authorised""
        );
        _;
    }

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    modifier onlyFactory() {
        require(
            treasury.checkPermission(FACTORY, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    /*╔═════════════════════════════════╗
      ║            EVENTS               ║
      ╚═════════════════════════════════╝*/

    /// @dev emitted every time an order is added to the orderbook
    event LogAddToOrderbook(
        address indexed newOwner,
        uint256 indexed newPrice,
        uint256 timeHeldLimit,
        uint256 nonce,
        uint256 indexed tokenId,
        address market
    );
    /// @dev emitted when an order is removed from the orderbook
    event LogRemoveFromOrderbook(
        address indexed owner,
        address indexed market,
        uint256 indexed tokenId
    );

    /*╔═════════════════════════════════╗
      ║         CONSTRUCTOR             ║
      ╚═════════════════════════════════╝*/

    constructor(IRCTreasury _treasury) {
        treasury = _treasury;
    }

    /*╔═════════════════════════════════╗
      ║         GOVERNANCE              ║
      ╚═════════════════════════════════╝*/

    function setTreasuryAddress(address _newTreasury)
        external
        override
        onlyUberOwner
    {
        require(_newTreasury != address(0));
        treasury = IRCTreasury(_newTreasury);
    }

    function setDeletionLimit(uint256 _deletionLimit)
        external
        override
        onlyUberOwner
    {
        maxDeletions = _deletionLimit;
    }

    function setCleaningLimit(uint256 _cleaningLimit)
        external
        override
        onlyUberOwner
    {
        cleaningLoops = _cleaningLimit;
    }

    function setSearchLimit(uint256 _searchLimit)
        external
        override
        onlyUberOwner
    {
        maxSearchIterations = _searchLimit;
    }

    function setMarketCloseLimit(uint256 _marketCloseLimit)
        external
        override
        onlyUberOwner
    {
        marketCloseLimit = _marketCloseLimit;
    }

    /*╔═════════════════════════════════════╗
      ║             INSERTIONS              ║
      ║ functions that add to the orderbook ║
      ╚═════════════════════════════════════╝*/

    /// @notice adds a new market to the orderbook
    function addMarket(
        address _market,
        uint256 _cardCount,
        uint256 _minIncrease
    ) internal {
        market[_market].cardCount = SafeCast.toUint64(_cardCount);
        market[_market].minimumPriceIncreasePercent = SafeCast.toUint64(
            _minIncrease
        );
        market[_market].minimumRentalDuration = SafeCast.toUint64(
            1 days / IRCMarket(_market).minRentalDayDivisor()
        );
        for (uint64 i = 0; i < _cardCount; i++) {
            // create new record for each card that becomes the head&tail of the linked list
            Bid memory _newBid;
            _newBid.market = _market;
            _newBid.card = i;
            _newBid.prev = _market;
            _newBid.next = _market;
            _newBid.price = 0;
            _newBid.timeHeldLimit = type(uint64).max;
            index[_market][_market][i] = user[_market].length;
            user[_market].push(_newBid);
        }
    }

    /// @notice adds or updates a bid in the orderbook
    /// @param _user the user placing the bid
    /// @param _card the card to place the bid on
    /// @param _price the price of the new bid
    /// @param _timeHeldLimit an optional time limit for the bid
    /// @param _prevUserAddress to help find where to insert the bid
    function addBidToOrderbook(
        address _user,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        address _prevUserAddress
    ) external override onlyMarkets {
        address _market = msgSender();
        if (!bidExists(_market, _market, _card)) {
            uint256 _cardCount = IRCMarket(_market).numberOfCards();
            uint256 _minIncrease = IRCMarket(_market)
                .minimumPriceIncreasePercent();
            addMarket(_market, _cardCount, _minIncrease);
        }
        // each new bid can help clean up some junk
        cleanWastePile();

        if (user[_user].length == 0) {
            //users first bid, skip already closed markets
            userClosedMarketIndex[_user] = closedMarkets.length;
        }

        if (_prevUserAddress == address(0)) {
            _prevUserAddress = _market;
        } else {
            require(
                user[_prevUserAddress][index[_prevUserAddress][_market][_card]]
                    .price >= _price,
                ""Location too low""
            );
        }
        require(
            bidExists(_prevUserAddress, _market, _card),
            ""Invalid starting location""
        );
        Bid storage _prevUser = user[_prevUserAddress][
            index[_prevUserAddress][_market][_card]
        ];

        if (bidExists(_user, _market, _card)) {
            // old bid exists, update it
            _updateBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        } else {
            // new bid, add it
            _newBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        }
    }

    /// @dev finds the correct location in the orderbook for a given bid
    /// @dev returns an adjusted (lowered) bid price if necessary.
    function _searchOrderbook(
        Bid storage _prevUser,
        address _market,
        uint256 _card,
        uint256 _price
    ) internal view returns (Bid storage, uint256) {
        uint256 _minIncrease = market[_market].minimumPriceIncreasePercent;
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];
        uint256 _requiredPrice = (_nextUser.price * (_minIncrease + (100))) /
            (100);

        uint256 i = 0;
        while (
            // break loop if match price above AND above price below (so if either is false, continue, hence OR )
            // if match previous then must be greater than next to continue
            (_price != _prevUser.price || _price <= _nextUser.price) &&
            // break loop if price x% above below
            _price < _requiredPrice &&
            // break loop if hits max iterations
            i < maxSearchIterations
        ) {
            _prevUser = _nextUser;
            _nextUser = user[_prevUser.next][
                index[_prevUser.next][_market][_card]
            ];
            _requiredPrice = (_nextUser.price * (_minIncrease + (100))) / (100);
            i++;
        }
        require(i < maxSearchIterations, ""Position not found"");

        // if previous price is zero it must be the market and this is a new owner
        // .. then don't reduce their price, we already checked they are 10% higher
        // .. than the previous owner.
        if (_prevUser.price != 0 && _prevUser.price < _price) {
            _price = _prevUser.price;
        }
        return (_prevUser, _price);
    }

    /// @dev add a new bid to the orderbook
    function _newBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        if (ownerOf[_market][_card] != _market) {
            (_prevUser, _price) = _searchOrderbook(
                _prevUser,
                _market,
                _card,
                _price
            );
        }

        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        // create new record
        Bid memory _newBid;
        _newBid.market = _market;
        _newBid.card = SafeCast.toUint64(_card);
        _newBid.prev = _nextUser.prev;
        _newBid.next = _prevUser.next;
        _newBid.price = SafeCast.toUint128(_price);
        _newBid.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        // insert in linked list
        _nextUser.prev = _user; // next record update prev link
        _prevUser.next = _user; // prev record update next link
        user[_user].push(_newBid);

        // update the index to help find the record later
        index[_user][_market][_card] = user[_user].length - (1);

        emit LogAddToOrderbook(
            _user,
            _price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        // update treasury values and transfer ownership if required
        treasury.increaseBidRate(_user, _price);
        if (user[_user][index[_user][_market][_card]].prev == _market) {
            address _oldOwner = user[_user][index[_user][_market][_card]].next;
            transferCard(_market, _card, _oldOwner, _user, _price);
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                user[_oldOwner][index[_oldOwner][_market][_card]].price,
                _price,
                block.timestamp
            );
        }
    }

    /// @dev updates a bid that is already in the orderbook
    function _updateBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        // TODO no need to unlink and relink if bid doesn't change position in orderbook
        // unlink current bid
        Bid storage _currUser = user[_user][index[_user][_market][_card]];
        user[_currUser.next][index[_currUser.next][_market][_card]]
            .prev = _currUser.prev;
        user[_currUser.prev][index[_currUser.prev][_market][_card]]
            .next = _currUser.next;
        bool _wasOwner = _currUser.prev == _market;

        // find new position
        (_prevUser, _price) = _searchOrderbook(
            _prevUser,
            _market,
            _card,
            _price
        );
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        // update price, save old price for rental rate adjustment later
        (_currUser.price, _price) = (
            SafeCast.toUint128(_price),
            uint256(_currUser.price)
        );
        _currUser.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        // relink bid
        _currUser.next = _prevUser.next;
        _currUser.prev = _nextUser.prev;
        _nextUser.prev = _user; // next record update prev link
        _prevUser.next = _user; // prev record update next link

        emit LogAddToOrderbook(
            _user,
            _currUser.price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        // update treasury values and transfer ownership if required
        treasury.increaseBidRate(_user, _currUser.price);
        treasury.decreaseBidRate(_user, _price);
        if (_wasOwner && _currUser.prev == _market) {
            // if owner before and after, update the price difference
            transferCard(_market, _card, _user, _user, _currUser.price);
            treasury.updateRentalRate(
                _user,
                _user,
                _price,
                _currUser.price,
                block.timestamp
            );
        } else if (_wasOwner && _currUser.prev != _market) {
            // if owner before and not after, remove the old price
            address _newOwner = user[_market][index[_market][_market][_card]]
                .next;
            uint256 _newPrice = user[_newOwner][
                index[_newOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _user,
                _newOwner,
                _price,
                _newPrice,
                block.timestamp
            );
            transferCard(_market, _card, _user, _newOwner, _newPrice);
        } else if (!_wasOwner && _currUser.prev == _market) {
            // if not owner before but is owner after, add new price
            address _oldOwner = _currUser.next;
            uint256 _oldPrice = user[_oldOwner][
                index[_oldOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                _oldPrice,
                _currUser.price,
                block.timestamp
            );
            transferCard(_market, _card, _oldOwner, _user, _currUser.price);
        }
    }

    /*╔══════════════════════════════════════════╗
      ║                DELETIONS                 ║      
      ║ functions that remove from the orderbook ║
      ╚══════════════════════════════════════════╝*/

    /// @notice removes a single bid from the orderbook - onlyMarkets
    function removeBidFromOrderbook(address _user, uint256 _card)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        assert(_user != ownerOf[_market][_card]);
        _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
    }

    /// @dev removes a single bid from the orderbook, doesn't update ownership
    function _removeBidFromOrderbookIgnoreOwner(
        address _user,
        address _market,
        uint256 _card
    ) internal returns (uint256 _newPrice) {
        Bid storage _currUser = user[_user][index[_user][_market][_card]];

        // extract from linked list
        address _tempNext = _currUser.next;
        address _tempPrev = _currUser.prev;
        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;
        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;

        // return next users price to check they're eligible later
        _newPrice = user[_tempNext][index[_tempNext][_market][_card]].price;

        // update rate
        treasury.decreaseBidRate(_user, _currUser.price);

        // overwrite array element
        uint256 _index = index[_user][_market][_card];
        uint256 _lastRecord = user[_user].length - 1;
        // no point overwriting itself
        if (_index != _lastRecord) {
            user[_user][_index] = user[_user][_lastRecord];
        }
        user[_user].pop();

        // update the index to help find the record later
        index[_user][_market][_card] = 0;
        if (user[_user].length != 0 && _index != _lastRecord) {
            index[_user][user[_user][_index].market][
                user[_user][_index].card
            ] = _index;
        }

        assert(!bidExists(_user, _market, _card));
        emit LogRemoveFromOrderbook(_user, _market, _card);
    }

    /// @notice find the next valid owner of a given card - onlyMarkets
    /// @param _card the card to remove
    /// @param _timeOwnershipChanged the timestamp, used to backdate ownership changes
    function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)
        external
        override
        onlyMarkets
    {
        address _newOwner = address(0);
        address _market = msgSender();
        // the market is the head of the list, the next bid is therefore the owner
        Bid storage _head = user[_market][index[_market][_market][_card]];
        address _oldOwner = address(0);
        uint256 _oldPrice = 0;
        if (oldOwner[_market][_card] != address(0)) {
            _oldOwner = oldOwner[_market][_card];
            _oldPrice = oldPrice[_market][_card];
            oldOwner[_market][_card] = address(0);
            oldPrice[_market][_card] = 0;
        } else {
            _oldOwner = ownerOf[_market][_card];
            _oldPrice = user[_oldOwner][index[_oldOwner][_market][_card]].price;
        }
        uint256 minimumTimeToOwnTo = _timeOwnershipChanged +
            market[_market].minimumRentalDuration;
        uint256 _newPrice;
        uint256 _loopCounter = 0;

        // delete current owner
        do {
            _newPrice = _removeBidFromOrderbookIgnoreOwner(
                _head.next,
                _market,
                _card
            );
            _loopCounter++;
            // delete next bid if foreclosed
        } while (
            treasury.foreclosureTimeUser(
                _head.next,
                _newPrice,
                _timeOwnershipChanged
            ) <
                minimumTimeToOwnTo &&
                _loopCounter < maxDeletions
        );

        if (_loopCounter != maxDeletions) {
            // the old owner is dead, long live the new owner
            _newOwner = user[_market][index[_market][_market][_card]].next;
            treasury.updateRentalRate(
                _oldOwner,
                _newOwner,
                _oldPrice,
                _newPrice,
                _timeOwnershipChanged
            );
            transferCard(_market, _card, _oldOwner, _newOwner, _newPrice);
        } else {
            // we hit the limit, save the old owner, we'll try again next time
            oldOwner[_market][_card] = _oldOwner;
            oldPrice[_market][_card] = _oldPrice;
        }
    }

    /// @notice when a user has foreclosed we can freely delete their bids, however leave owned cards
    /// @notice .. as the markets will need to finish the accounting for them first.
    /// @param _user the user whose bids to start deleting
    function removeUserFromOrderbook(address _user) external override {
        require(treasury.isForeclosed(_user), ""User must be foreclosed"");
        uint256 i = user[_user].length;
        if (i != 0) {
            uint256 _limit = 0;
            if (i > maxDeletions) {
                _limit = i - maxDeletions;
            }

            do {
                i--;

                // If the prev record isn't the market, this is only a bid (not owned) so we can delete
                if (user[_user][i].prev != user[_user][i].market) {
                    address _market = user[_user][i].market;
                    uint256 _card = user[_user][i].card;
                    _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
                }
            } while (user[_user].length > _limit && i > 0);
        }
        treasury.assessForeclosure(_user);
    }

    /// @notice reduces the rentalRates of the card owners when a market closes
    /// @dev too many bidders to reduce all bid rates also
    function closeMarket() external override onlyMarkets returns (bool) {
        address _market = msgSender();
        // check if the market was ever added to the orderbook
        if (bidExists(_market, _market, 0)) {
            closedMarkets.push(_market);
            uint256 i = user[_market].length; // start on the last record so we can easily pop()
            uint256 _limit = 0;
            if (marketCloseLimit < user[_market].length) {
                _limit = user[_market].length - marketCloseLimit;
            } else {
                _limit = 0;
            }
            do {
                i--;
                address _lastOwner = user[_market][index[_market][_market][i]]
                    .next;
                if (_lastOwner != _market) {
                    uint256 _price = user[_lastOwner][
                        index[_lastOwner][_market][i]
                    ].price;

                    // store last bid for later
                    address _lastBid = user[_market][index[_market][_market][i]]
                        .prev;

                    // detach market from rest of list
                    user[_market][index[_market][_market][i]].prev = _market;
                    user[_market][index[_market][_market][i]].next = _market;
                    user[_lastOwner][index[_lastOwner][_market][i]]
                        .prev = address(this);
                    user[_lastBid][index[_lastBid][_market][i]].next = address(
                        this
                    );

                    index[address(this)][_market][i] = user[address(this)]
                        .length;

                    // insert bids in the waste pile
                    Bid memory _newBid;
                    _newBid.market = _market;
                    _newBid.card = SafeCast.toUint64(i);
                    _newBid.prev = _lastBid;
                    _newBid.next = _lastOwner;
                    _newBid.price = 0;
                    _newBid.timeHeldLimit = 0;
                    user[address(this)].push(_newBid);

                    // reduce owners rental rate
                    treasury.updateRentalRate(
                        _lastOwner,
                        _market,
                        _price,
                        0,
                        block.timestamp
                    );
                }
                // remove the market record
                user[_market].pop();
            } while (i > _limit);
        }
        if (user[_market].length == 0) {
            return true;
        } else {
            return false;
        }
    }

    /// @notice Remove bids in closed markets for a given user
    /// @notice this can reduce the users bidRate and chance to foreclose
    /// @param _user the address of the users bids to remove
    function removeOldBids(address _user) external override {
        if (user[_user].length != 0) {
            address _market = address(0);
            uint256 _cardCount = 0;
            uint256 _loopCounter = 0;
            uint256 _subLoopCounter = 0;
            while (
                userClosedMarketIndex[_user] < closedMarkets.length &&
                _loopCounter + _cardCount < maxDeletions
            ) {
                _market = closedMarkets[userClosedMarketIndex[_user]];
                // Just do the whole market at once
                _cardCount = market[_market].cardCount;
                uint256 i = _cardCount;
                do {
                    i--;
                    if (bidExists(_user, _market, i)) {
                        uint256 _index = index[_user][_market][i];
                        // reduce bidRate
                        uint256 _price = user[_user][_index].price;

                        // preserve linked list
                        address _tempPrev = user[_user][_index].prev;
                        address _tempNext = user[_user][_index].next;

                        user[_tempNext][index[_tempNext][_market][i]]
                            .prev = _tempPrev;
                        user[_tempPrev][index[_tempPrev][_market][i]]
                            .next = _tempNext;

                        uint256 _lastRecord = user[_user].length - 1;
                        // no point overwriting itself
                        if (_index != _lastRecord) {
                            // overwrite array element
                            user[_user][_index] = user[_user][_lastRecord];
                        }
                        user[_user].pop();

                        // update the index to help find the record later
                        index[_user][_market][i] = 0;
                        if (user[_user].length != 0 && _index != _lastRecord) {
                            index[_user][user[_user][_index].market][
                                user[_user][_index].card
                            ] = _index;
                        }

                        treasury.decreaseBidRate(_user, _price);
                        // count deletions
                        _loopCounter++;
                    } else {
                        // iterations cost gas also
                        // after enough increment the loopCounter
                        _subLoopCounter++;
                        if (_subLoopCounter > 100) {
                            _subLoopCounter = 0;
                            _loopCounter++;
                        }
                    }
                } while (i > 0);
                userClosedMarketIndex[_user]++;
            }
        }
    }

    /// @dev remove bids in closed markets, not user specific
    function cleanWastePile() public override {
        uint256 i = 0;
        while (i < cleaningLoops && user[address(this)].length > 0) {
            uint256 _pileHeight = user[address(this)].length - 1;
            address _market = user[address(this)][_pileHeight].market;
            uint256 _card = user[address(this)][_pileHeight].card;
            address _user = user[address(this)][_pileHeight].next;

            if (user[address(this)][_pileHeight].next == address(this)) {
                index[address(this)][_market][_card] = 0;
                user[address(this)].pop();
            } else {
                uint256 _index = index[_user][_market][_card];
                address _tempNext = user[_user][_index].next;

                treasury.decreaseBidRate(_user, user[_user][_index].price);

                // extract from linked list
                user[address(this)][_pileHeight].next = _tempNext;
                user[_tempNext][index[_tempNext][_market][_card]]
                    .prev = address(this);

                // overwrite array element
                uint256 _lastRecord = user[_user].length - 1;
                // no point overwriting itself
                if (_index != _lastRecord) {
                    user[_user][_index] = user[_user][_lastRecord];
                }
                user[_user].pop();

                // update the index to help find the record later
                index[_user][_market][_card] = 0;
                if (user[_user].length != 0 && _index != _lastRecord) {
                    index[_user][user[_user][_index].market][
                        user[_user][_index].card
                    ] = _index;
                }
            }
            i++;
        }
    }

    /*╔═════════════════════════════════╗
      ║        HELPER FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @notice check if a bid exists
    /// @param _user the address of the user
    /// @param _market the address of the market
    /// @param _card the card index
    /// @return if the bid exists or not
    function bidExists(
        address _user,
        address _market,
        uint256 _card
    ) public view override returns (bool) {
        if (user[_user].length != 0) {
            //some bids exist
            if (index[_user][_market][_card] != 0) {
                // this bid exists
                return true;
            } else {
                // check bid isn't index 0
                if (
                    user[_user][0].market == _market &&
                    user[_user][0].card == _card
                ) {
                    return true;
                }
            }
        }
        return false;
    }

    function getBidValue(address _user, uint256 _card)
        external
        view
        override
        returns (uint256)
    {
        address _market = msgSender();
        if (bidExists(_user, _market, _card)) {
            return user[_user][index[_user][_market][_card]].price;
        } else {
            return 0;
        }
    }

    /// @dev just to pass old tests, not needed otherwise
    /// @dev but also useful to have so probably will stay
    function getBid(
        address _market,
        address _user,
        uint256 _card
    ) external view override returns (Bid memory) {
        if (bidExists(_user, _market, _card)) {
            Bid memory _bid = user[_user][index[_user][_market][_card]];
            return _bid;
        } else {
            Bid memory _newBid;
            _newBid.market = address(0);
            _newBid.card = SafeCast.toUint64(_card);
            _newBid.prev = address(0);
            _newBid.next = address(0);
            _newBid.price = 0;
            _newBid.timeHeldLimit = 0;
            return _newBid;
        }
    }

    function getTimeHeldlimit(address _user, uint256 _card)
        external
        view
        override
        onlyMarkets
        returns (uint256)
    {
        return user[_user][index[_user][msgSender()][_card]].timeHeldLimit;
    }

    function setTimeHeldlimit(
        address _user,
        uint256 _card,
        uint256 _timeHeldLimit
    ) external override onlyMarkets {
        address _market = msgSender();
        require(bidExists(_user, _market, _card), ""Bid doesn't exist"");
        user[_user][index[_user][_market][_card]].timeHeldLimit = SafeCast
            .toUint64(_timeHeldLimit);
    }

    function reduceTimeHeldLimit(
        address _user,
        uint256 _card,
        uint256 _timeToReduce
    ) external override onlyMarkets {
        user[_user][index[_user][msgSender()][_card]].timeHeldLimit -= SafeCast
            .toUint64(_timeToReduce);
    }

    function transferCard(
        address _market,
        uint256 _card,
        address _oldOwner,
        address _newOwner,
        uint256 _price
    ) internal {
        ownerOf[_market][_card] = _newOwner;
        uint256 _timeLimit = user[_newOwner][index[_newOwner][_market][_card]]
            .timeHeldLimit;
        IRCMarket _rcmarket = IRCMarket(_market);
        _rcmarket.transferCard(_oldOwner, _newOwner, _card, _price, _timeLimit);
    }
    /*
         ▲  
        ▲ ▲ 
              */
}

",7831,933,"[H-01] findNewOwner edgecase

In the function `findNewOwner` of `RCOrderbook`, as loop is done which included the check _loopCounter < maxDeletions Afterwards, a check is done for ""(_loopCounter != maxDeletions)"" to determine if the processing is finished. If _loopCounter == maxDeletions then the conclusion is that it isn't finished yet.
However, there is the edgecase that the processing might just be finished at the same time as _loopCounter == maxDeletions.
 You can see this the best if you assume maxDeletions==1, in that case it will never draw the conclusion it is finished. Of course having maxDeletions==1 is very unlikely in practice.",1,,"pragma solidity 0.8.7;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";




contract RCOrderbook is NativeMetaTransaction, IRCOrderbook {
    

    
    
    
    
    
    
    
    
    
    

    
    mapping(address => Bid[]) public user;
    
    mapping(address => mapping(address => mapping(uint256 => uint256)))
        public
        override index;

    
    struct Market {
        uint64 mode;
        uint64 cardCount;
        uint64 minimumPriceIncreasePercent;
        uint64 minimumRentalDuration;
    }
    
    mapping(address => Market) public market;
    
    mapping(address => mapping(uint256 => address)) public override ownerOf;
    
    mapping(address => mapping(uint256 => address)) public oldOwner;
    mapping(address => mapping(uint256 => uint256)) public oldPrice;
    
    address[] public override closedMarkets;
    
    mapping(address => uint256) public override userClosedMarketIndex;

    
    
    IRCTreasury public override treasury;
    
    
    uint256 public override maxSearchIterations = 1000;
    
    uint256 public override maxDeletions = 70;
    
    uint256 public override cleaningLoops = 2;
    
    uint256 public override marketCloseLimit = 70;
    
    uint256 public override nonce;

    
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");

    

    
    modifier onlyMarkets() {
        require(
            treasury.checkPermission(MARKET, msgSender()),
            ""Not authorised""
        );
        _;
    }

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    modifier onlyFactory() {
        require(
            treasury.checkPermission(FACTORY, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    

    
    event LogAddToOrderbook(
        address indexed newOwner,
        uint256 indexed newPrice,
        uint256 timeHeldLimit,
        uint256 nonce,
        uint256 indexed tokenId,
        address market
    );
    
    event LogRemoveFromOrderbook(
        address indexed owner,
        address indexed market,
        uint256 indexed tokenId
    );

    

    constructor(IRCTreasury _treasury) {
        treasury = _treasury;
    }

    

    function setTreasuryAddress(address _newTreasury)
        external
        override
        onlyUberOwner
    {
        require(_newTreasury != address(0));
        treasury = IRCTreasury(_newTreasury);
    }

    function setDeletionLimit(uint256 _deletionLimit)
        external
        override
        onlyUberOwner
    {
        maxDeletions = _deletionLimit;
    }

    function setCleaningLimit(uint256 _cleaningLimit)
        external
        override
        onlyUberOwner
    {
        cleaningLoops = _cleaningLimit;
    }

    function setSearchLimit(uint256 _searchLimit)
        external
        override
        onlyUberOwner
    {
        maxSearchIterations = _searchLimit;
    }

    function setMarketCloseLimit(uint256 _marketCloseLimit)
        external
        override
        onlyUberOwner
    {
        marketCloseLimit = _marketCloseLimit;
    }

    

    
    function addMarket(
        address _market,
        uint256 _cardCount,
        uint256 _minIncrease
    ) internal {
        market[_market].cardCount = SafeCast.toUint64(_cardCount);
        market[_market].minimumPriceIncreasePercent = SafeCast.toUint64(
            _minIncrease
        );
        market[_market].minimumRentalDuration = SafeCast.toUint64(
            1 days / IRCMarket(_market).minRentalDayDivisor()
        );
        for (uint64 i = 0; i < _cardCount; i++) {
            
            Bid memory _newBid;
            _newBid.market = _market;
            _newBid.card = i;
            _newBid.prev = _market;
            _newBid.next = _market;
            _newBid.price = 0;
            _newBid.timeHeldLimit = type(uint64).max;
            index[_market][_market][i] = user[_market].length;
            user[_market].push(_newBid);
        }
    }

    
    
    
    
    
    
    function addBidToOrderbook(
        address _user,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        address _prevUserAddress
    ) external override onlyMarkets {
        address _market = msgSender();
        if (!bidExists(_market, _market, _card)) {
            uint256 _cardCount = IRCMarket(_market).numberOfCards();
            uint256 _minIncrease = IRCMarket(_market)
                .minimumPriceIncreasePercent();
            addMarket(_market, _cardCount, _minIncrease);
        }
        
        cleanWastePile();

        if (user[_user].length == 0) {
            
            userClosedMarketIndex[_user] = closedMarkets.length;
        }

        if (_prevUserAddress == address(0)) {
            _prevUserAddress = _market;
        } else {
            require(
                user[_prevUserAddress][index[_prevUserAddress][_market][_card]]
                    .price >= _price,
                ""Location too low""
            );
        }
        require(
            bidExists(_prevUserAddress, _market, _card),
            ""Invalid starting location""
        );
        Bid storage _prevUser = user[_prevUserAddress][
            index[_prevUserAddress][_market][_card]
        ];

        if (bidExists(_user, _market, _card)) {
            
            _updateBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        } else {
            
            _newBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        }
    }

    
    
    function _searchOrderbook(
        Bid storage _prevUser,
        address _market,
        uint256 _card,
        uint256 _price
    ) internal view returns (Bid storage, uint256) {
        uint256 _minIncrease = market[_market].minimumPriceIncreasePercent;
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];
        uint256 _requiredPrice = (_nextUser.price * (_minIncrease + (100))) /
            (100);

        uint256 i = 0;
        while (
            
            
            (_price != _prevUser.price || _price <= _nextUser.price) &&
            
            _price < _requiredPrice &&
            
            i < maxSearchIterations
        ) {
            _prevUser = _nextUser;
            _nextUser = user[_prevUser.next][
                index[_prevUser.next][_market][_card]
            ];
            _requiredPrice = (_nextUser.price * (_minIncrease + (100))) / (100);
            i++;
        }
        require(i < maxSearchIterations, ""Position not found"");

        
        
        
        if (_prevUser.price != 0 && _prevUser.price < _price) {
            _price = _prevUser.price;
        }
        return (_prevUser, _price);
    }

    
    function _newBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        if (ownerOf[_market][_card] != _market) {
            (_prevUser, _price) = _searchOrderbook(
                _prevUser,
                _market,
                _card,
                _price
            );
        }

        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        
        Bid memory _newBid;
        _newBid.market = _market;
        _newBid.card = SafeCast.toUint64(_card);
        _newBid.prev = _nextUser.prev;
        _newBid.next = _prevUser.next;
        _newBid.price = SafeCast.toUint128(_price);
        _newBid.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        
        _nextUser.prev = _user; 
        _prevUser.next = _user; 
        user[_user].push(_newBid);

        
        index[_user][_market][_card] = user[_user].length - (1);

        emit LogAddToOrderbook(
            _user,
            _price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        
        treasury.increaseBidRate(_user, _price);
        if (user[_user][index[_user][_market][_card]].prev == _market) {
            address _oldOwner = user[_user][index[_user][_market][_card]].next;
            transferCard(_market, _card, _oldOwner, _user, _price);
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                user[_oldOwner][index[_oldOwner][_market][_card]].price,
                _price,
                block.timestamp
            );
        }
    }

    
    function _updateBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        
        
        Bid storage _currUser = user[_user][index[_user][_market][_card]];
        user[_currUser.next][index[_currUser.next][_market][_card]]
            .prev = _currUser.prev;
        user[_currUser.prev][index[_currUser.prev][_market][_card]]
            .next = _currUser.next;
        bool _wasOwner = _currUser.prev == _market;

        
        (_prevUser, _price) = _searchOrderbook(
            _prevUser,
            _market,
            _card,
            _price
        );
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        
        (_currUser.price, _price) = (
            SafeCast.toUint128(_price),
            uint256(_currUser.price)
        );
        _currUser.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        
        _currUser.next = _prevUser.next;
        _currUser.prev = _nextUser.prev;
        _nextUser.prev = _user; 
        _prevUser.next = _user; 

        emit LogAddToOrderbook(
            _user,
            _currUser.price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        
        treasury.increaseBidRate(_user, _currUser.price);
        treasury.decreaseBidRate(_user, _price);
        if (_wasOwner && _currUser.prev == _market) {
            
            transferCard(_market, _card, _user, _user, _currUser.price);
            treasury.updateRentalRate(
                _user,
                _user,
                _price,
                _currUser.price,
                block.timestamp
            );
        } else if (_wasOwner && _currUser.prev != _market) {
            
            address _newOwner = user[_market][index[_market][_market][_card]]
                .next;
            uint256 _newPrice = user[_newOwner][
                index[_newOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _user,
                _newOwner,
                _price,
                _newPrice,
                block.timestamp
            );
            transferCard(_market, _card, _user, _newOwner, _newPrice);
        } else if (!_wasOwner && _currUser.prev == _market) {
            
            address _oldOwner = _currUser.next;
            uint256 _oldPrice = user[_oldOwner][
                index[_oldOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                _oldPrice,
                _currUser.price,
                block.timestamp
            );
            transferCard(_market, _card, _oldOwner, _user, _currUser.price);
        }
    }

    

    
    function removeBidFromOrderbook(address _user, uint256 _card)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        assert(_user != ownerOf[_market][_card]);
        _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
    }

    
    function _removeBidFromOrderbookIgnoreOwner(
        address _user,
        address _market,
        uint256 _card
    ) internal returns (uint256 _newPrice) {
        Bid storage _currUser = user[_user][index[_user][_market][_card]];

        
        address _tempNext = _currUser.next;
        address _tempPrev = _currUser.prev;
        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;
        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;

        
        _newPrice = user[_tempNext][index[_tempNext][_market][_card]].price;

        
        treasury.decreaseBidRate(_user, _currUser.price);

        
        uint256 _index = index[_user][_market][_card];
        uint256 _lastRecord = user[_user].length - 1;
        
        if (_index != _lastRecord) {
            user[_user][_index] = user[_user][_lastRecord];
        }
        user[_user].pop();

        
        index[_user][_market][_card] = 0;
        if (user[_user].length != 0 && _index != _lastRecord) {
            index[_user][user[_user][_index].market][
                user[_user][_index].card
            ] = _index;
        }

        assert(!bidExists(_user, _market, _card));
        emit LogRemoveFromOrderbook(_user, _market, _card);
    }

    
    
    
    function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)
        external
        override
        onlyMarkets
    {
        address _newOwner = address(0);
        address _market = msgSender();
        
        Bid storage _head = user[_market][index[_market][_market][_card]];
        address _oldOwner = address(0);
        uint256 _oldPrice = 0;
        if (oldOwner[_market][_card] != address(0)) {
            _oldOwner = oldOwner[_market][_card];
            _oldPrice = oldPrice[_market][_card];
            oldOwner[_market][_card] = address(0);
            oldPrice[_market][_card] = 0;
        } else {
            _oldOwner = ownerOf[_market][_card];
            _oldPrice = user[_oldOwner][index[_oldOwner][_market][_card]].price;
        }
        uint256 minimumTimeToOwnTo = _timeOwnershipChanged +
            market[_market].minimumRentalDuration;
        uint256 _newPrice;
        uint256 _loopCounter = 0;

        
        do {
            _newPrice = _removeBidFromOrderbookIgnoreOwner(
                _head.next,
                _market,
                _card
            );
            _loopCounter++;
            
        } while (
            treasury.foreclosureTimeUser(
                _head.next,
                _newPrice,
                _timeOwnershipChanged
            ) <
                minimumTimeToOwnTo &&
                _loopCounter < maxDeletions
        );

        if (_loopCounter != maxDeletions) {
            
            _newOwner = user[_market][index[_market][_market][_card]].next;
            treasury.updateRentalRate(
                _oldOwner,
                _newOwner,
                _oldPrice,
                _newPrice,
                _timeOwnershipChanged
            );
            transferCard(_market, _card, _oldOwner, _newOwner, _newPrice);
        } else {
            
            oldOwner[_market][_card] = _oldOwner;
            oldPrice[_market][_card] = _oldPrice;
        }
    }

    
    
    
    function removeUserFromOrderbook(address _user) external override {
        require(treasury.isForeclosed(_user), ""User must be foreclosed"");
        uint256 i = user[_user].length;
        if (i != 0) {
            uint256 _limit = 0;
            if (i > maxDeletions) {
                _limit = i - maxDeletions;
            }

            do {
                i--;

                
                if (user[_user][i].prev != user[_user][i].market) {
                    address _market = user[_user][i].market;
                    uint256 _card = user[_user][i].card;
                    _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
                }
            } while (user[_user].length > _limit && i > 0);
        }
        treasury.assessForeclosure(_user);
    }

    
    
    function closeMarket() external override onlyMarkets returns (bool) {
        address _market = msgSender();
        
        if (bidExists(_market, _market, 0)) {
            closedMarkets.push(_market);
            uint256 i = user[_market].length; 
            uint256 _limit = 0;
            if (marketCloseLimit < user[_market].length) {
                _limit = user[_market].length - marketCloseLimit;
            } else {
                _limit = 0;
            }
            do {
                i--;
                address _lastOwner = user[_market][index[_market][_market][i]]
                    .next;
                if (_lastOwner != _market) {
                    uint256 _price = user[_lastOwner][
                        index[_lastOwner][_market][i]
                    ].price;

                    
                    address _lastBid = user[_market][index[_market][_market][i]]
                        .prev;

                    
                    user[_market][index[_market][_market][i]].prev = _market;
                    user[_market][index[_market][_market][i]].next = _market;
                    user[_lastOwner][index[_lastOwner][_market][i]]
                        .prev = address(this);
                    user[_lastBid][index[_lastBid][_market][i]].next = address(
                        this
                    );

                    index[address(this)][_market][i] = user[address(this)]
                        .length;

                    
                    Bid memory _newBid;
                    _newBid.market = _market;
                    _newBid.card = SafeCast.toUint64(i);
                    _newBid.prev = _lastBid;
                    _newBid.next = _lastOwner;
                    _newBid.price = 0;
                    _newBid.timeHeldLimit = 0;
                    user[address(this)].push(_newBid);

                    
                    treasury.updateRentalRate(
                        _lastOwner,
                        _market,
                        _price,
                        0,
                        block.timestamp
                    );
                }
                
                user[_market].pop();
            } while (i > _limit);
        }
        if (user[_market].length == 0) {
            return true;
        } else {
            return false;
        }
    }

    
    
    
    function removeOldBids(address _user) external override {
        if (user[_user].length != 0) {
            address _market = address(0);
            uint256 _cardCount = 0;
            uint256 _loopCounter = 0;
            uint256 _subLoopCounter = 0;
            while (
                userClosedMarketIndex[_user] < closedMarkets.length &&
                _loopCounter + _cardCount < maxDeletions
            ) {
                _market = closedMarkets[userClosedMarketIndex[_user]];
                
                _cardCount = market[_market].cardCount;
                uint256 i = _cardCount;
                do {
                    i--;
                    if (bidExists(_user, _market, i)) {
                        uint256 _index = index[_user][_market][i];
                        
                        uint256 _price = user[_user][_index].price;

                        
                        address _tempPrev = user[_user][_index].prev;
                        address _tempNext = user[_user][_index].next;

                        user[_tempNext][index[_tempNext][_market][i]]
                            .prev = _tempPrev;
                        user[_tempPrev][index[_tempPrev][_market][i]]
                            .next = _tempNext;

                        uint256 _lastRecord = user[_user].length - 1;
                        
                        if (_index != _lastRecord) {
                            
                            user[_user][_index] = user[_user][_lastRecord];
                        }
                        user[_user].pop();

                        
                        index[_user][_market][i] = 0;
                        if (user[_user].length != 0 && _index != _lastRecord) {
                            index[_user][user[_user][_index].market][
                                user[_user][_index].card
                            ] = _index;
                        }

                        treasury.decreaseBidRate(_user, _price);
                        
                        _loopCounter++;
                    } else {
                        
                        
                        _subLoopCounter++;
                        if (_subLoopCounter > 100) {
                            _subLoopCounter = 0;
                            _loopCounter++;
                        }
                    }
                } while (i > 0);
                userClosedMarketIndex[_user]++;
            }
        }
    }

    
    function cleanWastePile() public override {
        uint256 i = 0;
        while (i < cleaningLoops && user[address(this)].length > 0) {
            uint256 _pileHeight = user[address(this)].length - 1;
            address _market = user[address(this)][_pileHeight].market;
            uint256 _card = user[address(this)][_pileHeight].card;
            address _user = user[address(this)][_pileHeight].next;

            if (user[address(this)][_pileHeight].next == address(this)) {
                index[address(this)][_market][_card] = 0;
                user[address(this)].pop();
            } else {
                uint256 _index = index[_user][_market][_card];
                address _tempNext = user[_user][_index].next;

                treasury.decreaseBidRate(_user, user[_user][_index].price);

                
                user[address(this)][_pileHeight].next = _tempNext;
                user[_tempNext][index[_tempNext][_market][_card]]
                    .prev = address(this);

                
                uint256 _lastRecord = user[_user].length - 1;
                
                if (_index != _lastRecord) {
                    user[_user][_index] = user[_user][_lastRecord];
                }
                user[_user].pop();

                
                index[_user][_market][_card] = 0;
                if (user[_user].length != 0 && _index != _lastRecord) {
                    index[_user][user[_user][_index].market][
                        user[_user][_index].card
                    ] = _index;
                }
            }
            i++;
        }
    }

    

    
    
    
    
    
    function bidExists(
        address _user,
        address _market,
        uint256 _card
    ) public view override returns (bool) {
        if (user[_user].length != 0) {
            
            if (index[_user][_market][_card] != 0) {
                
                return true;
            } else {
                
                if (
                    user[_user][0].market == _market &&
                    user[_user][0].card == _card
                ) {
                    return true;
                }
            }
        }
        return false;
    }

    function getBidValue(address _user, uint256 _card)
        external
        view
        override
        returns (uint256)
    {
        address _market = msgSender();
        if (bidExists(_user, _market, _card)) {
            return user[_user][index[_user][_market][_card]].price;
        } else {
            return 0;
        }
    }

    
    
    function getBid(
        address _market,
        address _user,
        uint256 _card
    ) external view override returns (Bid memory) {
        if (bidExists(_user, _market, _card)) {
            Bid memory _bid = user[_user][index[_user][_market][_card]];
            return _bid;
        } else {
            Bid memory _newBid;
            _newBid.market = address(0);
            _newBid.card = SafeCast.toUint64(_card);
            _newBid.prev = address(0);
            _newBid.next = address(0);
            _newBid.price = 0;
            _newBid.timeHeldLimit = 0;
            return _newBid;
        }
    }

    function getTimeHeldlimit(address _user, uint256 _card)
        external
        view
        override
        onlyMarkets
        returns (uint256)
    {
        return user[_user][index[_user][msgSender()][_card]].timeHeldLimit;
    }

    function setTimeHeldlimit(
        address _user,
        uint256 _card,
        uint256 _timeHeldLimit
    ) external override onlyMarkets {
        address _market = msgSender();
        require(bidExists(_user, _market, _card), ""Bid doesn't exist"");
        user[_user][index[_user][_market][_card]].timeHeldLimit = SafeCast
            .toUint64(_timeHeldLimit);
    }

    function reduceTimeHeldLimit(
        address _user,
        uint256 _card,
        uint256 _timeToReduce
    ) external override onlyMarkets {
        user[_user][index[_user][msgSender()][_card]].timeHeldLimit -= SafeCast
            .toUint64(_timeToReduce);
    }

    function transferCard(
        address _market,
        uint256 _card,
        address _oldOwner,
        address _newOwner,
        uint256 _price
    ) internal {
        ownerOf[_market][_card] = _newOwner;
        uint256 _timeLimit = user[_newOwner][index[_newOwner][_market][_card]]
            .timeHeldLimit;
        IRCMarket _rcmarket = IRCMarket(_market);
        _rcmarket.transferCard(_oldOwner, _newOwner, _card, _price, _timeLimit);
    }
    
}",5819,1,0,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control Vulnerabilities"",
      ""Tasks"": [
        ""Verify that only authorized Market contracts (as determined by the Treasury) can call functions with the `onlyMarkets` modifier. Check the Treasury's permissioning logic."",
        ""Confirm that the `UBER_OWNER`, `OWNER`, `GOVERNOR`, `FACTORY`, `MARKET`, `TREASURY`, `ORDERBOOK`, and `WHITELIST` role constants are correctly defined and used within the Treasury contract."",
        ""Analyze the `setTreasuryAddress` function to ensure that only the intended UBER_OWNER can change the Treasury contract address and that the new address is validated (not address(0))."",
        ""Investigate the impact of a compromised Market contract. Can it manipulate bid prices, time limits, or ownership transfers despite the safeguards in place?"",
        ""Verify that the Treasury contract properly restricts access to the `MARKET` role, preventing unauthorized contracts from acting as Markets.""
      ]
    },
    {
      ""Area"": ""Reentrancy Risks"",
      ""Tasks"": [
        ""Examine the `_newBidInOrderbook` function for potential reentrancy vulnerabilities due to calls to the external `treasury.increaseBidRate` and `transferCard` functions before all internal state updates are finalized."",
        ""Analyze the `_updateBidInOrderbook` function for potential reentrancy vulnerabilities related to the same external calls (`treasury.increaseBidRate`, `treasury.decreaseBidRate`, `transferCard`)."",
        ""Assess the `findNewOwner` function for reentrancy risks stemming from the repeated calls to `_removeBidFromOrderbookIgnoreOwner` and `treasury.updateRentalRate` within the loop."",
        ""Check if the Treasury contract's functions called by the Orderbook are vulnerable to reentrancy attacks that could allow malicious actors to manipulate bid rates or rental rates."",
        ""Consider using reentrancy guards (e.g., OpenZeppelin's `ReentrancyGuard`) to mitigate potential reentrancy vulnerabilities in the identified functions.""
      ]
    },
    {
      ""Area"": ""Logic Errors and Data Consistency"",
      ""Tasks"": [
        ""Thoroughly review the doubly linked list implementation for adding, updating, and removing bids to ensure data consistency and prevent broken links, especially in edge cases (e.g., adding the first bid, removing the last bid)."",
        ""Analyze the price adjustment logic in `_searchOrderbook` (`if (_prevUser.price != 0 && _prevUser.price < _price) { _price = _prevUser.price; }`) to ensure its intended behavior and prevent unexpected price manipulations or incorrect bid placements."",
        ""Verify that the `index` mapping is correctly updated whenever a bid is added, removed, or moved within the `user` array to maintain accurate bid location tracking."",
        ""Check for potential integer overflow/underflow issues, especially when calculating prices, time limits, and other numerical values. Although SafeCast is used, ensure it's applied consistently."",
        ""Investigate potential issues related to concurrent modifications of the linked list by different Market contracts for the same card. Consider synchronization mechanisms if necessary."",
        ""Analyze the logic within `findNewOwner` to ensure the oldOwner and oldPrice variables are correctly handled to correctly revert state in the edge case of no valid new owner, without introducing a vulnerability."",
        ""Ensure all bid prices stored are non-zero, and the logic correctly handles zero prices throughout the contract.""
      ]
    },
    {
      ""Area"": ""Gas Optimization and DoS Prevention"",
      ""Tasks"": [
        ""Evaluate the gas cost of the `_searchOrderbook` function and consider alternative search algorithms or data structures to improve efficiency, especially for markets with a large number of bids."",
        ""Analyze the potential for denial-of-service (DoS) attacks due to excessive gas consumption in the `findNewOwner`, `removeUserFromOrderbook`, and `closeMarket` functions. Ensure that the gas limits (`maxSearchIterations`, `maxDeletions`, `marketCloseLimit`) are properly configured to prevent these attacks."",
        ""Review the `cleanWastePile` function to ensure it can efficiently process and remove bids from the temporary holding area without consuming excessive gas. Monitor the growth of `user[address(this)]` array."",
        ""Assess the gas overhead of using SafeCast and consider whether it can be replaced with more gas-efficient alternatives without sacrificing security."",
        ""Look for opportunities to reduce storage costs by using packed structs or other data compression techniques."",
        ""Examine the function `addMarket` to see if using a constant value (1 days / IRCMarket(_market).minRentalDayDivisor()) is efficient or if it can be hardcoded/passed as a variable.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify that the Orderbook contract correctly interacts with the Treasury contract for permission checks, bid rate updates, and foreclosure logic. Ensure that the Treasury contract's API is stable and well-documented."",
        ""Check that the Orderbook contract correctly interacts with the Market contracts for asset transfers and market parameter retrieval. Ensure that the Market contracts' API is compatible with the Orderbook's assumptions."",
        ""Investigate the potential impact of changes to the Treasury or Market contracts on the Orderbook's functionality and security. Consider using interface-based interactions and versioning to mitigate these risks."",
        ""Examine the `transferCard` function and determine what happens if the Market contract's `transferCard` function fails. The Orderbook does not handle this failure case and assumes the transfer is successful.""
      ]
    },
    {
      ""Area"": ""Market Closure and Cleanup"",
      ""Tasks"": [
        ""Analyze the `closeMarket` function to ensure it correctly moves bids to the temporary holding area and updates the linked list pointers. Verify that the market is properly marked as closed."",
        ""Review the `removeOldBids` function to ensure that users can efficiently clean up their bids from closed markets without consuming excessive gas. Check for potential DoS attacks related to this function."",
        ""Assess the interaction between `closeMarket`, `removeOldBids`, and `cleanWastePile` to ensure that the entire market closure and cleanup process is robust and efficient."",
        ""Consider edge cases such as closing a market with a large number of bids or cleaning up bids from a market that has been closed for a long time.""
      ]
    },
    {
      ""Area"": ""Event Emission"",
      ""Tasks"": [
        ""Verify that all relevant state changes are correctly logged using events (`LogAddToOrderbook`, `LogRemoveFromOrderbook`) to facilitate off-chain monitoring and analysis."",
        ""Ensure that the event parameters are properly indexed to allow efficient filtering and querying of events."",
        ""Assess whether additional events are needed to provide more comprehensive logging of contract activity.""
      ]
    },
    {
      ""Area"": ""NativeMetaTransaction Integration"",
      ""Tasks"": [
        ""Verify that the `NativeMetaTransaction` functionality (via `msgSender()`) is properly integrated and secure. Ensure that the trusted forwarder is properly configured and protects against replay attacks."",
        ""Analyze the impact of meta-transactions on the contract's gas consumption and potential vulnerabilities. Consider the security implications of relying on a trusted forwarder.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The RCOrderbook contract manages bids for assets (cards) within different market contracts. It implements a sorted doubly linked list for bids per card, allowing efficient insertion and updates based on price. It interacts heavily with an external Treasury contract for permissions, financial rate updates, and foreclosure logic, and with Market contracts for asset transfers and market parameters. It includes mechanisms for handling market closures, cleaning up old bids, and managing user foreclosures. The contract utilizes meta-transactions via NativeMetaTransaction and employs role-based access control delegated to the Treasury."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""RCOrderbook"",
    ""Purpose"": ""To manage and maintain an ordered list of bids for cards within various associated market contracts, facilitate ownership changes based on the highest valid bid, and handle related lifecycle events like market closure and user foreclosure."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""NativeMetaTransaction"",
        ""IRCOrderbook""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts/utils/math/SafeCast.sol"",
        ""hardhat/console.sol"",
        ""./lib/NativeMetaTransaction.sol"",
        ""./interfaces/IRCTreasury.sol"",
        ""./interfaces/IRCMarket.sol"",
        ""./interfaces/IRCOrderbook.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""user"",
        ""Type"": ""mapping(address => Bid[])"",
        ""Purpose"": ""Stores an array of bids for each user address.""
      },
      {
        ""Name"": ""index"",
        ""Type"": ""mapping(address => mapping(address => mapping(uint256 => uint256)))"",
        ""Purpose"": ""Provides a lookup index [user][market][cardId] to find the position of a specific bid within the user's Bid array.""
      },
      {
        ""Name"": ""Market"",
        ""Type"": ""struct"",
        ""Purpose"": ""Defines parameters for a market (mode, card count, min price increase, min rental duration).""
      },
      {
        ""Name"": ""market"",
        ""Type"": ""mapping(address => Market)"",
        ""Purpose"": ""Stores market-specific parameters.""
      },
      {
        ""Name"": ""ownerOf"",
        ""Type"": ""mapping(address => mapping(uint256 => address))"",
        ""Purpose"": ""Tracks the current owner (highest bidder) of a specific card within a market.""
      },
      {
        ""Name"": ""oldOwner"",
        ""Type"": ""mapping(address => mapping(uint256 => address))"",
        ""Purpose"": ""Temporarily stores the previous owner during owner transition edge cases (e.g., if findNewOwner fails temporarily).""
      },
      {
        ""Name"": ""oldPrice"",
        ""Type"": ""mapping(address => mapping(uint256 => uint256))"",
        ""Purpose"": ""Temporarily stores the previous owner's price during owner transition edge cases.""
      },
      {
        ""Name"": ""closedMarkets"",
        ""Type"": ""address[]"",
        ""Purpose"": ""An array storing the addresses of markets that have been closed.""
      },
      {
        ""Name"": ""userClosedMarketIndex"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks how far a user has progressed in cleaning up their bids from the closedMarkets array.""
      },
      {
        ""Name"": ""treasury"",
        ""Type"": ""IRCTreasury"",
        ""Purpose"": ""Reference to the external Treasury contract managing permissions and financial logic.""
      },
      {
        ""Name"": ""maxSearchIterations"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Limit for loops searching for bid positions to prevent excessive gas usage.""
      },
      {
        ""Name"": ""maxDeletions"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Limit for batch deletions in functions like findNewOwner and removeUserFromOrderbook.""
      },
      {
        ""Name"": ""cleaningLoops"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Limit for iterations within the cleanWastePile function.""
      },
      {
        ""Name"": ""marketCloseLimit"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Limit for the number of cards processed per call during market closure.""
      },
      {
        ""Name"": ""nonce"",
        ""Type"": ""uint256"",
        ""Purpose"": ""A counter incremented on bid additions, potentially for off-chain tracking or replay protection within certain contexts.""
      },
      {
        ""Name"": ""UBER_OWNER, OWNER, etc."",
        ""Type"": ""bytes32 constant"",
        ""Purpose"": ""Constants representing roles used for access control checks via the Treasury contract.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with the Treasury address."",
        ""Parameters"": [""IRCTreasury _treasury""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyMarkets"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts access to functions that should only be called by authorized Market contracts."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyUberOwner"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts access to functions requiring the UBER_OWNER role."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyFactory"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts access to functions requiring the FACTORY role (likely for initializing markets)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setTreasuryAddress"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the UBER_OWNER to update the Treasury contract address."",
        ""Parameters"": [""address _newTreasury""],
        ""Returns"": []
      },
      {
        ""Name"": ""setDeletionLimit, setCleaningLimit, setSearchLimit, setMarketCloseLimit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allow the UBER_OWNER to configure operational gas-saving limits."",
        ""Parameters"": [""uint256 _limit""],
        ""Returns"": []
      },
      {
        ""Name"": ""addMarket"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Initializes data structures for a new market, including creating placeholder bids."",
        ""Parameters"": [""address _market"", ""uint256 _cardCount"", ""uint256 _minIncrease""],
        ""Returns"": []
      },
      {
        ""Name"": ""addBidToOrderbook"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by Market contracts to add or update a user's bid for a specific card, managing the linked list and potentially triggering ownership changes."",
        ""Parameters"": [""address _user"", ""uint256 _card"", ""uint256 _price"", ""uint256 _timeHeldLimit"", ""address _prevUserAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""_searchOrderbook"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Finds the correct position (previous bid) in the linked list to insert a new bid based on price."",
        ""Parameters"": [""Bid storage _prevUser"", ""address _market"", ""uint256 _card"", ""uint256 _price""],
        ""Returns"": [""Bid storage"", ""uint256""]
      },
      {
        ""Name"": ""_newBidInOrderbook"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles the logic for inserting a completely new bid into the linked list."",
        ""Parameters"": [""address _user"", ""address _market"", ""uint256 _card"", ""uint256 _price"", ""uint256 _timeHeldLimit"", ""Bid storage _prevUser""],
        ""Returns"": []
      },
      {
        ""Name"": ""_updateBidInOrderbook"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles the logic for updating an existing bid's price/time limit and repositioning it in the linked list."",
        ""Parameters"": [""address _user"", ""address _market"", ""uint256 _card"", ""uint256 _price"", ""uint256 _timeHeldLimit"", ""Bid storage _prevUser""],
        ""Returns"": []
      },
      {
        ""Name"": ""removeBidFromOrderbook"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by Market contracts to remove a user's bid (cannot be the current owner)."",
        ""Parameters"": [""address _user"", ""uint256 _card""],
        ""Returns"": []
      },
      {
        ""Name"": ""_removeBidFromOrderbookIgnoreOwner"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Core logic for removing a bid from the linked list and updating storage, used by other functions."",
        ""Parameters"": [""address _user"", ""address _market"", ""uint256 _card""],
        ""Returns"": [""uint256 _newPrice""]
      },
      {
        ""Name"": ""findNewOwner"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by Market contracts when the current owner is invalidated (e.g., foreclosure). It iterates through lower bids, removing invalid ones until a suitable new owner is found."",
        ""Parameters"": [""uint256 _card"", ""uint256 _timeOwnershipChanged""],
        ""Returns"": []
      },
      {
        ""Name"": ""removeUserFromOrderbook"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows anyone to trigger the removal of bids for a user confirmed as foreclosed by the Treasury."",
        ""Parameters"": [""address _user""],
        ""Returns"": []
      },
      {
        ""Name"": ""closeMarket"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by Market contracts to initiate market closure. Moves remaining bids to a temporary holding area for later cleanup."",
        ""Parameters"": [],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""removeOldBids"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to clean up their own bids from markets that have been closed."",
        ""Parameters"": [""address _user""],
        ""Returns"": []
      },
      {
        ""Name"": ""cleanWastePile"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Processes and removes bids stored temporarily during market closure."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""bidExists"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Checks if a specific bid exists for a user, market, and card."",
        ""Parameters"": [""address _user"", ""address _market"", ""uint256 _card""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""getBidValue"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the price of a specific bid."",
        ""Parameters"": [""address _user"", ""uint256 _card""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getBid"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the full Bid struct for a specific bid."",
        ""Parameters"": [""address _market"", ""address _user"", ""uint256 _card""],
        ""Returns"": [""Bid memory""]
      },
      {
        ""Name"": ""getTimeHeldlimit"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the timeHeldLimit for a specific bid."",
        ""Parameters"": [""address _user"", ""uint256 _card""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""setTimeHeldlimit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows Market contracts to update the timeHeldLimit for a bid."",
        ""Parameters"": [""address _user"", ""uint256 _card"", ""uint256 _timeHeldLimit""],
        ""Returns"": []
      },
      {
        ""Name"": ""reduceTimeHeldLimit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows Market contracts to decrease the timeHeldLimit for a bid."",
        ""Parameters"": [""address _user"", ""uint256 _card"", ""uint256 _timeToReduce""],
        ""Returns"": []
      },
      {
        ""Name"": ""transferCard"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Updates the local ownerOf mapping and calls the transferCard function on the relevant Market contract."",
        ""Parameters"": [""address _market"", ""uint256 _card"", ""address _oldOwner"", ""address _newOwner"", ""uint256 _price""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IRCTreasury: Used extensively for permission checks (checkPermission), updating user bid/rental rates (increaseBidRate, decreaseBidRate, updateRentalRate), and checking/managing foreclosure status (foreclosureTimeUser, isForeclosed, assessForeclosure)."",
    ""IRCMarket: Called to get market configuration (numberOfCards, minimumPriceIncreasePercent, minRentalDayDivisor) and to execute the actual transfer of the card/asset between users (transferCard). The Orderbook contract itself is primarily called *by* Market contracts (enforced by onlyMarkets modifier).""
  ],
  ""SpecialMechanisms"": [
    ""Doubly Linked List: Bids for each card within a market are organized as a doubly linked list sorted by price, using the Bid struct's `prev` and `next` pointers and the `index` mapping for efficient lookups and modifications."",
    ""Meta Transactions: Inherits `NativeMetaTransaction`, likely enabling gasless transactions via a trusted forwarder (EIP-2771). `msgSender()` should resolve to the original user initiating the transaction."",
    ""Delegated Access Control: Uses role constants (UBER_OWNER, MARKET, etc.) but delegates the actual permission checking logic to the external `treasury.checkPermission` function."",
    ""State Cleanup: Includes multiple functions (`removeUserFromOrderbook`, `closeMarket`, `removeOldBids`, `cleanWastePile`) designed to manage contract state and prevent unbounded growth, particularly related to foreclosed users and closed markets."",
    ""Gas Control Limits: Configurable limits (`maxSearchIterations`, `maxDeletions`, etc.) are implemented to prevent certain operations (searching, cleaning, closing) from consuming excessive gas and potentially hitting block gas limits."",
    ""Waste Pile: Uses `address(this)` as a temporary holder in the `user` mapping during `closeMarket` to handle bids that need removal but are processed iteratively by `cleanWastePile`.""
  ],
  ""Questions"": [
    ""What is the exact purpose of the `Market.mode` field? It's set in `addMarket` but doesn't appear to be read elsewhere in this contract."",
    ""How is the `addMarket` internal function typically invoked? Presumably by a contract with the `FACTORY` role granted by the Treasury?"",
    ""The price adjustment logic in `_searchOrderbook` (`if (_prevUser.price != 0 && _prevUser.price < _price) { _price = _prevUser.price; }`) seems intended to prevent placing a bid lower than the preceding one, but needs careful review for edge cases. Is this the intended behavior?"",
    ""Are there potential reentrancy risks, especially in functions like `_newBidInOrderbook` and `_updateBidInOrderbook` that call external contracts (`treasury`, `_rcmarket.transferCard`) before state updates are fully complete (although most critical state like linked list pointers seems updated first)?"",
    ""How frequently is `cleanWastePile` expected to be called? Could the `user[address(this)]` array grow very large if it's not called often after market closures?"",
    ""What mechanisms prevent a malicious or compromised Market contract (if it somehow gets the MARKET role) from causing issues like incorrect owner changes or manipulating time limits?"",
    ""Is the `nonce` variable used for anything on-chain, or is it purely for external event tracking?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Denial of Service (DoS) via Unbounded Loops in Multiple Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Several functions contain loops that iterate based on the length of user bid arrays or other potentially large counts without sufficient safeguards against exceeding block gas limits. Specifically, `removeUserFromOrderbook` iterates through a user's potentially large bid list, `closeMarket` iterates through all bids in a market, `findNewOwner` iterates while removing bids, and `removeOldBids` iterates through closed markets and user bids. These loops, especially when combined with configurable limits like `maxDeletions` or `marketCloseLimit` set too high, or large amounts of data (user bids, closed markets), can consume excessive gas, leading to transaction reverts and Denial of Service. This can prevent critical operations like foreclosing users, closing markets, finding new owners after foreclosure, or cleaning up old bids."",
      ""Impact"": ""Denial of Service. Critical contract functions like `removeUserFromOrderbook`, `closeMarket`, `findNewOwner`, and `removeOldBids` may become unusable due to gas exhaustion, potentially freezing user accounts, preventing market closures, blocking foreclosure processes, or leading to storage bloat and inconsistencies."",
      ""Location"": ""Functions `removeUserFromOrderbook` (e.g., RCOrderbook.sol:471-489, RCOrderbook.sol:551-567), `closeMarket` (e.g., RCOrderbook.sol:502, RCOrderbook.sol:450), `findNewOwner`, `removeOldBids` (e.g., RCOrderbook.sol:477, RCOrderbook.sol:656-714), `cleanWastePile` (e.g., RCOrderbook.sol:718-759)""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerabilities via External Calls"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions make external calls to other contracts (`IRCMarket`, `treasury`) before completing state updates or within loops, opening potential reentrancy vectors. The `transferCard` function calls `IRCMarket.transferCard`, which could call back into `RCOrderbook`. Functions like `_newBidInOrderbook`, `_updateBidInOrderbook`, `removeBidFromOrderbook`, `_removeBidFromOrderbookIgnoreOwner`, `findNewOwner`, and `closeMarket` call various functions on the `treasury` contract. If either `IRCMarket` or `treasury` is malicious or compromised, or contains callback logic, an attacker could re-enter `RCOrderbook` mid-execution to manipulate state, potentially stealing cards, manipulating prices/rates, bypassing logic, or causing inconsistent states."",
      ""Impact"": ""Potential for attackers to manipulate orderbook state, steal cards, manipulate prices or rental rates, drain funds (if treasury is involved), or cause general contract malfunction through unexpected state changes during reentrant calls."",
      ""Location"": ""Functions `transferCard` (e.g., RCOrderbook.sol:607, RCOrderbook.sol:787-791, RCOrderbook.sol:952, RCOrderbook.sol:739), `_newBidInOrderbook`, `_updateBidInOrderbook`, `removeBidFromOrderbook`, `_removeBidFromOrderbookIgnoreOwner`, `findNewOwner`, `closeMarket` (interactions with `treasury`).""
    },
    {
      ""Issue"": ""Incorrect Array/Index Manipulation During Bid Removal"",
      ""Severity"": ""High"",
      ""Description"": ""The `_removeBidFromOrderbookIgnoreOwner` function incorrectly handles index updates after removing a bid by swapping it with the last element and popping. Specifically, it fails to validate array bounds before accessing the swapped element (`user[_user][_index].market`) when the array becomes empty after the pop, leading to reverts. Furthermore, it incorrectly updates the index mapping for the element that was moved into the removed bid's spot, potentially corrupting the `index` mapping, especially in edge cases where all bids for a user in a market are removed, causing `bidExists` to return false negatives."",
      ""Impact"": ""Potential for transactions to revert (DoS), incorrect index updates leading to data corruption in user bid lists and the `index` mapping, causing unexpected behavior in functions relying on accurate bid indexing and existence checks."",
      ""Location"": ""Function `_removeBidFromOrderbookIgnoreOwner` (e.g., RCOrderbook.sol:364, RCOrderbook.sol:450)""
    },
    {
      ""Issue"": ""Logic Error in `removeOldBids` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `removeOldBids` function contains flawed loop logic. The nested loop structure with `_subLoopCounter` and `_loopCounter` intended to limit gas usage can prevent bids from being removed effectively if `bidExists` returns false often. More critically, the inner `do...while (i > 0)` loop likely suffers from a scoping issue where `i` is not decremented correctly across iterations, potentially leading to infinite loops (limited by gas) or incorrect bid processing/removal. The check `_subLoopCounter > 100` might rarely trigger, hindering the intended gas limiting mechanism."",
      ""Impact"": ""Failure to remove old bids correctly, leading to storage bloat, inconsistent orderbook state, and potentially incorrect behavior in dependent logic. Gas exhaustion is possible due to faulty loop logic."",
      ""Location"": ""Function `removeOldBids` (e.g., RCOrderbook.sol:477, RCOrderbook.sol:656-714)""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Time and Price Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract performs arithmetic operations on `uint64` time values (`timeHeldLimit`, `minimumRentalDuration`) and `uint256` prices. Specifically, `reduceTimeHeldLimit` subtracts `_timeToReduce` without underflow checks. Time calculations in `findNewOwner` (`_timeOwnershipChanged + market[_market].minimumRentalDuration`) could overflow. Price calculations in `_searchOrderbook` (`_nextUser.price * (_minIncrease + 100)`) could overflow before division, leading to incorrect `_requiredPrice`. While `SafeCast` is used for type conversions, it doesn't protect against overflows/underflows in intermediate arithmetic operations."",
      ""Impact"": ""Incorrect time calculations can bypass rental duration logic, affect foreclosure timing, and lead to unexpected economic consequences. Price calculation overflows/rounding errors can lead to incorrect bid placement or search results."",
      ""Location"": ""Functions `reduceTimeHeldLimit` (e.g., RCOrderbook.sol:726), `findNewOwner` (e.g., RCOrderbook.sol:511), `_searchOrderbook` (e.g., RCOrderbook.sol:170, RCOrderbook.sol:333), `setTimeHeldlimit`""
    },
    {
      ""Issue"": ""Unsafe Casting from uint256 to Smaller Integers"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `addMarket`, `addBidToOrderbook`, `_newBidInOrderbook`, and `_updateBidInOrderbook` cast `uint256` inputs (`_cardCount`, `_minIncrease`, `_price`, `_timeHeldLimit`) to smaller types (`uint64`, `uint128`) using `SafeCast`. While `SafeCast` prevents silent truncation by reverting on overflow, this reliance means that inputs exceeding the target type's maximum value will cause transactions to fail. This doesn't prevent large valid values (close to `type(uint64).max`) from being set, which could still cause issues in subsequent calculations, and lacks graceful handling or validation for potentially oversized inputs derived from external contracts (`IRCMarket`)."",
      ""Impact"": ""Denial of Service for operations with inputs larger than the target type maximum (e.g., `uint64`). Potential for unexpected behavior if extremely large (but valid within the smaller type) values are used in calculations. Indirect exposure to manipulation if input values originate from external contracts."",
      ""Location"": ""Functions `addMarket` (e.g., RCOrderbook.sol:124, RCOrderbook.sol:127), `addBidToOrderbook` (e.g., RCOrderbook.sol:237), `_newBidInOrderbook`, `_updateBidInOrderbook`, `setTimeHeldlimit`""
    },
    {
      ""Issue"": ""Race Condition / Front Running in _searchOrderbook"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_searchOrderbook` function calculates the correct position for a new bid based on current orderbook state (e.g., `_nextUser.price`). However, the state of the orderbook can be changed by another transaction between the execution of `_searchOrderbook` and the actual insertion of the bid (`_newBidInOrderbook` or `_updateBidInOrderbook`). This race condition allows front-running, potentially causing the new bid to be inserted at an incorrect price or position, violating orderbook integrity."",
      ""Impact"": ""Orderbook corruption, incorrect bid placement (potentially allowing lower bids than intended), and potentially incorrect card transfers if logic depends on the assumed placement."",
      ""Location"": ""Function `_searchOrderbook` (e.g., RCOrderbook.sol:163 - RCOrderbook.sol:181) and its interaction with bid insertion functions.""
    },
    {
      ""Issue"": ""Potential State Issues and Loss of Funds in `findNewOwner`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `findNewOwner` function, besides the DoS risk from its loop, has potential state management issues. If the loop hits `maxDeletions` without finding a suitable owner, it saves `_oldOwner` and `_oldPrice` but lacks a mechanism to retry finding an owner later. The check `if (oldOwner[_market][_card] != address(0))` only occurs at the start, meaning if the initial call fails to find a new owner, `oldOwner` might be permanently set, preventing future attempts and potentially locking the card state. The current owner is removed from the orderbook during this process, meaning they might lose access to funds associated with the card if the `ownerOf` state isn't correctly updated."",
      ""Impact"": ""Potential permanent inability to find a new owner for a card after foreclosure attempt, locking the card state. Temporary or permanent loss of funds for the original owner if the ownership transfer fails to complete while their bid is removed."",
      ""Location"": ""Function `findNewOwner`""
    },
    {
      ""Issue"": ""Incomplete Foreclosure Logic in `removeUserFromOrderbook`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `removeUserFromOrderbook` function might not remove all of a user's bids if `maxDeletions` is reached before processing the entire list. While it calls `treasury.assessForeclosure(_user)` afterwards, the user might still retain some bids in the orderbook even though the treasury considers them foreclosed (partially or fully). This creates a state desynchronization between the orderbook and the treasury regarding the user's bid status."",
      ""Impact"": ""Inconsistent state between `RCOrderbook` and `treasury`. A user might be marked as foreclosed but still hold bids, leading to potential logic errors or unexpected behavior in interactions involving both contracts."",
      ""Location"": ""Function `removeUserFromOrderbook`""
    },
    {
      ""Issue"": ""Missing Access Control / Input Validation Issues"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions lack necessary access control or input validation: 1) `removeUserFromOrderbook` only checks if the user is foreclosed, potentially allowing the foreclosed user to trigger their own bid removal. 2) `addBidToOrderbook` does not validate if `_user` is the zero address. 3) `closeMarket` logic for moving bids to the waste pile (`user[address(this)]`) seems flawed, potentially leaving indexes out of sync."",
      ""Impact"": ""Potential for unauthorized actions (self-removal of bids by foreclosed user), state corruption due to zero address inputs, incorrect orderbook state, data corruption, and unexpected behaviors due to flawed logic in `closeMarket`."",
      ""Location"": ""Functions `removeUserFromOrderbook`, `addBidToOrderbook`, `closeMarket` (e.g., RCOrderbook.sol:450)""
    },
    {
      ""Issue"": ""Rounding Errors and Incorrect Calculation in `_searchOrderbook` Price Check"",
      ""Severity"": ""Low"",
      ""Description"": ""The calculation of `_requiredPrice` in `_searchOrderbook` uses integer division: `(_nextUser.price * (_minIncrease + 100)) / 100`. This can lead to rounding errors, potentially preventing users from placing bids at technically valid prices that fall victim to the rounding down. Small discrepancies can affect the precise ordering and minimum increase enforcement."",
      ""Impact"": ""Users might be unable to place bids at certain valid price points close to the required minimum increase due to rounding errors, slightly hindering market efficiency."",
      ""Location"": ""Function `_searchOrderbook` (e.g., RCOrderbook.sol:333)""
    },
    {
      ""Issue"": ""Lack of Input Validation on Critical Parameters"",
      ""Severity"": ""Low"",
      ""Description"": ""Several functions lack validation for critical inputs beyond basic type safety: 1) `setTimeHeldlimit` doesn't check if `_timeHeldLimit` is within a reasonable range, allowing potentially extreme values. 2) `setTreasuryAddress` checks for the zero address but not if the address is a contract or implements the correct interface. 3) `addBidToOrderbook` does not validate `_card` against the market's `_cardCount`."",
      ""Impact"": ""Potential for unintended consequences due to extreme time limits, contract malfunction if an invalid treasury address is set, or unexpected state changes if invalid card IDs are used (though partially mitigated elsewhere)."",
      ""Location"": ""Functions `setTimeHeldlimit` (e.g., RCOrderbook.sol:593), `setTreasuryAddress` (e.g., RCOrderbook.sol:153), `addBidToOrderbook`""
    },
    {
      ""Issue"": ""Problematic Use of `assert`"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses `assert` in `removeBidFromOrderbook` (e.g., `assert(_user != ownerOf[_market][_card]);`, `assert(!bidExists(...))`). Asserts are primarily for checking internal invariants and consume all remaining gas if triggered. Relying on them for conditions that *might* fail due to unexpected states (even if unlikely) can lead to transactions reverting with full gas consumption, causing a localized DoS for that specific operation. While the specific asserts might rarely fail in normal operation, using `require` is generally preferred for validating conditions that depend on state or inputs."",
      ""Impact"": ""Potential for specific transactions (like `removeBidFromOrderbook`) to revert unexpectedly and consume all gas if an invariant assumption is violated, hindering that specific operation."",
      ""Location"": ""Function `removeBidFromOrderbook` (e.g., RCOrderbook.sol:457, RCOrderbook.sol:440, RCOrderbook.sol:414, RCOrderbook.sol:407, RCOrderbook.sol:434)""
    },
    {
      ""Issue"": ""Potential Stale Data in `closedMarkets` and `cleanWastePile`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `closedMarkets` array stores closed market addresses, and `userClosedMarketIndex` tracks user progress. There's no mechanism to remove markets if reopened, potentially causing `removeOldBids` to iterate over irrelevant markets. `userClosedMarketIndex` also increments without bounds. The `cleanWastePile` function removes bids from the 'waste pile' but doesn't guarantee that other functions relying on bid data haven't already operated on stale information before the cleanup."",
      ""Impact"": ""Reduced efficiency in `removeOldBids`, potential storage bloat for `userClosedMarketIndex`. Potential logic errors if functions rely on data from bids that are pending cleanup in the waste pile."",
      ""Location"": ""Related to `closedMarkets` array (e.g., RCOrderbook.sol:461), `userClosedMarketIndex` (e.g., RCOrderbook.sol:563), and function `cleanWastePile`.""
    },
    {
      ""Issue"": ""Unnecessary Gas Consumption in `_searchOrderbook` Edge Case"",
      ""Severity"": ""Low"",
      ""Description"": ""In `_searchOrderbook`, the check `if (_prevUser.price != 0 && _prevUser.price < _price)` is redundant when the user is already at the top of the orderbook chain (i.e., `_prevUser` represents the highest bid). In this specific edge case, the condition will always be false, consuming unnecessary gas."",
      ""Impact"": ""Minor increase in gas consumption for users placing bids at the very top of the orderbook."",
      ""Location"": ""Function `_searchOrderbook`""
    },
    {
      ""Issue"": ""Integer Overflow/Underflow Protection Relies on Compiler Version"",
      ""Severity"": ""Informational"",
      ""Description"": ""The contract uses `pragma solidity ^0.8.0;`, which provides default protection against integer overflows and underflows. This finding is informational, confirming the presence of this protection due to the compiler version."",
      ""Impact"": ""None if compiled with Solidity 0.8.0 or later. Potential vulnerabilities if compiled with versions prior to 0.8.0."",
      ""Location"": ""Contract-wide (pragma solidity ^0.8.0;)""
    }
  ],
  ""IssueNumber"": 56,
  ""OutputList"": 17
}",301.12077283859253,4343.0,32.0,"### **[H-01] findNewOwner Edge Case**

**Report Description**:
The `findNewOwner` function in `RCOrderbook` contains a loop that checks `_loopCounter < maxDeletions`. After the loop, a condition `(_loopCounter != maxDeletions)` is used to determine if processing is finished. However, there is an edge case where processing might be completed exactly when `_loopCounter == maxDeletions`. This issue is most evident when `maxDeletions == 1`, where the function will never conclude that processing is finished. While `maxDeletions == 1` is unlikely in practice, the logic flaw remains a vulnerability.

**Match in Response List**:
Matches with the issue titled **""Potential State Issues and Loss of Funds in `findNewOwner`""**.

**Validation**:
**Partially Correct**. The response identifies the `findNewOwner` function and mentions potential state management issues, including the risk of failing to find a new owner and the associated loss of funds. However, it does not explicitly address the specific edge case where `_loopCounter == maxDeletions` could lead to incorrect conclusions about processing completion. The response covers broader risks but misses the precise logic flaw described in the issue report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[H-01] findNewOwner Edge Case**

**Missed Issues from Issue Report**:
- *None*

---

### **Analysis**
The response partially addresses the issue by identifying risks in the `findNewOwner` function but fails to fully capture the specific edge case described in the issue report. The logic flaw in the loop termination condition is a critical detail that is not covered in the response. While the response is not incorrect, it is incomplete in addressing the exact vulnerability.","```
None.
```",0.0
RCTreasury.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";

/// @title Reality Cards Treasury
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {
    using SafeERC20 for IERC20;

    /*╔═════════════════════════════════╗
      ║             VARIABLES           ║
      ╚═════════════════════════════════╝*/
    /// @dev orderbook instance, to remove users bids on foreclosure
    IRCOrderbook public override orderbook;
    /// @dev leaderboard instance
    IRCLeaderboard public override leaderboard;
    /// @dev token contract
    IERC20 public override erc20;
    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet
    address public override bridgeAddress;
    /// @dev the Factory so only the Factory can add new markets
    IRCFactory public override factory;
    /// @dev sum of all deposits
    uint256 public override totalDeposits;
    /// @dev the rental payments made in each market
    mapping(address => uint256) public override marketPot;
    /// @dev sum of all market pots
    uint256 public override totalMarketPots;
    /// @dev rent taken and allocated to a particular market
    uint256 public override marketBalance;
    /// @dev a quick check if a user is foreclosed
    mapping(address => bool) public override isForeclosed;
    /// @dev to keep track of the size of the rounding issue between rent collections
    uint256 public override marketBalanceTopup;

    /// @param deposit the users current deposit in wei
    /// @param rentalRate the daily cost of the cards the user current owns
    /// @param bidRate the sum total of all placed bids
    /// @param lastRentCalc The timestamp of the users last rent calculation
    /// @param lastRentalTime The timestamp the user last made a rental
    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;

    /*╔═════════════════════════════════╗
      ║      GOVERNANCE VARIABLES       ║
      ╚═════════════════════════════════╝*/
    /// @dev only parameters that need to be are here, the rest are in the Factory
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public override minRentalDayDivisor;
    /// @dev max deposit balance, to minimise funds at risk
    uint256 public override maxContractBalance;
    /// @dev whitelist to only allow certain addresses to deposit
    /// @dev intended for beta use only, will be disabled after launch
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;
    /// @dev allow markets to be restricted to a certain role
    mapping(address => bytes32) public marketWhitelist;

    /*╔═════════════════════════════════╗
      ║             SAFETY              ║
      ╚═════════════════════════════════╝*/
    /// @dev if true, cannot deposit, withdraw or rent any cards across all events
    bool public override globalPause;
    /// @dev if true, cannot rent, claim or upgrade any cards for specific market
    mapping(address => bool) public override marketPaused;
    /// @dev if true, owner has locked the market pause (Governors are locked out)
    mapping(address => bool) public override lockMarketPaused;

    /*╔═════════════════════════════════╗
      ║          Access Control         ║
      ╚═════════════════════════════════╝*/
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");

    /*╔═════════════════════════════════╗
      ║             EVENTS              ║
      ╚═════════════════════════════════╝*/

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);
    event LogWhitelistUser(address user, bool allowed);

    /*╔═════════════════════════════════╗
      ║           CONSTRUCTOR           ║
      ╚═════════════════════════════════╝*/

    constructor(address _tokenAddress) {
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        /* setup AccessControl

                         UBER_OWNER
            ┌───────────┬────┴─────┬────────────┬─────────┐
            │           │          │            │         │
          OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD
            │           │
         GOVERNOR     MARKET
            │
         WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE
        */
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(UBER_OWNER, _msgSender());
        _setupRole(OWNER, _msgSender());
        _setupRole(GOVERNOR, _msgSender());
        _setupRole(WHITELIST, _msgSender());
        _setupRole(TREASURY, address(this));
        _setRoleAdmin(UBER_OWNER, UBER_OWNER);
        _setRoleAdmin(OWNER, UBER_OWNER);
        _setRoleAdmin(FACTORY, UBER_OWNER);
        _setRoleAdmin(ORDERBOOK, UBER_OWNER);
        _setRoleAdmin(TREASURY, UBER_OWNER);
        _setRoleAdmin(GOVERNOR, OWNER);
        _setRoleAdmin(WHITELIST, GOVERNOR);
        _setRoleAdmin(ARTIST, GOVERNOR);
        _setRoleAdmin(AFFILIATE, GOVERNOR);
        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);
        _setRoleAdmin(MARKET, FACTORY);

        // initialise adjustable parameters
        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes
        setMaxContractBalance(1_000_000 ether); // 1m
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    /// @notice check that funds haven't gone missing during this function call
    modifier balancedBooks() {
        _;
        // using >= not == in case anyone sends tokens direct to contract
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/

    /// @dev all functions should be onlyRole(OWNER)
    // min rental event emitted by market. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUCTOR - PUBLIC │
      └────────────────────────────────────┘*/

    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    /// @param _newDivisor the divisor to set
    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {
        minRentalDayDivisor = _newDivisor;
    }

    /// @notice set max deposit balance, to minimise funds at risk
    /// @dev this is only a soft check, it is possible to exceed this limit
    /// @param _newBalanceLimit the max balance to set in wei
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyRole(OWNER)
    {
        maxContractBalance = _newBalanceLimit;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL │
      └──────────────────────────────────────────┘*/

    /// @notice if true, cannot deposit, withdraw or rent any cards
    function changeGlobalPause() external override onlyRole(OWNER) {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    /// @notice if true, cannot make a new rental, or claim the NFT for a specific market
    function changePauseMarket(address _market, bool _paused)
        external
        override
        onlyRole(OWNER)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        marketPaused[_market] = _paused;
        lockMarketPaused[_market] = marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /// @notice allow governance (via the factory) to approve and un pause the market if the owner hasn't paused it
    function unPauseMarket(address _market)
        external
        override
        onlyRole(FACTORY)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        require(!lockMarketPaused[_market], ""Owner has paused market"");
        marketPaused[_market] = false;
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /*╔═════════════════════════════════╗
      ║      WHITELIST FUNCTIONS        ║
      ╚═════════════════════════════════╝*/

    /// @notice if true, users must be on the whitelist to deposit
    function toggleWhitelist() external override onlyRole(OWNER) {
        whitelistEnabled = !whitelistEnabled;
    }

    /// @notice Add/Remove multiple users to the whitelist
    /// @param _users an array of users to add or remove
    /// @param add true to add the users
    function batchWhitelist(address[] calldata _users, bool add)
        external
        override
        onlyRole(GOVERNOR)
    {
        if (add) {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.grantRole(WHITELIST, _users[index]);
            }
        } else {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.revokeRole(WHITELIST, _users[index]);
            }
        }
    }

    /// @notice Some markets may be restricted to certain roles,
    /// @notice This function checks if the user has the role requried for a given market
    /// @dev Used for the markets to check themselves
    /// @param _user The user to check
    function marketWhitelistCheck(address _user)
        external
        view
        override
        returns (bool)
    {
        bytes32 requiredRole = marketWhitelist[msgSender()];
        if (requiredRole == bytes32(0)) {
            return true;
        } else {
            return hasRole(requiredRole, _user);
        }
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades
    /// @dev deploying and setting a new factory is effectively an upgrade
    /// @dev this is seperate so owner so can be set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governance functions

    function setFactoryAddress(address _newFactory)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newFactory != address(0), ""Must set an address"");
        // factory is also an OWNER and GOVERNOR to use the proxy functions
        revokeRole(FACTORY, address(factory));
        revokeRole(OWNER, address(factory));
        revokeRole(GOVERNOR, address(factory));
        factory = IRCFactory(_newFactory);
        grantRole(FACTORY, address(factory));
        grantRole(OWNER, address(factory));
        grantRole(GOVERNOR, address(factory));
    }

    function setOrderbookAddress(address _newOrderbook)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newOrderbook != address(0), ""Must set an address"");
        revokeRole(ORDERBOOK, address(orderbook));
        orderbook = IRCOrderbook(_newOrderbook);
        grantRole(ORDERBOOK, address(orderbook));
        factory.setOrderbookAddress(orderbook);
    }

    function setLeaderboardAddress(address _newLeaderboard)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newLeaderboard != address(0), ""Must set an address"");
        leaderboard = IRCLeaderboard(_newLeaderboard);
        factory.setLeaderboardAddress(leaderboard);
    }

    function setTokenAddress(address _newToken)
        public
        override
        onlyRole(UBER_OWNER)
    {
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    /// @notice Disaster recovery, pulls all funds from the Treasury to the UberOwner
    function globalExit() external onlyRole(UBER_OWNER) {
        uint256 _balance = erc20.balanceOf(address(this));
        /// @dev using msg.sender instead of msgSender as a precaution should Meta-Tx be compromised
        erc20.safeTransfer(msg.sender, _balance);
    }

    /*╔═════════════════════════════════╗
      ║ DEPOSIT AND WITHDRAW FUNCTIONS  ║
      ╚═════════════════════════════════╝*/

    /// @notice deposit tokens into RealityCards
    /// @dev it is passed the user instead of using msg.sender because might be called
    /// @dev ... via contract or Layer1->Layer2 bot
    /// @param _user the user to credit the deposit to
    /// @param _amount the amount to deposit, must be approved
    function deposit(uint256 _amount, address _user)
        external
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(hasRole(WHITELIST, _user), ""Not in whitelist"");
        }
        erc20.safeTransferFrom(msgSender(), address(this), _amount);

        // do some cleaning up, it might help cancel their foreclosure
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        // this deposit could cancel the users foreclosure
        assessForeclosure(_user);
        return true;
    }

    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet
    /// @dev this is the only function where funds leave the contract
    /// @param _amount the amount to withdraw
    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        // only allow withdraw if they have no bids,
        // OR they've had their cards for at least the minimum rental period
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        // step 1: collect rent on owned cards
        collectRentUser(_msgSender, block.timestamp);

        // step 2: process withdrawal
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.safeTransfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        // step 3: remove bids if insufficient deposit
        // do some cleaning up first, it might help avoid their foreclosure
        orderbook.removeOldBids(_msgSender);
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            // foreclose user, this is requred to remove them from the orderbook
            isForeclosed[_msgSender] = true;
            // remove them from the orderbook
            orderbook.removeUserFromOrderbook(_msgSender);
        }
    }

    /// @notice to increase the market balance
    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues
    function topupMarketBalance(uint256 _amount)
        external
        override
        balancedBooks
    {
        erc20.safeTransferFrom(msgSender(), address(this), _amount);
        marketBalanceTopup += _amount;
        marketBalance += _amount;
    }

    /*╔═════════════════════════════════╗
      ║         ERC20 helpers           ║
      ╚═════════════════════════════════╝*/

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    /*╔═════════════════════════════════╗
      ║        MARKET CALLABLE          ║
      ╚═════════════════════════════════╝*/
    // only markets can call these functions

    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,
    /// @notice ..called by _collectRent in the market
    /// @param _amount amount of rent to pay in wei
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (uint256)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            uint256 discrepancy = _amount - marketBalance;
            if (discrepancy > marketBalanceTopup) {
                marketBalanceTopup = 0;
            } else {
                marketBalanceTopup -= discrepancy;
            }
            _amount = marketBalance;
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;
        /// @dev return the amount just incase it was adjusted
        return _amount;
    }

    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)
    /// @param _user the user to query
    /// @param _amount amount to payout in wei
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        assessForeclosure(_user);
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent
    function refundUser(address _user, uint256 _refund)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        assessForeclosure(_user);
    }

    /// @notice ability to add liquidity to the pot without being able to win (called by market sponsor function).
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        address _msgSender = msgSender();
        require(!lockMarketPaused[_msgSender], ""Market is paused"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.safeTransferFrom(_sponsor, address(this), _amount);
        marketPot[_msgSender] += _amount;
        totalMarketPots += _amount;
    }

    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,
    /// @notice ..thus bypassing minimum rental duration
    /// @param _user the user to query
    function updateLastRentalTime(address _user)
        external
        override
        onlyRole(MARKET)
    {
        // update the last rental time
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        // check if this is their first rental (no previous rental calculation)
        if (user[_user].lastRentCalc == 0) {
            // we need to start their clock ticking, update their last rental calculation time
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
    }

    /*╔═════════════════════════════════╗
      ║        MARKET HELPERS           ║
      ╚═════════════════════════════════╝*/

    function addMarket(address _market, bool _paused) external override {
        require(hasRole(FACTORY, msgSender()), ""Not Authorised"");
        marketPaused[_market] = _paused;
        AccessControl.grantRole(MARKET, _market);
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /// @notice provides the sum total of a users bids across all markets (whether active or not)
    /// @param _user the user address to query
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    /// @notice provide the users remaining deposit
    /// @param _user the user address to query
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    /*╔═════════════════════════════════╗
      ║      ORDERBOOK CALLABLE         ║
      ╚═════════════════════════════════╝*/

    /// @notice updates users rental rates when ownership changes
    /// @dev rentalRate = sum of all active bids
    /// @param _oldOwner the address of the user losing ownership
    /// @param _newOwner the address of the user gaining ownership
    /// @param _oldPrice the price the old owner was paying
    /// @param _newPrice the price the new owner will be paying
    /// @param _timeOwnershipChanged the timestamp of this event
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyRole(ORDERBOOK) {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !hasRole(MARKET, _newOwner)
        ) {
            // The new owners rent must be collected before adjusting their rentalRate
            // See if the new owner has had a rent collection before or after this ownership change
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                // the new owner has a more recent rent collection

                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(
                    user[_newOwner].lastRentCalc,
                    _timeOwnershipChanged,
                    _newPrice
                );

                // they have enough funds, just collect the extra
                // we can be sure of this because it was checked they can cover the minimum rental
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);
            } else {
                // the new owner has an old rent collection, do they own anything else?
                if (user[_newOwner].rentalRate != 0) {
                    // rent collect upto ownership change time
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    // first card owned, set start time
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                    // send an event for the UI to have a timestamp
                    emit LogAdjustDeposit(_newOwner, 0, false);
                }
            }
        }
        // Must add before subtract, to avoid underflow in the case a user is only updating their price.
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    /// @dev increase bidRate when new bid entered
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    /// @dev decrease bidRate when bid removed
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    /*╔═════════════════════════════════╗
      ║      RENT CALC HELPERS          ║
      ╚═════════════════════════════════╝*/

    /// @notice returns the rent due between the users last rent calculation and
    /// @notice ..the current block.timestamp for all cards a user owns
    /// @param _user the user to query
    /// @param _timeOfCollection calculate upto a given time
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    /// @notice calculates the rent owed between the given timestamps
    /// @param _time1 one of the timestamps
    /// @param _time2 the second timestamp
    /// @param _price the rental rate for this time period
    /// @param _rent the rent due for this time period
    /// @dev the timestamps can be given in any order
    function rentOwedBetweenTimestamps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    /// @notice returns the current estimate of the users foreclosure time
    /// @param _user the user to query
    /// @param _newBid calculate foreclosure including a new card
    /// @param _timeOfNewBid timestamp of when a new card was gained
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /
                totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +
                timeLeftOfDeposit;

            if (
                foreclosureTimeWithoutNewCard > _timeOfNewBid &&
                _timeOfNewBid != 0
            ) {
                // calculate how long they can own the new card for
                uint256 _rentDifference = rentOwedBetweenTimestamps(
                    user[_user].lastRentCalc,
                    _timeOfNewBid,
                    totalUserDailyRent
                );
                uint256 _depositAtTimeOfNewBid = 0;

                if (user[_user].lastRentCalc < _timeOfNewBid) {
                    // new bid is after user rent calculation
                    _depositAtTimeOfNewBid =
                        user[_user].deposit -
                        _rentDifference;
                } else {
                    // new bid is before user rent calculation
                    _depositAtTimeOfNewBid =
                        user[_user].deposit +
                        _rentDifference;
                }

                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *
                    1 days) / (totalUserDailyRent + _newBid);

                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +
                    _timeLeftOfDepositWithNewBid;
                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {
                    return _foreclosureTimeWithNewCard;
                } else {
                    // The user couldn't afford to own the new card up to their last
                    // .. rent calculation, we can't rewind their rent calculation because
                    // .. of gas limits (there could be many markets having taken rent).
                    // Therefore unfortunately we can't give any ownership to this user as
                    // .. this could mean getting caught in a loop we may not be able to
                    // .. exit because of gas limits (there could be many users in this
                    // .. situation and we can't leave any unaccounted for).
                    // This means we return 0 to signify that the user can't afford this
                    // .. new ownership.
                    return 0;
                }
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            if (_newBid == 0) {
                // if no rentals they'll foreclose after the heat death of the universe
                return type(uint256).max;
            } else {
                return
                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);
            }
        }
    }

    /// @notice call for a rent collection on the given user
    /// @notice IF the user doesn't have enough deposit, returns foreclosure time
    /// @notice ..otherwise returns zero
    /// @param _user the user to query
    /// @param _timeToCollectTo the timestamp to collect rent upto
    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        require(_timeToCollectTo != 0, ""Must set collection time"");
        require(
            _timeToCollectTo <= block.timestamp,
            ""Can't collect future rent""
        );
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                // The User has run out of deposit already.
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                /*
            timeTheirDepositLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)
                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)
            */
                uint256 timeUsersDepositLasts = ((_timeToCollectTo -
                    previousCollectionTime) * uint256(user[_user].deposit)) /
                    rentOwedByUser;
                /*
            Users last collection time = previousCollectionTime + timeTheirDepositLasted
            */
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                // User has enough deposit to pay rent.
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    /// moving from the user deposit to the markets available balance
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }

    /// @notice checks if the user should still be foreclosed
    function assessForeclosure(address _user) public override {
        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        } else {
            isForeclosed[_user] = true;
            emit LogUserForeclosed(_user, true);
        }
    }

    /// @dev can't be called hasRole also because AccessControl.hasRole isn't virtual
    function checkPermission(bytes32 role, address account)
        external
        view
        override
        returns (bool)
    {
        return AccessControl.hasRole(role, account);
    }

    function grantRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.grantRole(_role, account);
    }

    function grantRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            // need to emit old event until frontend catches up
            emit LogWhitelistUser(account, true);
        }
        AccessControl.grantRole(role, account);
    }

    function revokeRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.revokeRole(_role, account);
    }

    function revokeRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            // need to emit old event until frontend catches up
            emit LogWhitelistUser(account, false);
        }
        AccessControl.revokeRole(role, account);
    }

    /*
         ▲  
        ▲ ▲ 
              */
}",8609,920,"[H-02] UberOwner has too much power

The`Uber_Owner` has too much power within the system. This makes the protocol closer to a centralized prediction market whose rules are determined by the Uber Owner. See issue page for referenced code
The above functions can be used by the Uber Owner to completely change the functionality of the system. This goes well beyond simple setting new constants and fees, the Uber Owner can basically reprogram how the entire protocol works. Not to mention if the address falls into the wrong hands.
Recommend limiting the permission of the Uber Owner to something more manageable and trustable. If upgrades to underlying contracts are required they can be done through a proxy instead, in the standard way.
 [M-01] Uninitialized Variable marketWhitelist in RCTreasury.sol

The variable, `marketWhitelist`, is never initialized in the contract RCTreasury.sol. As a result, the function marketWhitelistCheck() does not perform a proper check on whitelisted users for a restricted market. Additionally, the function will always return true, even if a market wishes to restrict its users to a specific role.
The initial state variable is defined in RCTreasury.sol L75.
The state variable marketWhitelist is accessed in the function RCTreasury.marketWhitelistCheck() at RCTreasury.sol L269-L281.
The function RCTreasury.marketWhitelistCheck() is called in RCMarket.newRental() at RCMarket.sol L758-L761. The comment indicates that there should be some ability to restrict certain markets to specific whitelists, however, there are no methods in RCTreasury that allow a market creator to enable this functionality.
Recommend ensuring this behavior is intended. If this is not the case, consider adding a function that enables a market creator to restrict their market to a specific role by whitelisting users.
 [M-03] Deposits don't work with fee-on transfer tokens

There are ERC20 tokens that may make certain customizations to their ERC20 contracts. One type of these tokens is deflationary tokens that charge a certain fee for every transfer() or transferFrom(). Others are rebasing tokens that increase in value over time like Aave's aTokens (balanceOf changes over time).
The RCTreasury.deposit() function will credit more deposits than the contract actually received:
erc20.safeTransferFrom(msgSender(), address(this), _amount);
user[_user].deposit += SafeCast.toUint128(_amount);
",3,,"pragma solidity 0.8.7;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";




contract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {
    using SafeERC20 for IERC20;

    
    
    IRCOrderbook public override orderbook;
    
    IRCLeaderboard public override leaderboard;
    
    IERC20 public override erc20;
    
    address public override bridgeAddress;
    
    IRCFactory public override factory;
    
    uint256 public override totalDeposits;
    
    mapping(address => uint256) public override marketPot;
    
    uint256 public override totalMarketPots;
    
    uint256 public override marketBalance;
    
    mapping(address => bool) public override isForeclosed;
    
    uint256 public override marketBalanceTopup;

    
    
    
    
    
    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;

    
    
    
    uint256 public override minRentalDayDivisor;
    
    uint256 public override maxContractBalance;
    
    
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;
    
    mapping(address => bytes32) public marketWhitelist;

    
    
    bool public override globalPause;
    
    mapping(address => bool) public override marketPaused;
    
    mapping(address => bool) public override lockMarketPaused;

    
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");

    

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);
    event LogWhitelistUser(address user, bool allowed);

    

    constructor(address _tokenAddress) {
        
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(UBER_OWNER, _msgSender());
        _setupRole(OWNER, _msgSender());
        _setupRole(GOVERNOR, _msgSender());
        _setupRole(WHITELIST, _msgSender());
        _setupRole(TREASURY, address(this));
        _setRoleAdmin(UBER_OWNER, UBER_OWNER);
        _setRoleAdmin(OWNER, UBER_OWNER);
        _setRoleAdmin(FACTORY, UBER_OWNER);
        _setRoleAdmin(ORDERBOOK, UBER_OWNER);
        _setRoleAdmin(TREASURY, UBER_OWNER);
        _setRoleAdmin(GOVERNOR, OWNER);
        _setRoleAdmin(WHITELIST, GOVERNOR);
        _setRoleAdmin(ARTIST, GOVERNOR);
        _setRoleAdmin(AFFILIATE, GOVERNOR);
        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);
        _setRoleAdmin(MARKET, FACTORY);

        
        setMinRental(24 * 6); 
        setMaxContractBalance(1_000_000 ether); 
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    

    
    modifier balancedBooks() {
        _;
        
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    

    
    

    

    
    
    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {
        minRentalDayDivisor = _newDivisor;
    }

    
    
    
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyRole(OWNER)
    {
        maxContractBalance = _newBalanceLimit;
    }

    

    
    function changeGlobalPause() external override onlyRole(OWNER) {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    
    function changePauseMarket(address _market, bool _paused)
        external
        override
        onlyRole(OWNER)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        marketPaused[_market] = _paused;
        lockMarketPaused[_market] = marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    
    function unPauseMarket(address _market)
        external
        override
        onlyRole(FACTORY)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        require(!lockMarketPaused[_market], ""Owner has paused market"");
        marketPaused[_market] = false;
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    

    
    function toggleWhitelist() external override onlyRole(OWNER) {
        whitelistEnabled = !whitelistEnabled;
    }

    
    
    
    function batchWhitelist(address[] calldata _users, bool add)
        external
        override
        onlyRole(GOVERNOR)
    {
        if (add) {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.grantRole(WHITELIST, _users[index]);
            }
        } else {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.revokeRole(WHITELIST, _users[index]);
            }
        }
    }

    
    
    
    
    function marketWhitelistCheck(address _user)
        external
        view
        override
        returns (bool)
    {
        bytes32 requiredRole = marketWhitelist[msgSender()];
        if (requiredRole == bytes32(0)) {
            return true;
        } else {
            return hasRole(requiredRole, _user);
        }
    }

    
    
    
    
    

    function setFactoryAddress(address _newFactory)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newFactory != address(0), ""Must set an address"");
        
        revokeRole(FACTORY, address(factory));
        revokeRole(OWNER, address(factory));
        revokeRole(GOVERNOR, address(factory));
        factory = IRCFactory(_newFactory);
        grantRole(FACTORY, address(factory));
        grantRole(OWNER, address(factory));
        grantRole(GOVERNOR, address(factory));
    }

    function setOrderbookAddress(address _newOrderbook)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newOrderbook != address(0), ""Must set an address"");
        revokeRole(ORDERBOOK, address(orderbook));
        orderbook = IRCOrderbook(_newOrderbook);
        grantRole(ORDERBOOK, address(orderbook));
        factory.setOrderbookAddress(orderbook);
    }

    function setLeaderboardAddress(address _newLeaderboard)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newLeaderboard != address(0), ""Must set an address"");
        leaderboard = IRCLeaderboard(_newLeaderboard);
        factory.setLeaderboardAddress(leaderboard);
    }

    function setTokenAddress(address _newToken)
        public
        override
        onlyRole(UBER_OWNER)
    {
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    
    function globalExit() external onlyRole(UBER_OWNER) {
        uint256 _balance = erc20.balanceOf(address(this));
        
        erc20.safeTransfer(msg.sender, _balance);
    }

    

    
    
    
    
    
    function deposit(uint256 _amount, address _user)
        external
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(hasRole(WHITELIST, _user), ""Not in whitelist"");
        }
        erc20.safeTransferFrom(msgSender(), address(this), _amount);

        
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        
        assessForeclosure(_user);
        return true;
    }

    
    
    
    
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        
        
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        
        collectRentUser(_msgSender, block.timestamp);

        
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.safeTransfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        
        
        orderbook.removeOldBids(_msgSender);
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            
            isForeclosed[_msgSender] = true;
            
            orderbook.removeUserFromOrderbook(_msgSender);
        }
    }

    
    
    function topupMarketBalance(uint256 _amount)
        external
        override
        balancedBooks
    {
        erc20.safeTransferFrom(msgSender(), address(this), _amount);
        marketBalanceTopup += _amount;
        marketBalance += _amount;
    }

    

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    
    

    
    
    
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (uint256)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            uint256 discrepancy = _amount - marketBalance;
            if (discrepancy > marketBalanceTopup) {
                marketBalanceTopup = 0;
            } else {
                marketBalanceTopup -= discrepancy;
            }
            _amount = marketBalance;
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;
        
        return _amount;
    }

    
    
    
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        assessForeclosure(_user);
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    
    function refundUser(address _user, uint256 _refund)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        assessForeclosure(_user);
    }

    
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        address _msgSender = msgSender();
        require(!lockMarketPaused[_msgSender], ""Market is paused"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.safeTransferFrom(_sponsor, address(this), _amount);
        marketPot[_msgSender] += _amount;
        totalMarketPots += _amount;
    }

    
    
    
    function updateLastRentalTime(address _user)
        external
        override
        onlyRole(MARKET)
    {
        
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        
        if (user[_user].lastRentCalc == 0) {
            
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
    }

    

    function addMarket(address _market, bool _paused) external override {
        require(hasRole(FACTORY, msgSender()), ""Not Authorised"");
        marketPaused[_market] = _paused;
        AccessControl.grantRole(MARKET, _market);
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    
    
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    
    
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    

    
    
    
    
    
    
    
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyRole(ORDERBOOK) {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !hasRole(MARKET, _newOwner)
        ) {
            
            
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                

                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(
                    user[_newOwner].lastRentCalc,
                    _timeOwnershipChanged,
                    _newPrice
                );

                
                
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);
            } else {
                
                if (user[_newOwner].rentalRate != 0) {
                    
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                    
                    emit LogAdjustDeposit(_newOwner, 0, false);
                }
            }
        }
        
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    

    
    
    
    
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    
    
    
    
    
    
    function rentOwedBetweenTimestamps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    
    
    
    
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /
                totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +
                timeLeftOfDeposit;

            if (
                foreclosureTimeWithoutNewCard > _timeOfNewBid &&
                _timeOfNewBid != 0
            ) {
                
                uint256 _rentDifference = rentOwedBetweenTimestamps(
                    user[_user].lastRentCalc,
                    _timeOfNewBid,
                    totalUserDailyRent
                );
                uint256 _depositAtTimeOfNewBid = 0;

                if (user[_user].lastRentCalc < _timeOfNewBid) {
                    
                    _depositAtTimeOfNewBid =
                        user[_user].deposit -
                        _rentDifference;
                } else {
                    
                    _depositAtTimeOfNewBid =
                        user[_user].deposit +
                        _rentDifference;
                }

                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *
                    1 days) / (totalUserDailyRent + _newBid);

                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +
                    _timeLeftOfDepositWithNewBid;
                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {
                    return _foreclosureTimeWithNewCard;
                } else {
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    return 0;
                }
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            if (_newBid == 0) {
                
                return type(uint256).max;
            } else {
                return
                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);
            }
        }
    }

    
    
    
    
    
    
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        require(_timeToCollectTo != 0, ""Must set collection time"");
        require(
            _timeToCollectTo <= block.timestamp,
            ""Can't collect future rent""
        );
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                
                uint256 timeUsersDepositLasts = ((_timeToCollectTo -
                    previousCollectionTime) * uint256(user[_user].deposit)) /
                    rentOwedByUser;
                
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }

    
    function assessForeclosure(address _user) public override {
        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        } else {
            isForeclosed[_user] = true;
            emit LogUserForeclosed(_user, true);
        }
    }

    
    function checkPermission(bytes32 role, address account)
        external
        view
        override
        returns (bool)
    {
        return AccessControl.hasRole(role, account);
    }

    function grantRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.grantRole(_role, account);
    }

    function grantRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            
            emit LogWhitelistUser(account, true);
        }
        AccessControl.grantRole(role, account);
    }

    function revokeRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.revokeRole(_role, account);
    }

    function revokeRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            
            emit LogWhitelistUser(account, false);
        }
        AccessControl.revokeRole(role, account);
    }

    
}",5177,1,2,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control and Role Management"",
      ""Tasks"": [
        ""Verify that only intended addresses/contracts are granted the UBER_OWNER, OWNER, GOVERNOR, FACTORY, MARKET, ORDERBOOK, WHITELIST, ARTIST, AFFILIATE and CARD_AFFILIATE roles during contract initialization and throughout its lifecycle."",
        ""Analyze the impact of granting and revoking roles on contract functionality and data integrity."",
        ""Confirm that the `_setRoleAdmin` calls establish the correct hierarchy and permissions for each role."",
        ""Examine the security implications of the `globalExit` function and verify that only the UBER_OWNER can execute it."",
        ""Investigate whether the `NativeMetaTransaction` implementation introduces any vulnerabilities related to role-based access control bypass.""
      ]
    },
    {
      ""Area"": ""Rent Calculation and Foreclosure Logic"",
      ""Tasks"": [
        ""Conduct thorough testing of the `rentOwedUser`, `rentOwedBetweenTimestamps`, and `foreclosureTimeUser` functions, paying close attention to edge cases such as zero rental rates, identical timestamps, and potential overflows/underflows."",
        ""Analyze the logic in `updateRentalRate` to ensure accurate rent calculations, especially when ownership changes occur rapidly in succession."",
        ""Simulate various scenarios to verify the correctness of the foreclosure mechanism and its impact on user deposits and the overall system."",
        ""Specifically test scenarios where _timeOwnershipChanged < user[_newOwner].lastRentCalc in `updateRentalRate` to ensure rent calculations are accurate."",
        ""Verify that division by (1 days) consistently produces expected results and explore alternate solutions to mitigate truncation-related rounding errors.""
      ]
    },
    {
      ""Area"": ""Deposit and Withdrawal Mechanisms"",
      ""Tasks"": [
        ""Assess the potential for manipulation or exploitation of the deposit and withdrawal functions, including reentrancy attacks or unauthorized access."",
        ""Examine the interaction between `deposit`, `withdrawDeposit`, `assessForeclosure`, and `orderbook.removeOldBids(_user)` to ensure consistent state updates."",
        ""Analyze the whitelisting mechanism to verify that only authorized users can deposit funds when enabled."",
        ""Confirm that the contract correctly handles scenarios where a user attempts to withdraw more than their available deposit."",
        ""Audit `withdrawDeposit` and the interaction with the `IRCBridge` contract to verify safe and secure withdrawals to mainnet. Ensure adequate error handling for bridge failures.""
      ]
    },
    {
      ""Area"": ""Market Balance and Payout Management"",
      ""Tasks"": [
        ""Investigate the flow of funds between the general `marketBalance` and individual `marketPot`s, paying attention to potential inconsistencies or vulnerabilities."",
        ""Verify that only authorized MARKET contracts can call the `payRent`, `payout`, `refundUser`, and `sponsor` functions."",
        ""Analyze the logic in `payRent` to ensure that funds are correctly transferred from `marketBalance` to the appropriate `marketPot` and that discrepancy scenarios are handled appropriately."",
        ""Examine the `refundUser` function to determine under which scenarios this function will be triggered and whether this operation is sourced from the general `marketBalance`."",
        ""Confirm proper authorization is required to call function `addMarket`.""
      ]
    },
    {
      ""Area"": ""Paused State Management"",
      ""Tasks"": [
        ""Verify that the `globalPause`, `marketPaused`, and `lockMarketPaused` mechanisms effectively prevent unauthorized access to critical functionalities."",
        ""Test the interaction between these pause states and other functions to ensure consistent behavior."",
        ""Analyze the potential for race conditions or other vulnerabilities related to pause state changes."",
        ""Confirm that only the OWNER role can pause a market via `changePauseMarket`."",
        ""Confirm that only the FACTORY role can unpause a market via `unPauseMarket`, *unless* the owner has `lockMarketPaused`.""
      ]
    },
    {
      ""Area"": ""Invariants and Overflow Protection"",
      ""Tasks"": [
        ""Thoroughly test the `balancedBooks` modifier to ensure that the contract's token balance always matches its liabilities."",
        ""Identify potential overflow/underflow vulnerabilities in arithmetic operations, especially related to rent calculations and deposit management."",
        ""Confirm that `SafeCast` is used appropriately throughout the code to prevent data truncation or loss of precision."",
        ""Address the warning that `mapping(address => bool) public override isAllowed` is unused. Remove dead code.""
      ]
    },
    {
      ""Area"": ""External Contract Interactions"",
      ""Tasks"": [
        ""Audit the interactions with the IERC20, IRCOrderbook, IRCMarket, IRCFactory, IRCBridge, and IRCLeaderboard contracts to ensure data integrity and prevent potential vulnerabilities."",
        ""Verify that the contract correctly handles unexpected responses or errors from external contracts."",
        ""Specifically analyze the Orderbook's role in providing rental and bid rates, including potential manipulation or data integrity risks."",
        ""Ensure that the IRCBridge interaction for withdrawals is secure and handles potential failures appropriately.""
      ]
    },
    {
      ""Area"": ""ERC20 Token and Bridge Considerations"",
      ""Tasks"": [
        ""Verify that the contract has sufficient allowance to transfer ERC20 tokens from users' accounts."",
        ""Assess the impact of ERC20 token decimal precision on rent calculations and deposit management."",
        ""Analyze the potential risks associated with using a bridge contract and ensure proper security measures are in place."",
        ""Ensure correct ERC20 approval is set for the Bridge contract in `setBridgeAddress`.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and address gas inefficiencies in the contract's code, such as redundant calculations or unnecessary storage operations."",
        ""Consider using more efficient data structures or algorithms to reduce gas costs."",
        ""Evaluate the potential benefits of using assembly code for gas-critical sections of the contract."",
         ""Remove `hardhat/console.sol` import for production.""
      ]
    },
    {
       ""Area"": ""Market Whitelist Logic"",
       ""Tasks"":[
          ""Clarify and confirm the intended operational flow of `marketWhitelist` and `marketWhitelistCheck`.  Ensure the market *itself* is able to define roles users must have to interact via that market."",
          ""Write test cases covering authorized and unauthorized access based on `marketWhitelistCheck` to verify its intended functionality.""
       ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""Initial review indicates a complex treasury contract managing user deposits, rent collection based on external market/orderbook interactions, and payouts. It employs robust access control, pausing mechanisms, and safety checks like balanced books."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""RCTreasury"",
    ""Purpose"": ""Acts as a central vault for user deposits (ERC20 tokens) within a larger system (likely related to Reality Cards). It manages funds associated with user participation (renting/bidding), collects rent based on rates determined externally (Orderbook), handles payouts directed by Market contracts, enforces whitelisting, provides pausing capabilities, and facilitates withdrawals, potentially via a bridge."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""@openzeppelin/contracts/access/AccessControl.sol"",
        ""./lib/NativeMetaTransaction.sol"",
        ""./interfaces/IRCTreasury.sol""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts/access/AccessControl.sol"",
        ""@openzeppelin/contracts/utils/math/SafeCast.sol"",
        ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"",
        ""hardhat/console.sol"",
        ""./lib/NativeMetaTransaction.sol"",
        ""./interfaces/IRCTreasury.sol"",
        ""./interfaces/IRCMarket.sol"",
        ""./interfaces/IRCOrderbook.sol"",
        ""./interfaces/IRCNftHubL2.sol"",
        ""./interfaces/IRCFactory.sol"",
        ""./interfaces/IRCBridge.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""orderbook"",
        ""Type"": ""IRCOrderbook"",
        ""Purpose"": ""Reference to the Orderbook contract, which dictates rental/bid rates.""
      },
      {
        ""Name"": ""leaderboard"",
        ""Type"": ""IRCLeaderboard"",
        ""Purpose"": ""Reference to the Leaderboard contract (address set, but not directly used).""
      },
      {
        ""Name"": ""erc20"",
        ""Type"": ""IERC20"",
        ""Purpose"": ""The ERC20 token used for deposits, rent, and payouts.""
      },
      {
        ""Name"": ""bridgeAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the bridge contract for L2->L1 withdrawals.""
      },
      {
        ""Name"": ""factory"",
        ""Type"": ""IRCFactory"",
        ""Purpose"": ""Reference to the Factory contract that creates Markets.""
      },
      {
        ""Name"": ""totalDeposits"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Sum of all active user deposits held by the Treasury.""
      },
      {
        ""Name"": ""marketPot"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks funds accumulated by each specific Market contract from rent/sponsorships, available for payout.""
      },
      {
        ""Name"": ""totalMarketPots"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Sum of all funds held in individual market pots.""
      },
      {
        ""Name"": ""marketBalance"",
        ""Type"": ""uint256"",
        ""Purpose"": ""General pool of funds collected from user rent, potentially available to be moved to market pots.""
      },
      {
        ""Name"": ""isForeclosed"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks if a user's deposit is too low to cover potential rent/bids, triggering foreclosure.""
      },
      {
        ""Name"": ""marketBalanceTopup"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Tracks funds explicitly added via `topupMarketBalance`, potentially buffering the `marketBalance`.""
      },
      {
        ""Name"": ""user"",
        ""Type"": ""mapping(address => User)"",
        ""Purpose"": ""Stores data for each user, including deposit, rental/bid rates, and rent calculation timestamps.""
      },
      {
        ""Name"": ""User (struct)"",
        ""Type"": ""struct"",
        ""Purpose"": ""Contains user-specific state: deposit, rentalRate, bidRate, lastRentCalc timestamp, lastRentalTime timestamp.""
      },
      {
        ""Name"": ""minRentalDayDivisor"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Divisor used to calculate minimum rental periods or deposit requirements (e.g., 24*6 suggests 1/6th of a day).""
      },
      {
        ""Name"": ""maxContractBalance"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Maximum total ERC20 balance allowed in the contract.""
      },
      {
        ""Name"": ""isAllowed"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Declared but appears unused; whitelisting uses AccessControl roles.""
      },
      {
        ""Name"": ""whitelistEnabled"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to enable/disable deposit whitelisting requirement.""
      },
      {
        ""Name"": ""marketWhitelist"",
        ""Type"": ""mapping(address => bytes32)"",
        ""Purpose"": ""Maps market addresses to specific roles required for users interacting with that market (checked via `marketWhitelistCheck`).""
      },
      {
        ""Name"": ""globalPause"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to pause major functions like deposits, withdrawals, rent, payouts globally.""
      },
      {
        ""Name"": ""marketPaused"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks if interactions related to a specific market are paused.""
      },
      {
        ""Name"": ""lockMarketPaused"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Prevents Factory from unpausing a market if the Owner paused it.""
      },
      {
        ""Name"": ""Role Constants"",
        ""Type"": ""bytes32"",
        ""Purpose"": ""Constants defining roles used in AccessControl (UBER_OWNER, OWNER, GOVERNOR, etc.).""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes EIP-712, sets up extensive role hierarchy, sets initial config values, and enables whitelist."",
        ""Parameters"": [""address _tokenAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""balancedBooks"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Modifier ensuring the contract's token balance covers its liabilities (deposits + market balance + market pots)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setMinRental"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the minimum rental day divisor (OWNER role)."",
        ""Parameters"": [""uint256 _newDivisor""],
        ""Returns"": []
      },
      {
        ""Name"": ""setMaxContractBalance"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the maximum token balance limit for the contract (OWNER role)."",
        ""Parameters"": [""uint256 _newBalanceLimit""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeGlobalPause"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Toggles the global pause flag (OWNER role)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""changePauseMarket"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Pauses/unpauses a specific market and locks the state (OWNER role)."",
        ""Parameters"": [""address _market"", ""bool _paused""],
        ""Returns"": []
      },
      {
        ""Name"": ""unPauseMarket"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Unpauses a market if not locked by the owner (FACTORY role)."",
        ""Parameters"": [""address _market""],
        ""Returns"": []
      },
      {
        ""Name"": ""toggleWhitelist"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Enables/disables the deposit whitelist requirement (OWNER role)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""batchWhitelist"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds or removes the WHITELIST role for multiple users (GOVERNOR role)."",
        ""Parameters"": [""address[] calldata _users"", ""bool add""],
        ""Returns"": []
      },
      {
        ""Name"": ""marketWhitelistCheck"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Checks if a user has the specific role required by the calling market (if any)."",
        ""Parameters"": [""address _user""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""setFactoryAddress"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the Factory address and associated roles (UBER_OWNER role)."",
        ""Parameters"": [""address _newFactory""],
        ""Returns"": []
      },
      {
        ""Name"": ""setOrderbookAddress"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the Orderbook address and associated roles (UBER_OWNER role)."",
        ""Parameters"": [""address _newOrderbook""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLeaderboardAddress"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the Leaderboard address (UBER_OWNER role)."",
        ""Parameters"": [""address _newLeaderboard""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTokenAddress"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the ERC20 token address (UBER_OWNER role)."",
        ""Parameters"": [""address _newToken""],
        ""Returns"": []
      },
      {
        ""Name"": ""setBridgeAddress"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the Bridge address and approves max tokens (UBER_OWNER role)."",
        ""Parameters"": [""address _newBridge""],
        ""Returns"": []
      },
      {
        ""Name"": ""globalExit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Emergency function to withdraw all contract funds to the caller (UBER_OWNER role)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""deposit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user (via msg.sender approval) to deposit tokens for a beneficiary user."",
        ""Parameters"": [""uint256 _amount"", ""address _user""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""withdrawDeposit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to withdraw their available deposit, either locally or via the bridge."",
        ""Parameters"": [""uint256 _amount"", ""bool _localWithdrawal""],
        ""Returns"": []
      },
      {
        ""Name"": ""topupMarketBalance"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows anyone to add funds directly to the general market balance buffer."",
        ""Parameters"": [""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""checkSponsorship"",
        ""Visibility"": ""external"",
        ""Purpose"": ""View function to check if a potential sponsor has sufficient balance and allowance."",
        ""Parameters"": [""address sender"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""payRent"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by a Market to move collected rent from the general market balance to its specific market pot."",
        ""Parameters"": [""uint256 _amount""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""payout"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by a Market to transfer funds from its market pot to a user's deposit."",
        ""Parameters"": [""address _user"", ""uint256 _amount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""refundUser"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by a Market to refund a user from the general market balance back to their deposit."",
        ""Parameters"": [""address _user"", ""uint256 _refund""],
        ""Returns"": []
      },
      {
        ""Name"": ""sponsor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by a Market to transfer funds from an approved sponsor directly into the Market's pot."",
        ""Parameters"": [""address _sponsor"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateLastRentalTime"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by a Market to update timestamps related to a user's rental activity."",
        ""Parameters"": [""address _user""],
        ""Returns"": []
      },
      {
        ""Name"": ""addMarket"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by the Factory to grant the MARKET role to a new market contract."",
        ""Parameters"": [""address _market"", ""bool _paused""],
        ""Returns"": []
      },
      {
        ""Name"": ""userTotalBids"",
        ""Visibility"": ""external"",
        ""Purpose"": ""View function to get a user's total bid rate."",
        ""Parameters"": [""address _user""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""userDeposit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""View function to get a user's current deposit."",
        ""Parameters"": [""address _user""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""updateRentalRate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by the Orderbook to update user rental rates upon ownership changes, potentially collecting interim rent."",
        ""Parameters"": [""address _oldOwner"", ""address _newOwner"", ""uint256 _oldPrice"", ""uint256 _newPrice"", ""uint256 _timeOwnershipChanged""],
        ""Returns"": []
      },
      {
        ""Name"": ""increaseBidRate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by the Orderbook to increase a user's total bid rate."",
        ""Parameters"": [""address _user"", ""uint256 _price""],
        ""Returns"": []
      },
      {
        ""Name"": ""decreaseBidRate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by the Orderbook to decrease a user's total bid rate."",
        ""Parameters"": [""address _user"", ""uint256 _price""],
        ""Returns"": []
      },
      {
        ""Name"": ""rentOwedUser"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates rent owed by a user since their last calculation time."",
        ""Parameters"": [""address _user"", ""uint256 _timeOfCollection""],
        ""Returns"": [""uint256 rentDue""]
      },
      {
        ""Name"": ""rentOwedBetweenTimestamps"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates rent owed for a given rate between two timestamps."",
        ""Parameters"": [""uint256 _time1"", ""uint256 _time2"", ""uint256 _price""],
        ""Returns"": [""uint256 _rent""]
      },
      {
        ""Name"": ""foreclosureTimeUser"",
        ""Visibility"": ""external"",
        ""Purpose"": ""View function to estimate the timestamp when a user will be foreclosed based on current rates and an optional new bid."",
        ""Parameters"": [""address _user"", ""uint256 _newBid"", ""uint256 _timeOfNewBid""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""collectRentUser"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates and collects rent owed by a user up to a specific time, deducting from their deposit and potentially triggering foreclosure."",
        ""Parameters"": [""address _user"", ""uint256 _timeToCollectTo""],
        ""Returns"": [""uint256 newTimeLastCollectedOnForeclosure""]
      },
      {
        ""Name"": ""_increaseMarketBalance"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Helper function to decrease user deposit/total deposits and increase the general market balance during rent collection."",
        ""Parameters"": [""uint256 rentCollected"", ""address _user""],
        ""Returns"": []
      },
      {
        ""Name"": ""assessForeclosure"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the user's foreclosure status based on their deposit vs. minimum required based on bid rate."",
        ""Parameters"": [""address _user""],
        ""Returns"": []
      },
      {
        ""Name"": ""checkPermission"",
        ""Visibility"": ""external"",
        ""Purpose"": ""View function to check if an account has a specific role."",
        ""Parameters"": [""bytes32 role"", ""address account""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""grantRole"",
        ""Visibility"": ""external/public"",
        ""Purpose"": ""Grants a specified role to an account (implements/overrides AccessControl)."",
        ""Parameters"": [""string memory role / bytes32 role"", ""address account""],
        ""Returns"": []
      },
      {
        ""Name"": ""revokeRole"",
        ""Visibility"": ""external/public"",
        ""Purpose"": ""Revokes a specified role from an account (implements/overrides AccessControl)."",
        ""Parameters"": [""string memory role / bytes32 role"", ""address account""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20: Interacts heavily for deposits (`safeTransferFrom`), withdrawals (`safeTransfer`), bridging (`approve`, `safeTransfer`), checking balances (`balanceOf`) and allowances (`allowance`)."",
    ""IRCOrderbook: Receives calls to update user rates (`updateRentalRate`, `increaseBidRate`, `decreaseBidRate`). Calls Orderbook to remove bids/users (`removeOldBids`, `removeUserFromOrderbook`)."",
    ""IRCMarket: Market contracts call Treasury to manage funds (`payRent`, `payout`, `refundUser`, `sponsor`) and update user state (`updateLastRentalTime`)."",
    ""IRCFactory: Factory calls Treasury to manage market roles/pausing (`addMarket`, `unPauseMarket`)."",
    ""IRCBridge: Called for cross-chain withdrawals (`withdrawToMainnet`)."",
    ""NativeMetaTransaction (Inherited): Enables EIP-712 meta-transactions, allowing `_msgSender()` to potentially differ from `msg.sender`.""
  ],
  ""SpecialMechanisms"": [
    ""Role-Based Access Control: Utilizes OpenZeppelin AccessControl with a multi-level role hierarchy (UBER_OWNER, OWNER, GOVERNOR, FACTORY, MARKET, ORDERBOOK, WHITELIST, etc.)."",
    ""Rent Calculation & Collection: Core logic involving `rentalRate`, `lastRentCalc`, `block.timestamp` to determine rent owed per user, deducted from deposits."",
    ""Foreclosure Mechanism: Users whose deposits fall below a threshold (related to `bidRate` and `minRentalDayDivisor`) are marked `isForeclosed`, potentially triggering actions in the Orderbook."",
    ""Balanced Books Invariant: `balancedBooks` modifier ensures contract solvency before critical state changes."",
    ""Pause Functionality: Global and per-market pausing controlled by Owner/Factory."",
    ""Whitelisting: Optional deposit restriction based on `WHITELIST` role."",
    ""Meta-transactions: Support for gasless transactions via EIP-712."",
    ""Bridging Integration: Built-in support for withdrawing funds to another chain via a specified Bridge contract."",
    ""Market Pots vs. General Balance: Segregates funds collected generally (`marketBalance`) from funds allocated to specific markets (`marketPot`).""
  ],
  ""Questions"": [
    ""What is the precise lifecycle of funds? Rent is collected into `marketBalance`. How does it move to `marketPot` (only via `payRent` called by Market)? Is `marketBalance` intended to be a buffer?"",
    ""The `balancedBooks` check is crucial. Are there potential precision issues or edge cases (e.g., division rounding in rent calculation) that could lead to it failing incorrectly or funds being trapped?"",
    ""The `foreclosureTimeUser` calculation is complex. Has it undergone rigorous testing for edge cases (zero rates, timestamps equality, potential overflows)? Why return 0 if the calculated time is before `lastRentCalc`?"",
    ""In `updateRentalRate`, the logic for handling `_timeOwnershipChanged` relative to `lastRentCalc` needs careful review. Could rapid successive calls lead to incorrect rent calculations?"",
    ""What scenarios trigger `refundUser`? Why is the refund sourced from the general `marketBalance`?"",
    ""What does the foreclosure threshold `user[_user].bidRate / minRentalDayDivisor` represent conceptually? Is it the minimum deposit needed to sustain *bids* for the minimum rental period?"",
    ""The state variable `mapping(address => bool) public override isAllowed` is declared but never appears to be written to or read. Is this dead code?"",
    ""`hardhat/console.sol` import should be removed for production deployment."",
    ""The `globalExit` function provides immense power to UBER_OWNER. What are the safeguards against misuse?"",
    ""Confirm the intended interaction flow for `marketWhitelist` and `marketWhitelistCheck`. Is it intended that a market *itself* defines a role users must have to interact via that market?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Risk in `deposit` and `withdrawDeposit`"",
      ""Severity"": ""High"",
      ""Description"": ""The `deposit` and `withdrawDeposit` functions perform external calls (ERC20 transfers via `safeTransferFrom`/`safeTransfer` or calls to `bridge.withdrawToMainnet`) before fully updating the user's state (like `user[_msgSender].deposit` and `totalDeposits`). If the ERC20 token contract or the bridge contract has a malicious callback or reentrancy vulnerability, an attacker could re-enter the treasury contract mid-execution. This could allow them to withdraw more funds than entitled or manipulate the contract state before the initial transaction completes. While SafeERC20 is used, it doesn't prevent reentrancy through external calls."",
      ""Impact"": ""Potential theft of funds from the treasury, incorrect state updates, and draining of contract balances."",
      ""Location"": ""RCTreasury.sol: withdrawDeposit, deposit functions (multiple lines including approx. 272-281, 309-334, 400, 445-476, 504, 509, 579)""
    },
    {
      ""Issue"": ""Insufficient Access Control and Validation on `addMarket` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `addMarket` function only checks if the caller has the `FACTORY` role but fails to validate that the provided `_market` address corresponds to a legitimate, deployed market contract conforming to the expected interface. A compromised or malicious Factory contract could abuse this by adding arbitrary addresses (including EOAs or malicious contracts) as markets, granting them the `MARKET` role. This bypasses the intended system design where only valid markets interact with the treasury."",
      ""Impact"": ""Malicious or invalid addresses can be granted the `MARKET` role, potentially leading to unauthorized fund manipulation (rent payments, payouts), draining treasury funds, disrupting the orderbook/leaderboard, causing unexpected behavior, or denial of service."",
      ""Location"": ""RCTreasury.sol: addMarket function (multiple lines including approx. 436-449, 497, 594, 684, 689)""
    },
    {
      ""Issue"": ""Flawed Foreclosure Logic and Time Calculations"",
      ""Severity"": ""High"",
      ""Description"": ""The logic within `foreclosureTimeUser` and `assessForeclosure` for calculating foreclosure times and assessing foreclosure status contains several potential flaws. Issues include: incorrect comparison logic (e.g., involving `_timeOfNewBid`), potentially confusing return values for different scenarios (no bids vs. active bids), lack of validation for input timestamps (`_timeOfNewBid`, stored `lastRentCalc`), potential precision loss due to integer division (e.g., `timeLeftOfDeposit`), and edge cases where the calculation `user[_user].bidRate / minRentalDayDivisor` could become zero if `minRentalDayDivisor` is very large, incorrectly preventing foreclosure for users with small positive deposits."",
      ""Impact"": ""Incorrect foreclosure time calculations leading to premature or delayed foreclosures, potentially causing financial losses for users or the protocol. Users might evade legitimate foreclosure."",
      ""Location"": ""RCTreasury.sol: foreclosureTimeUser, assessForeclosure functions (multiple lines including approx. 552-555, 609-704, 746-751, 856)""
    },
    {
      ""Issue"": ""Unbounded Loop in `batchWhitelist` Function Can Lead to Gas Exhaustion"",
      ""Severity"": ""High"",
      ""Description"": ""The `batchWhitelist` function iterates through the `_users` array provided as input to grant or revoke the `WHITELIST` role. There is no check on the size of this array. If a malicious actor or compromised governor provides a very large array, the gas required for the loop could exceed the block gas limit, causing the transaction to revert."",
      ""Impact"": ""Denial of Service (DoS). Prevents legitimate batch whitelisting or de-whitelisting operations, hindering user management. A malicious actor could grief the contract owner by repeatedly submitting large arrays."",
      ""Location"": ""RCTreasury.sol: batchWhitelist function (multiple lines including approx. 178-193, 189-203, 198-212, 199-213, 228-240, 330, 360)""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Rent Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Rent calculation functions like `rentOwedBetweenTimestamps` and `rentOwedUser` involve arithmetic operations (multiplication, subtraction, division) on `uint256` values representing time differences and prices/rates. While Solidity 0.8+ provides default overflow/underflow checks for basic operations, complex calculations involving large time differences (`_time1 - _time2` or `_timeOfCollection - user[_user].lastRentCalc`) multiplied by large prices/rates (`_price` or `rentalRate`) could potentially lead to intermediate values exceeding `uint256.max` before division, resulting in wraparound or incorrect results despite final division. The swapping logic for timestamps in `rentOwedBetweenTimestamps` doesn't prevent potential overflow in the multiplication step."",
      ""Impact"": ""Incorrect rent calculations, leading to users being overcharged or undercharged, financial discrepancies, potential fund loss, incorrect user balances, and unfair foreclosures."",
      ""Location"": ""RCTreasury.sol: rentOwedBetweenTimestamps, rentOwedUser functions (multiple lines including approx. 456-493, 512-517, 529-553, 530-536, 538-546, 589-601, 634-637, 656-663, 693, 714, 719, 737)""
    },
    {
      ""Issue"": ""Lack of Input Validation and Sanity Checks on Critical Parameters and Inputs"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions lack sufficient input validation: 1) Admin functions (`setMinRental`, `setMaxContractBalance`) don't check for reasonable bounds (e.g., `minRentalDayDivisor > 0`). Setting `minRentalDayDivisor` to 0 causes division-by-zero errors. 2) Setter functions (`setFactoryAddress`, `setOrderbookAddress`, `setLeaderboardAddress`, `setTokenAddress`, `setBridgeAddress`) lack checks to verify if the provided address implements the expected interface, allowing potentially incompatible or malicious contracts to be set. 3) Functions like `payout`, `refundUser`, `sponsor` lack zero-address checks for `_user` or `_sponsor`. 4) Market interaction functions (`payRent`, `payout`, `sponsor`) lack sanity checks on the `_amount` parameter provided by the `MARKET` role caller. 5) `collectRentUser` lacks validation against excessively old `_timeToCollectTo` timestamps."",
      ""Impact"": ""Potential for division-by-zero errors, contract breakage due to incompatible dependencies, unexpected behavior, resource exhaustion, griefing, transaction failures, financial discrepancies from malicious market inputs, and errors from invalid timestamps."",
      ""Location"": ""RCTreasury.sol: setMinRental, setMaxContractBalance, setFactoryAddress, setOrderbookAddress, setLeaderboardAddress, setTokenAddress, setBridgeAddress, payout, refundUser, sponsor, payRent, collectRentUser functions (multiple lines including approx. 140-156, 161-175, 238, 254, 260, 266, 267-285, 404, 423, 437, 449, 459, 609, 639, 656, 672, 811)""
    },
    {
      ""Issue"": ""Front-Running / Race Condition Vulnerabilities"",
      ""Severity"": ""Medium"",
      ""Description"": ""Potential front-running exists: 1) In `withdrawDeposit`, an attacker observing a pending withdrawal in the mempool could manipulate market conditions (e.g., increase the user's bid rate) before the withdrawal executes, potentially causing the user to be unexpectedly foreclosed. 2) In `deposit`, checks for ERC20 allowance and `maxContractBalance` occur before the `safeTransferFrom` call and other operations (like `orderbook.removeOldBids`). An attacker could front-run the deposit, reducing the user's allowance or filling the contract capacity between the check and the transfer, causing the legitimate deposit to fail."",
      ""Impact"": ""Unexpected user foreclosure, potential loss of funds for users, transaction failures for valid deposits, denial of service for specific users."",
      ""Location"": ""RCTreasury.sol: withdrawDeposit, deposit functions (multiple lines including approx. 281-335, 406-425, 524, 575)""
    },
    {
      ""Issue"": ""Potential Manipulation/Griefing via Timestamps and Rates"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies on externally provided or stored time-related values for critical calculations. The `updateRentalRate` function accepts `_timeOwnershipChanged` from the caller (likely Orderbook), which could be manipulated to cause incorrect rent calculations. Similarly, the `collectRentUser` function uses `user[_user].lastRentCalc`, which, if susceptible to manipulation through another vulnerability, could be set far in the past, inflating rent owed and potentially forcing unfair foreclosures or causing DoS."",
      ""Impact"": ""Incorrect rent calculation, potential loss of funds, unexpected foreclosures, griefing attacks, denial of service targeting specific users."",
      ""Location"": ""RCTreasury.sol: updateRentalRate, collectRentUser functions (multiple lines including approx. 456-493, 617, 621-670)""
    },
    {
      ""Issue"": ""Unsafe Casting to `uint128` May Hinder Functionality"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract frequently uses `SafeCast.toUint128` to cast `uint256` values (often related to deposits, amounts, or rates) to `uint128`. While SafeCast prevents overflow/truncation errors by reverting, if legitimate values in the system (e.g., large deposits, high cumulative rental rates) naturally exceed the maximum value representable by `uint128`, these transactions will consistently revert."",
      ""Impact"": ""Users may be unable to deposit, withdraw, pay rent, or interact with other core functions if the amounts involved exceed the `uint128` limit, severely limiting the contract's usability for large values."",
      ""Location"": ""RCTreasury.sol: Multiple functions including deposit, withdrawDeposit, payRent, payout, refundUser, updateRentalRate (approx. 333, 369, 402, 418, 501, 585, 586, 596, 684, 693)""
    },
    {
      ""Issue"": ""Insufficient Market Pause Protection Logic"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract features `globalPause` (Owner) and `marketPaused` (Owner/Factory). While `lockMarketPaused` aims to prevent the Factory from unpausing a market paused by the Owner, the implementation detail where `lockMarketPaused` is set equal to `marketPaused` within `changePauseMarket` might inadvertently allow the Factory to call `unPauseMarket` right after the Owner pauses it, potentially overriding the Owner's action."",
      ""Impact"": ""The Factory role might be able to override the Owner's decision to pause a market, potentially allowing unintended market activity or manipulation."",
      ""Location"": ""RCTreasury.sol: changePauseMarket, unPauseMarket functions (approx. 208-221)""
    },
    {
      ""Issue"": ""Centralization Risk via Owner Control of Critical Parameters"",
      ""Severity"": ""Medium"",
      ""Description"": ""Key operational parameters of the treasury, such as `minRentalDayDivisor` and `maxContractBalance`, are controlled exclusively by the `OWNER` role. While owner control is common for configuration, this level of control over parameters directly affecting rent calculation frequency and deposit limits poses a centralization risk."",
      ""Impact"": ""A malicious or compromised owner could manipulate these parameters to disrupt contract functionality, increase costs for users, block deposits, or otherwise negatively impact the system and user funds."",
      ""Location"": ""RCTreasury.sol: setMinRental, setMaxContractBalance functions (approx. 138-152)""
    },
    {
      ""Issue"": ""Information Leakage and Whitelist Bypass Concerns"",
      ""Severity"": ""Medium"",
      ""Description"": ""1) The `marketWhitelistCheck` function is `external view` with no access control, allowing anyone to query the whitelist status of any user for any market, potentially leaking information useful to attackers. 2) The `deposit` function contains logic allowing the treasury contract itself (`address(this)`) to bypass the `whitelistEnabled` check. If an attacker gains control over the treasury contract through another exploit, this could facilitate unauthorized actions."",
      ""Impact"": ""Information leakage about user roles. Potential for whitelist bypass and unauthorized deposits/actions if contract control is compromised."",
      ""Location"": ""RCTreasury.sol: marketWhitelistCheck, deposit functions (approx. 219-230, 447)""
    },
    {
      ""Issue"": ""Inconsistent Role Management and Access Control Implementation"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract exhibits inconsistencies in handling access control and roles: 1) Mixes usage of `onlyRole` modifiers and direct `AccessControl.hasRole` checks. 2) `grantRole` emits `LogWhitelistUser` only for the `WHITELIST` role, but `revokeRole` emits it regardless of the role. 3) Setter functions (`setFactoryAddress`, etc.) perform potentially redundant/excessive role revocations and grants (e.g., granting OWNER/GOVERNOR to Factory) and use internal `RCTreasury.grant/revokeRole` wrappers instead of `AccessControl` directly. 4) Mixes string-based roles and bytes32 constants. 5) `unPauseMarket` may have insufficient role checks (only checks FACTORY)."",
      ""Impact"": ""Increased code complexity, reduced readability, potential for confusion and human error in managing roles, making audits harder. Specific functions might have slightly incorrect access control logic (e.g., market pausing)."",
      ""Location"": ""RCTreasury.sol: Multiple locations including Access Control setup, role constants, grantRole, revokeRole, addMarket, setFactoryAddress, setOrderbookAddress, setLeaderboardAddress, unPauseMarket (approx. 82-90, 171, 238-246, 301-307, 748-833)""
    },
    {
      ""Issue"": ""Gas Inefficiency and Redundant Operations"",
      ""Severity"": ""Low"",
      ""Description"": ""Several areas contain potential gas inefficiencies: 1) The `deposit` function includes a check `(erc20.balanceOf(address(this)) + _amount) <= maxContractBalance` which might be redundant if `safeTransferFrom` implicitly handles balance limits or if the check is unlikely to fail when allowance/transfer succeeds. 2) Functions like `deposit`, `withdrawDeposit`, `payout`, and `refundUser` call `assessForeclosure`, which performs storage writes. Multiple calls within the same transaction for the same user could consume significant gas. 3) Both `deposit` and `withdrawDeposit` call `orderbook.removeOldBids`, which might be redundant or slightly inefficient if called close together for the same user."",
      ""Impact"": ""Increased gas costs for users interacting with the contract. In the case of repeated `assessForeclosure` calls, potential for targeted DoS by making interactions for a specific user prohibitively expensive."",
      ""Location"": ""RCTreasury.sol: deposit, withdrawDeposit, payout, refundUser functions (approx. 252-255, 524, 575)""
    },
    {
      ""Issue"": ""Unlimited ERC20 Approval to Bridge Address"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setBridgeAddress` function grants an unlimited (`type(uint256).max`) ERC20 allowance for the contract's token to the new bridge address. This is a common pattern but poses a security risk: if the bridge contract is compromised or contains a vulnerability, an attacker could potentially drain the entire balance of the approved ERC20 token from the treasury."",
      ""Impact"": ""Potential loss of all treasury funds for the specific ERC20 token if the bridge address is compromised or exploited."",
      ""Location"": ""RCTreasury.sol: setBridgeAddress function (approx. 270-273, 332)""
    },
    {
      ""Issue"": ""Use of `assert` in Production Code"",
      ""Severity"": ""Low"",
      ""Description"": ""The code includes an `assert` statement (`assert(user[_user].deposit == 0);`) within the `collectRentUser` function. `assert` is typically used for checking internal invariants during development. In production, if an assert condition fails (which might happen due to unexpected states or bugs), the transaction reverts and consumes all remaining gas, which can be user-unfriendly and make debugging difficult."",
      ""Impact"": ""Unexpected transaction reversions consuming all gas, potentially hindering contract operation or user interaction under unforeseen circumstances."",
      ""Location"": ""RCTreasury.sol: collectRentUser function""
    }
  ],
  ""IssueNumber"": 79,
  ""OutputList"": 16
}",393.0648708343506,4245.0,39.0,"### **[H-02] UberOwner has too much power**

**Report Description**:  
The `Uber_Owner` has excessive control over the system, making the protocol resemble a centralized prediction market where the rules are determined by the Uber Owner. The Uber Owner can completely alter the system's functionality, going beyond simple parameter adjustments like setting constants and fees. This centralization poses a significant risk if the Uber Owner's address is compromised. The recommendation is to limit the Uber Owner's permissions to a more manageable and trustable level. If contract upgrades are necessary, they should be implemented through a proxy in a standardized manner.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of excessive centralization or the risks associated with the Uber Owner's permissions. This is a critical oversight, as centralization risks are a significant security concern in smart contract design. The response list focuses on other vulnerabilities but misses this key issue entirely.

---

### **[M-01] Uninitialized Variable `marketWhitelist` in `RCTreasury.sol`**

**Report Description**:  
The variable `marketWhitelist` in `RCTreasury.sol` is never initialized, causing the function `marketWhitelistCheck()` to always return `true`. This behavior undermines the intended functionality of restricting certain markets to specific whitelists. The issue is present in the function `RCTreasury.marketWhitelistCheck()` and is called in `RCMarket.newRental()`. The recommendation is to ensure this behavior is intentional or to add a function that allows market creators to restrict their markets to specific roles by whitelisting users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of the uninitialized `marketWhitelist` variable or its impact on the whitelist functionality. This is a significant oversight, as uninitialized variables can lead to unintended behavior and security vulnerabilities.

---

### **[M-03] Deposits don't work with fee-on-transfer tokens**

**Report Description**:  
The `RCTreasury.deposit()` function does not account for fee-on-transfer tokens, which charge a fee on every `transfer()` or `transferFrom()`. As a result, the function credits more deposits than the contract actually receives, leading to discrepancies in user balances. This issue is particularly relevant for deflationary tokens or rebasing tokens like Aave's aTokens, where the balance changes over time.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of fee-on-transfer tokens or the potential for balance discrepancies. This is a significant oversight, as fee-on-transfer tokens are a common edge case in ERC20 token interactions and can lead to financial discrepancies if not handled properly.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-02] UberOwner has too much power**  
- **[M-01] Uninitialized Variable `marketWhitelist` in `RCTreasury.sol`**  
- **[M-03] Deposits don't work with fee-on-transfer tokens**

---

### **Conclusion**  
The response list fails to address any of the issues raised in the issue report. This indicates a significant gap in the coverage of vulnerabilities, particularly concerning centralization risks, uninitialized variables, and fee-on-transfer token handling. These issues are critical to the security and functionality of the smart contract and should be addressed in future responses.","```
None.
```",0.0
RCFactory.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRealitio.sol"";

/// @title Reality Cards Factory
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCFactory is NativeMetaTransaction, IRCFactory {
    /*╔═════════════════════════════════╗
      ║           VARIABLES             ║
      ╚═════════════════════════════════╝*/

    /////// CONTRACT VARIABLES ///////
    IRCTreasury public override treasury;
    IRCNftHubL2 public override nfthub;
    IRCOrderbook public override orderbook;
    IRCLeaderboard public override leaderboard;
    IRealitio public override realitio;
    /// @dev reference contract
    address public override referenceContractAddress;
    /// @dev increments each time a new reference contract is added
    uint256 public override referenceContractVersion;
    /// @dev market addresses, mode // address
    /// @dev these are not used for anything, just an easy way to get markets
    mapping(IRCMarket.Mode => address[]) public marketAddresses;

    ////// BACKUP MODE //////
    /// @dev should the Graph fail the UI needs a way to poll the contracts for market data
    /// @dev the IPFS hash for each market
    mapping(address => string) public override ipfsHash;
    /// @dev the slug each market is hosted at
    mapping(string => address) public override slugToAddress;
    mapping(address => string) public override addressToSlug;
    /// @dev the number of results to return in the backup view function
    uint256 public override marketInfoResults;

    ///// GOVERNANCE VARIABLES- OWNER /////
    /// @dev artist / winner / market creator / affiliate / card affiliate
    uint256[5] public potDistribution;
    /// @dev minimum tokens that must be sent when creating market which forms initial pot
    uint256 public override sponsorshipRequired;
    /// @dev adjust required price increase (in %)
    uint256 public override minimumPriceIncreasePercent;
    /// @dev The number of users that are allowed to mint an NFT
    uint256 public override nftsToAward;
    /// @dev market opening time must be at least this many seconds in the future
    uint32 public override advancedWarning;
    /// @dev market closing time must be no more than this many seconds in the future
    uint32 public override maximumDuration;
    /// @dev market closing time must be at least this many seconds after opening
    uint32 public override minimumDuration;
    /// @dev if false, anyone can create markets
    bool public override marketCreationGovernorsOnly = true;
    /// @dev if false, anyone can be an affiliate
    bool public override approvedAffiliatesOnly = true;
    /// @dev if false, anyone can be an artist
    bool public override approvedArtistsOnly = true;
    /// @dev the maximum number of rent collections to perform in a single transaction
    uint256 public override maxRentIterations;
    /// @dev the maximum number of rent collections to have performed before locking the market
    uint256 public override maxRentIterationsToLockMarket;
    /// @dev the address of the arbitrator
    address public override arbitrator;
    /// @dev the time allowed to dispute the oracle answer
    uint32 public override timeout;
    /// @dev if true markets default to the paused state
    bool public override marketPausedDefaultState;
    /// @dev a limit to the number of NFTs to mint per market
    uint256 public override cardLimit;

    ///// GOVERNANCE VARIABLES- GOVERNORS /////
    /// @dev unapproved markets hidden from the interface
    mapping(address => bool) public override isMarketApproved;

    ///// OTHER /////
    uint256 public constant PER_MILLE = 1000; // in MegaBip so (1000 = 100%)
    /// @dev store the tokenURIs for when we need to mint them
    /// @dev we may want the original and the copies to have slightly different metadata
    /// @dev so we append the metadata for the copies to the end of this array
    mapping(address => mapping(uint256 => string)) tokenURIs;

    /*╔═════════════════════════════════╗
      ║          Access Control         ║
      ╚═════════════════════════════════╝*/
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");

    /*╔═════════════════════════════════╗
      ║            EVENTS               ║
      ╚═════════════════════════════════╝*/

    event LogMarketCreated1(
        address contractAddress,
        address treasuryAddress,
        address nftHubAddress,
        uint256 referenceContractVersion
    );
    event LogMarketCreated2(
        address contractAddress,
        IRCMarket.Mode mode,
        string[] tokenURIs,
        string ipfsHash,
        uint32[] timestamps,
        uint256 totalNftMintCount
    );
    event LogMarketApproved(address market, bool approved);
    event LogMarketTimeRestrictions(
        uint256 _newAdvancedWarning,
        uint256 _newMinimumDuration,
        uint256 _newMaximumDuration
    );
    event LogMintNFTCopy(
        uint256 _originalTokenId,
        address _newOwner,
        uint256 _newTokenId
    );
    event LogMintNFT(uint256 _cardId, address _market, uint256 _tokenId);

    /*╔═════════════════════════════════╗
      ║          CONSTRUCTOR            ║
      ╚═════════════════════════════════╝*/

    constructor(
        IRCTreasury _treasury,
        address _realitioAddress,
        address _arbitratorAddress
    ) {
        require(address(_treasury) != address(0), ""Must set Address"");
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsFactory"", ""1"");

        // store contract instances
        treasury = _treasury;

        // initialise adjustable parameters
        // artist // winner // creator // affiliate // card affiliates
        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate
        setMinimumPriceIncreasePercent(10); // 10%
        setNumberOfNFTsToAward(3);
        setCardLimit(100); // safe limit tested and set at 100, can be adjusted later if gas limit changes
        setMaxRentIterations(50, 25); // safe limit tested and set at 50 & 25, can be adjusted later if gas limit changes
        // oracle
        setArbitrator(_arbitratorAddress);
        setRealitioAddress(_realitioAddress);
        setTimeout(86400); // 24 hours
    }

    /*╔═════════════════════════════════╗
      ║          VIEW FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @notice Fetch the address of the most recently created market
    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode
    /// @return the address of the most recent market in the given mode
    function getMostRecentMarket(IRCMarket.Mode _mode)
        external
        view
        override
        returns (address)
    {
        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
    }

    /// @notice Fetch all the market addresses for a given mode
    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode
    /// @return an array of all markets in a given mode
    function getAllMarkets(IRCMarket.Mode _mode)
        external
        view
        override
        returns (address[] memory)
    {
        return marketAddresses[_mode];
    }

    /// @notice Returns the currently set pot distribution
    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates
    function getPotDistribution()
        external
        view
        override
        returns (uint256[5] memory)
    {
        return potDistribution;
    }

    /// @notice fetch the current oracle, arbitrator and timeout settings
    /// @dev called by the market upon initialise
    /// @dev not passed to initialise to avoid stack too deep error
    /// @return Oracle Address
    /// @return Arbitrator Address
    /// @return Question timeout in seconds
    function getOracleSettings()
        external
        view
        override
        returns (
            IRealitio,
            address,
            uint32
        )
    {
        return (realitio, arbitrator, timeout);
    }

    /// @notice Returns market addresses and ipfs hashes
    /// @dev used for the UI backup mode
    /// @param _mode return markets only in the given mode
    /// @param _state return markets only in the given state
    /// @param _skipResults the number of results to skip
    function getMarketInfo(
        IRCMarket.Mode _mode,
        uint256 _state,
        uint256 _skipResults
    )
        external
        view
        returns (
            address[] memory,
            string[] memory,
            string[] memory,
            uint256[] memory
        )
    {
        uint256 _marketIndex = marketAddresses[_mode].length;
        uint256 _resultNumber = 0;
        address[] memory _marketAddresses = new address[](marketInfoResults);
        string[] memory _ipfsHashes = new string[](marketInfoResults);
        uint256[] memory _potSizes = new uint256[](marketInfoResults);
        string[] memory _slugs = new string[](marketInfoResults);
        while (_resultNumber < marketInfoResults && _marketIndex > 1) {
            _marketIndex--;
            address _market = marketAddresses[_mode][_marketIndex];
            if (IRCMarket(_market).state() == IRCMarket.States(_state)) {
                if (_resultNumber < _skipResults) {
                    _resultNumber++;
                } else {
                    _marketAddresses[_resultNumber] = _market;
                    _ipfsHashes[_resultNumber] = ipfsHash[_market];
                    _slugs[_resultNumber] = addressToSlug[_market];
                    _potSizes[_resultNumber] = IRCMarket(_market)
                        .totalRentCollected();
                    _resultNumber++;
                }
            }
        }
        return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Not approved""
        );
        _;
    }
    modifier onlyOwner() {
        require(treasury.checkPermission(OWNER, msgSender()), ""Not approved"");
        _;
    }
    modifier onlyGovernors() {
        require(
            treasury.checkPermission(GOVERNOR, msgSender()),
            ""Not approved""
        );
        _;
    }
    modifier onlyMarkets() {
        require(treasury.checkPermission(MARKET, msgSender()), ""Not approved"");
        _;
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyOwner modifier
    // Min price increase & pot distribution emitted by Market.
    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUCTOR - PUBLIC │
      └────────────────────────────────────┘*/

    /// @notice update stakeholder payouts
    /// @dev in MegaBip (so 1000 = 100%)
    /// @param _artistCut The artist that designed the card
    /// @param _winnerCut Extra cut for the longest owner
    /// @param _creatorCut The creator of the market
    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts
    /// @param _cardAffiliateCut An affiliate cur for specific cards
    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) public override onlyOwner {
        require(
            _artistCut +
                _winnerCut +
                _creatorCut +
                _affiliateCut +
                _cardAffiliateCut <=
                PER_MILLE,
            ""Cuts too big""
        );
        potDistribution[0] = _artistCut;
        potDistribution[1] = _winnerCut;
        potDistribution[2] = _creatorCut;
        potDistribution[3] = _affiliateCut;
        potDistribution[4] = _cardAffiliateCut;
    }

    /// @notice how much above the current price a user must bid, in %
    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%
    function setMinimumPriceIncreasePercent(uint256 _percentIncrease)
        public
        override
        onlyOwner
    {
        minimumPriceIncreasePercent = _percentIncrease;
    }

    /// @notice how many NFTs will be awarded to the leaderboard
    /// @param _nftsToAward the number of NFTs to award
    function setNumberOfNFTsToAward(uint256 _nftsToAward)
        public
        override
        onlyOwner
    {
        nftsToAward = _nftsToAward;
    }

    /// @notice A limit to the number of NFTs to mint per market
    /// @dev to avoid gas limits
    /// @param _cardLimit the limit to set
    function setCardLimit(uint256 _cardLimit) public override onlyOwner {
        cardLimit = _cardLimit;
    }

    /// @notice A limit to the number of rent collections per transaction
    /// @dev to avoid gas limits
    /// @param _rentLimit the limit to set
    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)
        public
        override
        onlyOwner
    {
        maxRentIterations = _rentLimit;
        maxRentIterationsToLockMarket = _rentLimitLocking;
    }

    /// @notice set the address of the reality.eth contracts
    /// @param _newAddress the address to set
    function setRealitioAddress(address _newAddress) public override onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        realitio = IRealitio(_newAddress);
    }

    /// @notice address of the arbitrator, in case of continued disputes on reality.eth
    /// @param _newAddress the address to set
    function setArbitrator(address _newAddress) public override onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        arbitrator = _newAddress;
    }

    /// @notice set how long reality.eth waits for disputes before finalising
    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs
    function setTimeout(uint32 _newTimeout) public override onlyOwner {
        // event is emitted from the Oracle when the question is asked
        timeout = _newTimeout;
    }

    function setMarketPausedDefaultState(bool _state)
        external
        override
        onlyOwner
    {
        marketPausedDefaultState = _state;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL │
      └──────────────────────────────────────────┘*/

    /// @notice whether or not only governors can create the market
    function changeMarketCreationGovernorsOnly() external override onlyOwner {
        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;
    }

    /// @notice whether or not anyone can be an artist
    function changeApprovedArtistsOnly() external override onlyOwner {
        approvedArtistsOnly = !approvedArtistsOnly;
    }

    /// @notice whether or not anyone can be an affiliate
    function changeApprovedAffilliatesOnly() external override onlyOwner {
        approvedAffiliatesOnly = !approvedAffiliatesOnly;
    }

    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot
    /// @param _amount the sponsorship required in wei
    function setSponsorshipRequired(uint256 _amount)
        external
        override
        onlyOwner
    {
        sponsorshipRequired = _amount;
    }

    /// @notice market opening time must be at least this many seconds in the future
    /// @param _newAdvancedWarning the warning time to set in seconds
    function setMarketTimeRestrictions(
        uint32 _newAdvancedWarning,
        uint32 _newMinimumDuration,
        uint32 _newMaximumDuration
    ) external override onlyOwner {
        advancedWarning = _newAdvancedWarning;
        minimumDuration = _newMinimumDuration;
        maximumDuration = _newMaximumDuration;
        emit LogMarketTimeRestrictions(
            _newAdvancedWarning,
            _newMinimumDuration,
            _newMaximumDuration
        );
    }

    /// @notice Allow the owner to update a token URI.
    /// @param _market the market address the token belongs to
    /// @param _cardId the index 0 card id of the token to change
    /// @param _newTokenURI the new URI to set
    /// @param _newCopyTokenURI the new URI to set for the copy
    function updateTokenURI(
        address _market,
        uint256 _cardId,
        string calldata _newTokenURI,
        string calldata _newCopyTokenURI
    ) external override onlyOwner {
        IRCMarket.Mode _mode = IRCMarket(_market).mode();
        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();
        tokenURIs[_market][_cardId] = _newTokenURI;
        tokenURIs[_market][(_cardId + _numberOfCards)] = _newCopyTokenURI;
        string[] memory _tokenURIs = new string[](_numberOfCards);
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            _tokenURIs[i] = tokenURIs[_market][i];
        }
        uint32[] memory _timestamps = new uint32[](3);
        _timestamps[0] = IRCMarket(_market).marketOpeningTime();
        _timestamps[1] = IRCMarket(_market).marketLockingTime();
        _timestamps[2] = IRCMarket(_market).oracleResolutionTime();

        // reuse this event so the frontend can pickup the change
        emit LogMarketCreated2(
            _market,
            IRCMarket.Mode(_mode),
            _tokenURIs,
            ipfsHash[_market],
            _timestamps,
            nfthub.totalSupply()
        );
    }

    /// @notice change how many results are returned from getMarketInfo
    /// @dev would be better to pass this as a parameter in getMarketInfo
    /// @dev .. however we are limited because of stack too deep errors
    function setMarketInfoResults(uint256 _results)
        external
        override
        onlyOwner
    {
        // no event needed, only used for the backup view mode
        marketInfoResults = _results;
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - GOVERNORS      ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyGovernors modifier

    /// @notice markets are default hidden from the interface, this reveals them
    /// @param _market the market address to change approval for
    function changeMarketApproval(address _market)
        external
        override
        onlyGovernors
    {
        require(_market != address(0), ""Must set Address"");
        // check it's an RC contract
        require(treasury.checkPermission(MARKET, _market), ""Not Market"");
        isMarketApproved[_market] = !isMarketApproved[_market];
        // governors shouldn't have the ability to pause a market, only un-pause.
        // .. if a governor accidentally approves a market they should seek
        // .. assistance from the owner to decide if it should be paused.
        treasury.unPauseMarket(_market);
        // the market will however be hidden from the UI in the meantime
        emit LogMarketApproved(_market, isMarketApproved[_market]);
    }

    /*╔═════════════════════════════════╗
      ║   GOVERNANCE - Role management  ║
      ╚═════════════════════════════════╝*/
    /// @dev the following functions could all be performed directly on the treasury
    /// @dev .. they are here as an interim solution to give governors an easy way
    /// @dev .. to change all their parameters via the block explorer.

    /// @notice Grant the artist role to an address
    /// @param _newArtist the address to grant the role of artist
    function addArtist(address _newArtist) external override onlyGovernors {
        treasury.grantRole(ARTIST, _newArtist);
    }

    /// @notice Remove the artist role from an address
    /// @param _oldArtist the address to revoke the role of artist
    function removeArtist(address _oldArtist) external override onlyGovernors {
        treasury.revokeRole(ARTIST, _oldArtist);
    }

    /// @notice Grant the affiliate role to an address
    /// @param _newAffiliate the address to grant the role of affiliate
    function addAffiliate(address _newAffiliate)
        external
        override
        onlyGovernors
    {
        treasury.grantRole(AFFILIATE, _newAffiliate);
    }

    /// @notice Remove the affiliate role from an address
    /// @param _oldAffiliate the address to revoke the role of affiliate
    function removeAffiliate(address _oldAffiliate)
        external
        override
        onlyGovernors
    {
        treasury.revokeRole(AFFILIATE, _oldAffiliate);
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades, this is separated so owner can be
    /// @dev ..  set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governance functions

    /// @notice change the reference contract for the contract logic
    /// @param _newAddress the address of the new reference contract to set
    function setReferenceContractAddress(address _newAddress)
        external
        override
        onlyUberOwner
    {
        require(_newAddress != address(0));
        // check it's an RC contract
        IRCMarket newContractVariable = IRCMarket(_newAddress);
        require(newContractVariable.isMarket(), ""Not Market"");
        // set
        referenceContractAddress = _newAddress;
        // increment version
        referenceContractVersion += 1;
    }

    /// @notice where the NFTs live
    /// @param _newAddress the address to set
    function setNftHubAddress(IRCNftHubL2 _newAddress)
        external
        override
        onlyUberOwner
    {
        require(address(_newAddress) != address(0), ""Must set Address"");
        nfthub = _newAddress;
    }

    /// @notice set the address of the orderbook contract
    /// @param _newOrderbook the address to set
    /// @dev set by the treasury to ensure all contracts use the same orderbook
    function setOrderbookAddress(IRCOrderbook _newOrderbook) external override {
        require(
            treasury.checkPermission(TREASURY, msgSender()),
            ""Not approved""
        );
        orderbook = _newOrderbook;
    }

    /// @notice set the address of the leaderboard contract
    /// @param _newLeaderboard the address to set
    /// @dev set by the treasury to ensure all contracts use the same leaderboard
    function setLeaderboardAddress(IRCLeaderboard _newLeaderboard)
        external
        override
    {
        require(
            treasury.checkPermission(TREASURY, msgSender()),
            ""Not approved""
        );
        leaderboard = _newLeaderboard;
    }

    /*╔═════════════════════════════════╗
      ║         MARKET CREATION         ║
      ╚═════════════════════════════════╝*/

    /// @notice Creates a new market with the given parameters
    /// @param _mode 0 = normal, 1 = winner takes all
    /// @param _ipfsHash the IPFS location of the market metadata
    /// @param _slug the URL subdomain in the UI
    /// @param _timestamps for market opening, locking, and oracle resolution
    /// @param _tokenURIs location of NFT metadata, originals followed by copies
    /// @param _artistAddress where to send artist's cut, if any
    /// @param _affiliateAddress where to send affiliates cut, if any
    /// @param _cardAffiliateAddresses where to send card specific affiliates cut, if any
    /// @param _realitioQuestion the details of the event to send to the oracle
    /// @param _sponsorship amount of sponsorship to create the market with
    /// @return The address of the new market
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        string memory _slug,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string memory _realitioQuestion,
        uint256 _sponsorship
    ) external override returns (address) {
        address _creator = msgSender();

        // check nfthub has been set
        require(address(nfthub) != address(0), ""Nfthub not set"");

        // check sponsorship
        require(
            _sponsorship >= sponsorshipRequired,
            ""Insufficient sponsorship""
        );
        treasury.checkSponsorship(_creator, _sponsorship);

        // check the number of NFTs to mint is within limits
        /// @dev we want different tokenURIs for originals and copies
        /// @dev ..the copies are appended to the end of the array
        /// @dev ..so half the array length if the number of tokens.
        require(
            (_tokenURIs.length / 2) <= cardLimit,
            ""Too many tokens to mint""
        );

        // check stakeholder addresses
        // artist
        if (approvedArtistsOnly) {
            require(
                _artistAddress == address(0) ||
                    treasury.checkPermission(ARTIST, _artistAddress),
                ""Artist not approved""
            );
        }

        // affiliate
        require(
            _cardAffiliateAddresses.length == 0 ||
                _cardAffiliateAddresses.length == (_tokenURIs.length / 2),
            ""Card Affiliate Length Error""
        );
        if (approvedAffiliatesOnly) {
            require(
                _affiliateAddress == address(0) ||
                    treasury.checkPermission(AFFILIATE, _affiliateAddress),
                ""Affiliate not approved""
            );
            // card affiliates
            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {
                require(
                    _cardAffiliateAddresses[i] == address(0) ||
                        treasury.checkPermission(
                            CARD_AFFILIATE,
                            _cardAffiliateAddresses[i]
                        ),
                    ""Card affiliate not approved""
                );
            }
        }

        // check market creator is approved
        if (marketCreationGovernorsOnly) {
            require(
                treasury.checkPermission(GOVERNOR, _creator),
                ""Not approved""
            );
        }

        _checkTimestamps(_timestamps);

        // create the market and emit the appropriate events
        // two events to avoid stack too deep error
        address _newAddress = Clones.clone(referenceContractAddress);
        emit LogMarketCreated1(
            _newAddress,
            address(treasury),
            address(nfthub),
            referenceContractVersion
        );
        emit LogMarketCreated2(
            _newAddress,
            IRCMarket.Mode(_mode),
            _tokenURIs,
            _ipfsHash,
            _timestamps,
            nfthub.totalSupply()
        );

        // tell Treasury and NFT hub about new market
        // before initialize as during initialize the market may call the treasury
        treasury.addMarket(_newAddress, marketPausedDefaultState);
        nfthub.addMarket(_newAddress);

        // update internals
        marketAddresses[IRCMarket.Mode(_mode)].push(_newAddress);
        ipfsHash[_newAddress] = _ipfsHash;
        slugToAddress[_slug] = _newAddress;
        addressToSlug[_newAddress] = _slug;

        // initialize the market
        IRCMarket(_newAddress).initialize(
            IRCMarket.Mode(_mode),
            _timestamps,
            (_tokenURIs.length / 2),
            _artistAddress,
            _affiliateAddress,
            _cardAffiliateAddresses,
            _creator,
            _realitioQuestion,
            nftsToAward
        );

        // store token URIs
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            tokenURIs[_newAddress][i] = _tokenURIs[i];
        }

        // pay sponsorship, if applicable
        if (_sponsorship > 0) {
            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);
        }

        return _newAddress;
    }

    function _checkTimestamps(uint32[] memory _timestamps) internal view {
        // check timestamps
        require(_timestamps.length == 3, ""Incorrect number of array elements"");
        // check market opening time
        if (advancedWarning != 0) {
            // different statements to give clearer revert messages
            require(
                _timestamps[0] >= block.timestamp,
                ""Market opening time not set""
            );
            require(
                _timestamps[0] - advancedWarning > block.timestamp,
                ""Market opens too soon""
            );
        }
        // check market locking time
        if (maximumDuration != 0) {
            require(
                _timestamps[1] < block.timestamp + maximumDuration,
                ""Market locks too late""
            );
        }
        require(
            _timestamps[0] + minimumDuration < _timestamps[1] &&
                block.timestamp + minimumDuration < _timestamps[1],
            ""Market lock must be after opening""
        );
        // check oracle resolution time (no more than 1 week after market locking to get result)
        require(
            _timestamps[1] + (1 weeks) > _timestamps[2] &&
                _timestamps[1] <= _timestamps[2],
            ""Oracle resolution time error""
        );
    }

    /// @notice Called by the markets to mint the original NFTs
    /// @param _card the card id to be minted
    function mintMarketNFT(uint256 _card) external override onlyMarkets {
        uint256 nftHubMintCount = nfthub.totalSupply();
        address _market = msgSender();
        nfthub.mint(_market, nftHubMintCount, tokenURIs[_market][_card]);
        emit LogMintNFT(_card, _market, nftHubMintCount);
    }

    /// @notice allows the market to mint a copy of the NFT for users on the leaderboard
    /// @param _user the user to award the NFT to
    /// @param _cardId the tokenId to copy
    function mintCopyOfNFT(address _user, uint256 _cardId)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        uint256 _newTokenId = nfthub.totalSupply();
        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();
        nfthub.mint(
            _user,
            _newTokenId,
            tokenURIs[_market][(_cardId + _numberOfCards)]
        );
        emit LogMintNFTCopy(_cardId, _user, _newTokenId);
    }

    /*
         ▲  
        ▲ ▲ 
              */
}

",7456,838,"[M-02] Parameter updates not propagated

There are several functions to update parameters. However these parameters are only updated on the top level and not propagated to the other contracts. This could lead to various unpredictable results. Examples are:
 	`setNftHubAddress` of RCFactory
	`setOrderbookAddress` of RCFactory
	`setLeaderboardAddress` of RCFactory
	`setMinRental` of RCTreasury
",1,,"pragma solidity 0.8.7;

import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRealitio.sol"";




contract RCFactory is NativeMetaTransaction, IRCFactory {
    

    
    IRCTreasury public override treasury;
    IRCNftHubL2 public override nfthub;
    IRCOrderbook public override orderbook;
    IRCLeaderboard public override leaderboard;
    IRealitio public override realitio;
    
    address public override referenceContractAddress;
    
    uint256 public override referenceContractVersion;
    
    
    mapping(IRCMarket.Mode => address[]) public marketAddresses;

    
    
    
    mapping(address => string) public override ipfsHash;
    
    mapping(string => address) public override slugToAddress;
    mapping(address => string) public override addressToSlug;
    
    uint256 public override marketInfoResults;

    
    
    uint256[5] public potDistribution;
    
    uint256 public override sponsorshipRequired;
    
    uint256 public override minimumPriceIncreasePercent;
    
    uint256 public override nftsToAward;
    
    uint32 public override advancedWarning;
    
    uint32 public override maximumDuration;
    
    uint32 public override minimumDuration;
    
    bool public override marketCreationGovernorsOnly = true;
    
    bool public override approvedAffiliatesOnly = true;
    
    bool public override approvedArtistsOnly = true;
    
    uint256 public override maxRentIterations;
    
    uint256 public override maxRentIterationsToLockMarket;
    
    address public override arbitrator;
    
    uint32 public override timeout;
    
    bool public override marketPausedDefaultState;
    
    uint256 public override cardLimit;

    
    
    mapping(address => bool) public override isMarketApproved;

    
    uint256 public constant PER_MILLE = 1000; 
    
    
    
    mapping(address => mapping(uint256 => string)) tokenURIs;

    
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");

    

    event LogMarketCreated1(
        address contractAddress,
        address treasuryAddress,
        address nftHubAddress,
        uint256 referenceContractVersion
    );
    event LogMarketCreated2(
        address contractAddress,
        IRCMarket.Mode mode,
        string[] tokenURIs,
        string ipfsHash,
        uint32[] timestamps,
        uint256 totalNftMintCount
    );
    event LogMarketApproved(address market, bool approved);
    event LogMarketTimeRestrictions(
        uint256 _newAdvancedWarning,
        uint256 _newMinimumDuration,
        uint256 _newMaximumDuration
    );
    event LogMintNFTCopy(
        uint256 _originalTokenId,
        address _newOwner,
        uint256 _newTokenId
    );
    event LogMintNFT(uint256 _cardId, address _market, uint256 _tokenId);

    

    constructor(
        IRCTreasury _treasury,
        address _realitioAddress,
        address _arbitratorAddress
    ) {
        require(address(_treasury) != address(0), ""Must set Address"");
        
        _initializeEIP712(""RealityCardsFactory"", ""1"");

        
        treasury = _treasury;

        
        
        setPotDistribution(20, 0, 0, 20, 100); 
        setMinimumPriceIncreasePercent(10); 
        setNumberOfNFTsToAward(3);
        setCardLimit(100); 
        setMaxRentIterations(50, 25); 
        
        setArbitrator(_arbitratorAddress);
        setRealitioAddress(_realitioAddress);
        setTimeout(86400); 
    }

    

    
    
    
    function getMostRecentMarket(IRCMarket.Mode _mode)
        external
        view
        override
        returns (address)
    {
        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
    }

    
    
    
    function getAllMarkets(IRCMarket.Mode _mode)
        external
        view
        override
        returns (address[] memory)
    {
        return marketAddresses[_mode];
    }

    
    
    function getPotDistribution()
        external
        view
        override
        returns (uint256[5] memory)
    {
        return potDistribution;
    }

    
    
    
    
    
    
    function getOracleSettings()
        external
        view
        override
        returns (
            IRealitio,
            address,
            uint32
        )
    {
        return (realitio, arbitrator, timeout);
    }

    
    
    
    
    
    function getMarketInfo(
        IRCMarket.Mode _mode,
        uint256 _state,
        uint256 _skipResults
    )
        external
        view
        returns (
            address[] memory,
            string[] memory,
            string[] memory,
            uint256[] memory
        )
    {
        uint256 _marketIndex = marketAddresses[_mode].length;
        uint256 _resultNumber = 0;
        address[] memory _marketAddresses = new address[](marketInfoResults);
        string[] memory _ipfsHashes = new string[](marketInfoResults);
        uint256[] memory _potSizes = new uint256[](marketInfoResults);
        string[] memory _slugs = new string[](marketInfoResults);
        while (_resultNumber < marketInfoResults && _marketIndex > 1) {
            _marketIndex--;
            address _market = marketAddresses[_mode][_marketIndex];
            if (IRCMarket(_market).state() == IRCMarket.States(_state)) {
                if (_resultNumber < _skipResults) {
                    _resultNumber++;
                } else {
                    _marketAddresses[_resultNumber] = _market;
                    _ipfsHashes[_resultNumber] = ipfsHash[_market];
                    _slugs[_resultNumber] = addressToSlug[_market];
                    _potSizes[_resultNumber] = IRCMarket(_market)
                        .totalRentCollected();
                    _resultNumber++;
                }
            }
        }
        return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);
    }

    

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Not approved""
        );
        _;
    }
    modifier onlyOwner() {
        require(treasury.checkPermission(OWNER, msgSender()), ""Not approved"");
        _;
    }
    modifier onlyGovernors() {
        require(
            treasury.checkPermission(GOVERNOR, msgSender()),
            ""Not approved""
        );
        _;
    }
    modifier onlyMarkets() {
        require(treasury.checkPermission(MARKET, msgSender()), ""Not approved"");
        _;
    }

    
    
    
    

    

    
    
    
    
    
    
    
    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) public override onlyOwner {
        require(
            _artistCut +
                _winnerCut +
                _creatorCut +
                _affiliateCut +
                _cardAffiliateCut <=
                PER_MILLE,
            ""Cuts too big""
        );
        potDistribution[0] = _artistCut;
        potDistribution[1] = _winnerCut;
        potDistribution[2] = _creatorCut;
        potDistribution[3] = _affiliateCut;
        potDistribution[4] = _cardAffiliateCut;
    }

    
    
    function setMinimumPriceIncreasePercent(uint256 _percentIncrease)
        public
        override
        onlyOwner
    {
        minimumPriceIncreasePercent = _percentIncrease;
    }

    
    
    function setNumberOfNFTsToAward(uint256 _nftsToAward)
        public
        override
        onlyOwner
    {
        nftsToAward = _nftsToAward;
    }

    
    
    
    function setCardLimit(uint256 _cardLimit) public override onlyOwner {
        cardLimit = _cardLimit;
    }

    
    
    
    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)
        public
        override
        onlyOwner
    {
        maxRentIterations = _rentLimit;
        maxRentIterationsToLockMarket = _rentLimitLocking;
    }

    
    
    function setRealitioAddress(address _newAddress) public override onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        realitio = IRealitio(_newAddress);
    }

    
    
    function setArbitrator(address _newAddress) public override onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        arbitrator = _newAddress;
    }

    
    
    function setTimeout(uint32 _newTimeout) public override onlyOwner {
        
        timeout = _newTimeout;
    }

    function setMarketPausedDefaultState(bool _state)
        external
        override
        onlyOwner
    {
        marketPausedDefaultState = _state;
    }

    

    
    function changeMarketCreationGovernorsOnly() external override onlyOwner {
        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;
    }

    
    function changeApprovedArtistsOnly() external override onlyOwner {
        approvedArtistsOnly = !approvedArtistsOnly;
    }

    
    function changeApprovedAffilliatesOnly() external override onlyOwner {
        approvedAffiliatesOnly = !approvedAffiliatesOnly;
    }

    
    
    function setSponsorshipRequired(uint256 _amount)
        external
        override
        onlyOwner
    {
        sponsorshipRequired = _amount;
    }

    
    
    function setMarketTimeRestrictions(
        uint32 _newAdvancedWarning,
        uint32 _newMinimumDuration,
        uint32 _newMaximumDuration
    ) external override onlyOwner {
        advancedWarning = _newAdvancedWarning;
        minimumDuration = _newMinimumDuration;
        maximumDuration = _newMaximumDuration;
        emit LogMarketTimeRestrictions(
            _newAdvancedWarning,
            _newMinimumDuration,
            _newMaximumDuration
        );
    }

    
    
    
    
    
    function updateTokenURI(
        address _market,
        uint256 _cardId,
        string calldata _newTokenURI,
        string calldata _newCopyTokenURI
    ) external override onlyOwner {
        IRCMarket.Mode _mode = IRCMarket(_market).mode();
        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();
        tokenURIs[_market][_cardId] = _newTokenURI;
        tokenURIs[_market][(_cardId + _numberOfCards)] = _newCopyTokenURI;
        string[] memory _tokenURIs = new string[](_numberOfCards);
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            _tokenURIs[i] = tokenURIs[_market][i];
        }
        uint32[] memory _timestamps = new uint32[](3);
        _timestamps[0] = IRCMarket(_market).marketOpeningTime();
        _timestamps[1] = IRCMarket(_market).marketLockingTime();
        _timestamps[2] = IRCMarket(_market).oracleResolutionTime();

        
        emit LogMarketCreated2(
            _market,
            IRCMarket.Mode(_mode),
            _tokenURIs,
            ipfsHash[_market],
            _timestamps,
            nfthub.totalSupply()
        );
    }

    
    
    
    function setMarketInfoResults(uint256 _results)
        external
        override
        onlyOwner
    {
        
        marketInfoResults = _results;
    }

    
    

    
    
    function changeMarketApproval(address _market)
        external
        override
        onlyGovernors
    {
        require(_market != address(0), ""Must set Address"");
        
        require(treasury.checkPermission(MARKET, _market), ""Not Market"");
        isMarketApproved[_market] = !isMarketApproved[_market];
        
        
        
        treasury.unPauseMarket(_market);
        
        emit LogMarketApproved(_market, isMarketApproved[_market]);
    }

    
    
    
    

    
    
    function addArtist(address _newArtist) external override onlyGovernors {
        treasury.grantRole(ARTIST, _newArtist);
    }

    
    
    function removeArtist(address _oldArtist) external override onlyGovernors {
        treasury.revokeRole(ARTIST, _oldArtist);
    }

    
    
    function addAffiliate(address _newAffiliate)
        external
        override
        onlyGovernors
    {
        treasury.grantRole(AFFILIATE, _newAffiliate);
    }

    
    
    function removeAffiliate(address _oldAffiliate)
        external
        override
        onlyGovernors
    {
        treasury.revokeRole(AFFILIATE, _oldAffiliate);
    }

    
    
    
    

    
    
    function setReferenceContractAddress(address _newAddress)
        external
        override
        onlyUberOwner
    {
        require(_newAddress != address(0));
        
        IRCMarket newContractVariable = IRCMarket(_newAddress);
        require(newContractVariable.isMarket(), ""Not Market"");
        
        referenceContractAddress = _newAddress;
        
        referenceContractVersion += 1;
    }

    
    
    function setNftHubAddress(IRCNftHubL2 _newAddress)
        external
        override
        onlyUberOwner
    {
        require(address(_newAddress) != address(0), ""Must set Address"");
        nfthub = _newAddress;
    }

    
    
    
    function setOrderbookAddress(IRCOrderbook _newOrderbook) external override {
        require(
            treasury.checkPermission(TREASURY, msgSender()),
            ""Not approved""
        );
        orderbook = _newOrderbook;
    }

    
    
    
    function setLeaderboardAddress(IRCLeaderboard _newLeaderboard)
        external
        override
    {
        require(
            treasury.checkPermission(TREASURY, msgSender()),
            ""Not approved""
        );
        leaderboard = _newLeaderboard;
    }

    

    
    
    
    
    
    
    
    
    
    
    
    
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        string memory _slug,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string memory _realitioQuestion,
        uint256 _sponsorship
    ) external override returns (address) {
        address _creator = msgSender();

        
        require(address(nfthub) != address(0), ""Nfthub not set"");

        
        require(
            _sponsorship >= sponsorshipRequired,
            ""Insufficient sponsorship""
        );
        treasury.checkSponsorship(_creator, _sponsorship);

        
        
        
        
        require(
            (_tokenURIs.length / 2) <= cardLimit,
            ""Too many tokens to mint""
        );

        
        
        if (approvedArtistsOnly) {
            require(
                _artistAddress == address(0) ||
                    treasury.checkPermission(ARTIST, _artistAddress),
                ""Artist not approved""
            );
        }

        
        require(
            _cardAffiliateAddresses.length == 0 ||
                _cardAffiliateAddresses.length == (_tokenURIs.length / 2),
            ""Card Affiliate Length Error""
        );
        if (approvedAffiliatesOnly) {
            require(
                _affiliateAddress == address(0) ||
                    treasury.checkPermission(AFFILIATE, _affiliateAddress),
                ""Affiliate not approved""
            );
            
            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {
                require(
                    _cardAffiliateAddresses[i] == address(0) ||
                        treasury.checkPermission(
                            CARD_AFFILIATE,
                            _cardAffiliateAddresses[i]
                        ),
                    ""Card affiliate not approved""
                );
            }
        }

        
        if (marketCreationGovernorsOnly) {
            require(
                treasury.checkPermission(GOVERNOR, _creator),
                ""Not approved""
            );
        }

        _checkTimestamps(_timestamps);

        
        
        address _newAddress = Clones.clone(referenceContractAddress);
        emit LogMarketCreated1(
            _newAddress,
            address(treasury),
            address(nfthub),
            referenceContractVersion
        );
        emit LogMarketCreated2(
            _newAddress,
            IRCMarket.Mode(_mode),
            _tokenURIs,
            _ipfsHash,
            _timestamps,
            nfthub.totalSupply()
        );

        
        
        treasury.addMarket(_newAddress, marketPausedDefaultState);
        nfthub.addMarket(_newAddress);

        
        marketAddresses[IRCMarket.Mode(_mode)].push(_newAddress);
        ipfsHash[_newAddress] = _ipfsHash;
        slugToAddress[_slug] = _newAddress;
        addressToSlug[_newAddress] = _slug;

        
        IRCMarket(_newAddress).initialize(
            IRCMarket.Mode(_mode),
            _timestamps,
            (_tokenURIs.length / 2),
            _artistAddress,
            _affiliateAddress,
            _cardAffiliateAddresses,
            _creator,
            _realitioQuestion,
            nftsToAward
        );

        
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            tokenURIs[_newAddress][i] = _tokenURIs[i];
        }

        
        if (_sponsorship > 0) {
            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);
        }

        return _newAddress;
    }

    function _checkTimestamps(uint32[] memory _timestamps) internal view {
        
        require(_timestamps.length == 3, ""Incorrect number of array elements"");
        
        if (advancedWarning != 0) {
            
            require(
                _timestamps[0] >= block.timestamp,
                ""Market opening time not set""
            );
            require(
                _timestamps[0] - advancedWarning > block.timestamp,
                ""Market opens too soon""
            );
        }
        
        if (maximumDuration != 0) {
            require(
                _timestamps[1] < block.timestamp + maximumDuration,
                ""Market locks too late""
            );
        }
        require(
            _timestamps[0] + minimumDuration < _timestamps[1] &&
                block.timestamp + minimumDuration < _timestamps[1],
            ""Market lock must be after opening""
        );
        
        require(
            _timestamps[1] + (1 weeks) > _timestamps[2] &&
                _timestamps[1] <= _timestamps[2],
            ""Oracle resolution time error""
        );
    }

    
    
    function mintMarketNFT(uint256 _card) external override onlyMarkets {
        uint256 nftHubMintCount = nfthub.totalSupply();
        address _market = msgSender();
        nfthub.mint(_market, nftHubMintCount, tokenURIs[_market][_card]);
        emit LogMintNFT(_card, _market, nftHubMintCount);
    }

    
    
    
    function mintCopyOfNFT(address _user, uint256 _cardId)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        uint256 _newTokenId = nfthub.totalSupply();
        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();
        nfthub.mint(
            _user,
            _newTokenId,
            tokenURIs[_market][(_cardId + _numberOfCards)]
        );
        emit LogMintNFTCopy(_cardId, _user, _newTokenId);
    }

    
}",4268,0,1,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only the intended UBER_OWNER can call setReferenceContractAddress, setNftHubAddress, setOrderbookAddress, and setLeaderboardAddress."",
        ""Confirm that OWNER role can modify critical parameters like pot distribution, minimum price increase, number of NFTs to award, card limit, rent iteration limits, Realitio/Arbitrator addresses, timeouts, market paused default state, and sponsorship requirement."",
        ""Ensure only GOVERNOR role can add/remove artists/affiliates and change market approval status."",
        ""Verify that markets can only call mintMarketNFT and mintCopyOfNFT functions via the onlyMarkets modifier."",
        ""Analyze IRCTreasury contract to understand how roles (UBER_OWNER, OWNER, GOVERNOR, MARKET, ARTIST, AFFILIATE, CARD_AFFILIATE) are managed and assigned."",
        ""Investigate potential vulnerabilities in the role management within the IRCTreasury contract (e.g., privilege escalation, unauthorized role assignment)."",
        ""Check that the treasury address cannot be set to the zero address."",
        ""Verify there is no way to accidentally or maliciously self-assign a role or grant a role to the zero address within the treasury contract.""
      ]
    },
    {
      ""Area"": ""Market Creation and Configuration"",
      ""Tasks"": [
        ""Analyze the createMarket function's input validation logic, focusing on timestamp checks (_checkTimestamps) to prevent markets from being created with invalid or manipulated time settings."",
        ""Review the usage of Clones.clone and IRCMarket.initialize to ensure proper initialization of new market instances and prevent potential cloning vulnerabilities."",
        ""Verify that the _sponsorship parameter in createMarket is correctly handled and that the checkSponsorship function in the treasury prevents replay attacks or other abuses of the sponsorship mechanism."",
        ""Confirm that only approved entities can be assigned roles during market creation, based on the approvedArtistsOnly and approvedAffiliatesOnly flags."",
        ""Investigate potential vulnerabilities related to the _tokenURIs parameter in createMarket, ensuring that it is correctly validated and that the token URIs are properly stored and used."",
        ""Examine the mintMarketNFT and mintCopyOfNFT functions to ensure they can only be called by approved market contracts and prevent unauthorized NFT minting."",
        ""Check for reentrancy vulnerabilities when treasury is being called from createMarket (e.g. treasury.checkSponsorship)."",
        ""Examine the logic in updateTokenURI function, particularly the re-emission of LogMarketCreated2 event, verifying that it accurately reflects the current state of the market and NFT Hub."",
        ""Ensure the division by 2 of _tokenURIs.length is safe and well-understood."",
        ""Analyze the potential for denial of service in `getMarketInfo` if a malicious actor creates numerous markets that all match the filtering criteria.""
      ]
    },
    {
      ""Area"": ""Timestamp Validation and Market Duration"",
      ""Tasks"": [
        ""Thoroughly examine the _checkTimestamps function to ensure that it correctly validates the market opening, locking, and resolution times."",
        ""Verify that advancedWarning, minimumDuration, and maximumDuration are properly enforced and cannot be manipulated to create markets with unintended durations."",
        ""Check for potential vulnerabilities related to block.timestamp and its predictability, as it is used in the timestamp validation logic."",
        ""Analyze the interaction between the timestamp validation logic and the Realitio oracle resolution process to ensure that the market resolution time is properly enforced."",
        ""Consider scenarios where the oracle resolution time is significantly delayed and how this might affect the market's functionality and user experience.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit all external calls to the IRCTreasury, IRCNftHubL2, IRealitio, and IRCMarket contracts, paying close attention to potential reentrancy vulnerabilities, unexpected return values, or data manipulation."",
        ""Verify that the Clones library is used correctly and that the cloned market contracts are properly initialized."",
        ""Analyze the interaction between the RCFactory and the IRCOrderbook and IRCLeaderboard contracts, ensuring that data is correctly passed and processed."",
        ""Check for potential vulnerabilities related to the Realitio oracle and its ability to provide accurate and reliable market resolution data."",
        ""Review the `checkSponsorship` function in the `IRCTreasury` for potential vulnerabilities, especially related to reentrancy or double-spending of sponsorship funds."",
         ""Verify the NFTHub address cannot be set to the zero address.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify gas inefficiencies in the createMarket function, particularly in the loop that iterates over the _tokenURIs array."",
        ""Analyze the storage access patterns in the contract to identify potential areas for gas optimization."",
        ""Evaluate the gas cost of the getMarketInfo function, considering the potential for a large number of markets."",
        ""Review the usage of memory vs. storage in the contract and optimize where possible."",
        ""Consider using immutable variables where appropriate to reduce gas costs."",
        ""Check whether calldata can be used instead of memory in some functions.""
      ]
    },
    {
      ""Area"": ""Minting and NFT Security"",
      ""Tasks"": [
        ""Ensure proper access control on the mintMarketNFT and mintCopyOfNFT functions, restricting them to approved market contracts only."",
        ""Verify that the tokenURIs mapping is properly managed and that the correct token URIs are used when minting NFTs."",
        ""Analyze the potential for NFT minting vulnerabilities, such as unauthorized minting or double-minting of NFTs."",
        ""Review the interaction between the RCFactory and the IRCNftHubL2 contract, ensuring that NFT minting is performed securely and efficiently."",
        ""Check for integer overflow issues when calculating the _newTokenId in mintCopyOfNFT."",
        ""Validate the range of `_cardId` within `mintCopyOfNFT` to ensure it is within the number of cards and less than the total supply to prevent underflow issues.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The RCFactory contract serves as the central creation point and configuration manager for Reality Cards markets (IRCMarket). It utilizes OpenZeppelin's Clones library to efficiently deploy new market instances based on a reference contract. It manages global settings like pot distribution, fees, time limits, NFT awards, and references to other core system contracts (Treasury, NftHub, Orderbook, Leaderboard, Realitio). Access control is heavily reliant on roles defined and checked within the associated Treasury contract. It also supports EIP-712 meta-transactions via NativeMetaTransaction."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""RCFactory"",
    ""Purpose"": ""To create, configure, and manage instances (clones) of Reality Cards markets (IRCMarket). It acts as a central registry and settings provider for the Reality Cards ecosystem."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""NativeMetaTransaction"",
        ""IRCFactory""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts/proxy/Clones.sol"",
        ""hardhat/console.sol"",
        ""./interfaces/IRCFactory.sol"",
        ""./interfaces/IRCTreasury.sol"",
        ""./interfaces/IRCMarket.sol"",
        ""./interfaces/IRCNftHubL2.sol"",
        ""./interfaces/IRCOrderbook.sol"",
        ""./lib/NativeMetaTransaction.sol"",
        ""./interfaces/IRealitio.sol"",
        ""./interfaces/IRCLeaderboard.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""treasury"",
        ""Type"": ""IRCTreasury"",
        ""Purpose"": ""Reference to the Treasury contract, used for payments and role-based access control checks.""
      },
      {
        ""Name"": ""nfthub"",
        ""Type"": ""IRCNftHubL2"",
        ""Purpose"": ""Reference to the NFT Hub contract, responsible for minting NFTs for markets.""
      },
      {
        ""Name"": ""orderbook"",
        ""Type"": ""IRCOrderbook"",
        ""Purpose"": ""Reference to the Orderbook contract (purpose inferred, likely related to market orders).""
      },
      {
        ""Name"": ""leaderboard"",
        ""Type"": ""IRCLeaderboard"",
        ""Purpose"": ""Reference to the Leaderboard contract (purpose inferred, likely for tracking user stats).""
      },
      {
        ""Name"": ""realitio"",
        ""Type"": ""IRealitio"",
        ""Purpose"": ""Reference to the Realitio contract, used as the oracle for market resolution.""
      },
      {
        ""Name"": ""referenceContractAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""The address of the logic contract (IRCMarket implementation) to be cloned for new markets.""
      },
      {
        ""Name"": ""referenceContractVersion"",
        ""Type"": ""uint256"",
        ""Purpose"": ""A version number incremented when the reference contract address is updated.""
      },
      {
        ""Name"": ""marketAddresses"",
        ""Type"": ""mapping(IRCMarket.Mode => address[])"",
        ""Purpose"": ""Stores lists of created market addresses, categorized by market mode.""
      },
      {
        ""Name"": ""ipfsHash"",
        ""Type"": ""mapping(address => string)"",
        ""Purpose"": ""Maps market addresses to their corresponding IPFS hash containing market metadata.""
      },
      {
        ""Name"": ""slugToAddress"",
        ""Type"": ""mapping(string => address)"",
        ""Purpose"": ""Maps a human-readable slug to a market address.""
      },
      {
        ""Name"": ""addressToSlug"",
        ""Type"": ""mapping(address => string)"",
        ""Purpose"": ""Maps a market address back to its slug.""
      },
      {
        ""Name"": ""marketInfoResults"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The maximum number of results returned by getMarketInfo.""
      },
      {
        ""Name"": ""potDistribution"",
        ""Type"": ""uint256[5]"",
        ""Purpose"": ""Array defining how the collected rent (pot) is distributed (artist, winner, creator, affiliate, cardAffiliate cuts) in per mille (1/1000).""
      },
      {
        ""Name"": ""sponsorshipRequired"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Minimum sponsorship amount required to create a market.""
      },
      {
        ""Name"": ""minimumPriceIncreasePercent"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The minimum percentage increase required when taking ownership of a card.""
      },
      {
        ""Name"": ""nftsToAward"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The number of NFTs awarded to top holders at market resolution.""
      },
      {
        ""Name"": ""advancedWarning"",
        ""Type"": ""uint32"",
        ""Purpose"": ""Minimum time (in seconds) before a market's opening time that it can be created.""
      },
      {
        ""Name"": ""maximumDuration"",
        ""Type"": ""uint32"",
        ""Purpose"": ""Maximum duration (in seconds) a market can run from creation to locking.""
      },
      {
        ""Name"": ""minimumDuration"",
        ""Type"": ""uint32"",
        ""Purpose"": ""Minimum duration (in seconds) a market must run between opening and locking.""
      },
      {
        ""Name"": ""marketCreationGovernorsOnly"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag indicating if only Governors can create markets.""
      },
      {
        ""Name"": ""approvedAffiliatesOnly"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag indicating if only approved Affiliates can be assigned during market creation.""
      },
      {
        ""Name"": ""approvedArtistsOnly"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag indicating if only approved Artists can be assigned during market creation.""
      },
      {
        ""Name"": ""maxRentIterations"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Limit on rent collection iterations (purpose inferred, likely gas optimization).""
      },
      {
        ""Name"": ""maxRentIterationsToLockMarket"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Limit on rent collection iterations when locking a market (purpose inferred).""
      },
      {
        ""Name"": ""arbitrator"",
        ""Type"": ""address"",
        ""Purpose"": ""The arbitrator address used for Realitio oracle resolution.""
      },
      {
        ""Name"": ""timeout"",
        ""Type"": ""uint32"",
        ""Purpose"": ""The timeout period (in seconds) used for Realitio oracle resolution.""
      },
      {
        ""Name"": ""marketPausedDefaultState"",
        ""Type"": ""bool"",
        ""Purpose"": ""The default paused state for newly created markets.""
      },
      {
        ""Name"": ""cardLimit"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Maximum number of distinct cards (outcomes) allowed per market.""
      },
      {
        ""Name"": ""isMarketApproved"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Maps market addresses to their approval status (controlled by Governors).""
      },
      {
        ""Name"": ""PER_MILLE"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Constant representing 1000, used for percentage calculations.""
      },
      {
        ""Name"": ""tokenURIs"",
        ""Type"": ""mapping(address => mapping(uint256 => string))"",
        ""Purpose"": ""Stores token URIs for NFTs associated with each market and card ID (including originals and copies).""
      },
      {
        ""Name"": ""UBER_OWNER / OWNER / GOVERNOR / etc."",
        ""Type"": ""bytes32 constant"",
        ""Purpose"": ""Constants representing role identifiers used for access control checks via the Treasury contract.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract, sets Treasury, Realitio, Arbitrator, EIP712 domain, and default parameters."",
        ""Parameters"": [""IRCTreasury _treasury"", ""address _realitioAddress"", ""address _arbitratorAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""getMostRecentMarket"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the address of the most recently created market for a given mode."",
        ""Parameters"": [""IRCMarket.Mode _mode""],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""getAllMarkets"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns an array of all market addresses for a given mode."",
        ""Parameters"": [""IRCMarket.Mode _mode""],
        ""Returns"": [""address[] memory""]
      },
      {
        ""Name"": ""getPotDistribution"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the current pot distribution percentages."",
        ""Parameters"": [],
        ""Returns"": [""uint256[5] memory""]
      },
      {
        ""Name"": ""getOracleSettings"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the Realitio address, arbitrator address, and timeout value."",
        ""Parameters"": [],
        ""Returns"": [""IRealitio"", ""address"", ""uint32""]
      },
      {
        ""Name"": ""getMarketInfo"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Retrieves information (address, IPFS hash, slug, pot size) for markets matching a specific mode and state."",
        ""Parameters"": [""IRCMarket.Mode _mode"", ""uint256 _state"", ""uint256 _skipResults""],
        ""Returns"": [""address[] memory"", ""string[] memory"", ""string[] memory"", ""uint256[] memory""]
      },
      {
        ""Name"": ""onlyUberOwner / onlyOwner / onlyGovernors / onlyMarkets"",
        ""Visibility"": ""internal (modifier)"",
        ""Purpose"": ""Access control modifiers that check sender's role via the Treasury contract."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setPotDistribution"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the pot distribution percentages (Owner only)."",
        ""Parameters"": [""uint256 _artistCut"", ""uint256 _winnerCut"", ""uint256 _creatorCut"", ""uint256 _affiliateCut"", ""uint256 _cardAffiliateCut""],
        ""Returns"": []
      },
      {
        ""Name"": ""setMinimumPriceIncreasePercent / setNumberOfNFTsToAward / setCardLimit / setMaxRentIterations / setRealitioAddress / setArbitrator / setTimeout / setMarketPausedDefaultState / setSponsorshipRequired / setMarketTimeRestrictions / setMarketInfoResults"",
        ""Visibility"": ""public/external"",
        ""Purpose"": ""Various setter functions for global configuration parameters (mostly Owner only)."",
        ""Parameters"": [""Vary depending on function""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeMarketCreationGovernorsOnly / changeApprovedArtistsOnly / changeApprovedAffilliatesOnly"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Toggles boolean flags controlling creation restrictions (Owner only)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""updateTokenURI"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the token URI for a specific card in a market and re-emits LogMarketCreated2 (Owner only)."",
        ""Parameters"": [""address _market"", ""uint256 _cardId"", ""string calldata _newTokenURI"", ""string calldata _newCopyTokenURI""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeMarketApproval"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Toggles the approval status of a market (Governors only). Also unpauses the market in the treasury."",
        ""Parameters"": [""address _market""],
        ""Returns"": []
      },
      {
        ""Name"": ""addArtist / removeArtist / addAffiliate / removeAffiliate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds or removes addresses from specific roles via the Treasury contract (Governors only)."",
        ""Parameters"": [""address _address""],
        ""Returns"": []
      },
      {
        ""Name"": ""setReferenceContractAddress"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the address of the reference market contract to be cloned (UberOwner only)."",
        ""Parameters"": [""address _newAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""setNftHubAddress / setOrderbookAddress / setLeaderboardAddress"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the addresses of core system contracts (UberOwner or Treasury role required)."",
        ""Parameters"": [""address _newAddress or Interface _newAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""createMarket"",
        ""Visibility"": ""external"",
        ""Purpose"": ""The core function: validates parameters, checks permissions/approvals, requires sponsorship, clones the reference contract, initializes the new market, registers it, stores metadata, and emits events."",
        ""Parameters"": [""uint32 _mode"", ""string memory _ipfsHash"", ""string memory _slug"", ""uint32[] memory _timestamps"", ""string[] memory _tokenURIs"", ""address _artistAddress"", ""address _affiliateAddress"", ""address[] memory _cardAffiliateAddresses"", ""string memory _realitioQuestion"", ""uint256 _sponsorship""],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""_checkTimestamps"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Helper function to validate the market opening, locking, and resolution timestamps."",
        ""Parameters"": [""uint32[] memory _timestamps""],
        ""Returns"": []
      },
      {
        ""Name"": ""mintMarketNFT"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by a market contract (onlyMarkets modifier) to mint an original NFT via the NftHub."",
        ""Parameters"": [""uint256 _card""],
        ""Returns"": []
      },
      {
        ""Name"": ""mintCopyOfNFT"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by a market contract (onlyMarkets modifier) to mint a copy NFT for a user via the NftHub."",
        ""Parameters"": [""address _user"", ""uint256 _cardId""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IRCTreasury: Used for role checks (checkPermission), adding markets (addMarket), unpausing markets (unPauseMarket), checking sponsorship (checkSponsorship), and potentially payments (implicitly via sponsor function call on market). Role management (grantRole, revokeRole) is delegated to it."",
    ""IRCNftHubL2: Used to mint NFTs (mint) and add market permissions (addMarket). Relies on its totalSupply."",
    ""IRealitio: Used as the oracle service interface, address stored."",
    ""IRCMarket (Reference Contract): Cloned using Clones.clone. The factory calls the initialize function on the newly cloned market address. It also reads state (state(), totalRentCollected(), marketOpeningTime(), etc.) from market instances."",
    ""IRCOrderbook: Address stored, likely called by other components or off-chain services."",
    ""IRCLeaderboard: Address stored, likely called by other components or off-chain services."",
    ""Clones (OpenZeppelin): Library used to create minimal proxy clones of the referenceContractAddress.""
  ],
  ""SpecialMechanisms"": [
    ""Factory Pattern: Creates instances of IRCMarket contracts."",
    ""Minimal Proxy (Clones): Uses EIP-1167 minimal proxies (via OZ Clones library) for gas-efficient deployment of market instances."",
    ""Role-Based Access Control (RBAC): Uses specific roles (UBER_OWNER, OWNER, GOVERNOR, MARKET, ARTIST, AFFILIATE, CARD_AFFILIATE) defined as constants. Access control checks are delegated to the IRCTreasury contract."",
    ""EIP-712 Meta-transactions: Inherits from NativeMetaTransaction, allowing users to submit transactions signed off-chain, potentially enabling gasless transactions if a relayer service is used."",
    ""Configuration Hub: Acts as a central point for managing global settings affecting all markets."",
    ""Registry: Maintains lists of created markets (marketAddresses) and mappings for metadata (ipfsHash, slugToAddress).""
  ],
  ""Questions"": [
    ""How are the specific roles (UBER_OWNER, OWNER, GOVERNOR, etc.) managed and assigned within the IRCTreasury contract?"",
    ""What is the exact logic within the `IRCMarket.initialize` function called after cloning?"",
    ""Are there checks within the `treasury.checkSponsorship` function to prevent re-entrancy or double-spending of sponsorship?"",
    ""The `getMarketInfo` function iterates through the `marketAddresses` array. Could this lead to excessive gas usage if the number of markets becomes very large?"",
    ""The `updateTokenURI` function re-emits `LogMarketCreated2`. Is this intended to signal a full metadata update to off-chain indexers? Does it accurately reflect the state (e.g., `nfthub.totalSupply()` might have changed since original creation)?"",
    ""Why can the `TREASURY` role set the Orderbook and Leaderboard addresses, while other critical addresses require `UBER_OWNER`? Is this intended access level?"",
    ""How is the division of `_tokenURIs.length / 2` used consistently? Does it imply that the input array always contains pairs of URIs (original, copy)?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerabilities"",
      ""Severity"": ""High"",
      ""Description"": ""The contract may be vulnerable to reentrancy attacks in several functions. The `createMarket` function makes external calls to `treasury.checkSponsorship` and potentially `IRCMarket(_newAddress).sponsor()` before the market state is fully finalized. If these external contracts allow reentrancy back into RCFactory, it could lead to inconsistent state, incorrect market configurations, or potential theft of sponsorship funds. Additionally, the `changeMarketApproval` function calls `treasury.unPauseMarket`, which could also introduce reentrancy if the treasury or the market contract allows callbacks."",
      ""Impact"": ""Reentrancy could lead to inconsistent contract state, creation of markets with incorrect configurations, potential denial of service, theft of sponsorship funds, or unauthorized manipulation of market approval status."",
      ""Location"": ""RCFactory.sol:539 (createMarket), RCFactory.sol:createMarket (sponsor call), Function `changeMarketApproval`""
    },
    {
      ""Issue"": ""Potential Denial of Service via Gas Exhaustion (`getMarketInfo`, `setMarketInfoResults`)"",
      ""Severity"": ""High"",
      ""Description"": ""The `getMarketInfo` function iterates through market addresses using a `while` loop constrained by `marketInfoResults`. If `marketInfoResults` is set to a very large value (via `setMarketInfoResults`, which lacks an upper bound check) and there are many markets, the loop can consume excessive gas, potentially exceeding the block gas limit. This can cause denial of service for users trying to retrieve market information and potentially for the owner trying to lower the limit."",
      ""Impact"": ""Potential for gas exhaustion leading to denial-of-service for read operations (`getMarketInfo`) and potentially preventing the owner from fixing the issue."",
      ""Location"": ""RCFactory.sol:getMarketInfo, RCFactory.sol:setMarketInfoResults""
    },
    {
      ""Issue"": ""Lack of Reentrancy Protection in Key Functions"",
      ""Severity"": ""High"",
      ""Description"": ""The contract lacks reentrancy protection (e.g., using a nonReentrant modifier) in critical functions that involve external calls and state changes, such as `createMarket`, `mintMarketNFT`, and `mintCopyOfNFT`. External calls to `IRCNftHubL2.mint()` or other dependencies could potentially call back into the `RCFactory`, leading to race conditions, inconsistent state, or potential exploits if the external contract is malicious or vulnerable."",
      ""Impact"": ""Potential for fund drain, market corruption, NFT minting issues, inconsistent state, and denial of service due to unexpected reentrant calls."",
      ""Location"": ""Functions `createMarket`, `mintMarketNFT`, `mintCopyOfNFT`""
    },
    {
      ""Issue"": ""Missing/Insufficient Input Validation in `createMarket` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `createMarket` function lacks sufficient input validation for several parameters. Specifically: 1) Array lengths for `_tokenURIs` and `_cardAffiliateAddresses` are checked with division (`_tokenURIs.length / 2`), which can be bypassed with odd lengths. The check also doesn't prevent providing only 1 URI. 2) The `_timestamps` array length is checked, but individual timestamp values are not validated against reasonable bounds (e.g., excessively far future values) and the check allows `marketLockingTime` and `oracleResolutionTime` to be equal. 3) The `_mode` parameter (uint32) is cast to `IRCMarket.Mode` without checking if the value corresponds to a valid enum member. 4) Zero address checks are missing for `_artistAddress`, `_affiliateAddress`, and elements within `_cardAffiliateAddresses`. 5) There's no check to ensure `referenceContractAddress` is initialized and operational before cloning."",
      ""Impact"": ""Potential for unexpected behavior, inconsistent market state, denial-of-service (DoS), incorrect market parameters, misdirection of funds (if zero addresses used unintentionally), or reverting market creation if inputs are malformed or dependencies invalid."",
      ""Location"": ""RCFactory.sol:625-630, RCFactory.sol: Line 697 (createMarket), Line 779 (_checkTimestamps), Function `createMarket`, Function `_checkTimestamps`, Location `createMarket`""
    },
    {
      ""Issue"": ""Insufficient Access Control on `setOrderbookAddress` and `setLeaderboardAddress`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `setOrderbookAddress` and `setLeaderboardAddress` use `treasury.checkPermission(TREASURY, msgSender())` for access control. This relies on the Treasury contract's permission system and allows any address with the `TREASURY` role to change these critical addresses. This might be overly permissive, as a compromised account with this role, or even the treasury contract itself (if vulnerable), could redirect these to malicious contracts. It's also architecturally questionable why the Treasury role, rather than an owner or specific governance role, controls these settings."",
      ""Impact"": ""Potential manipulation of orderbook or leaderboard data, front-running attacks, diversion of funds, disruption of system functionality if addresses are set maliciously by an entity with `TREASURY` permission."",
      ""Location"": ""RCFactory.sol:455, RCFactory.sol:468, RCFactory.sol: Line 609 (setOrderbookAddress), Line 622 (setLeaderboardAddress), Functions `setOrderbookAddress`, `setLeaderboardAddress`""
    },
    {
      ""Issue"": ""Input Validation and Logic Issues in `updateTokenURI`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `updateTokenURI` function has several issues: 1) It lacks validation for the `_cardId` input; a large value could cause `_cardId + _numberOfCards` to overflow, leading to incorrect index calculation. 2) The calculation `string[] memory _tokenURIs = new string[](_numberOfCards);` is incorrect; the array size should likely be `_numberOfCards * 2` to account for originals and copies. 3) The function recalculates `_tokenURIs` and `_timestamps` based on potentially outdated factory state (`tokenURIs[_market][i]`) solely to emit a `LogMarketCreated2` event; it does not actually update the token URIs on the target `IRCMarket` contract itself. 4) It lacks checks on the provided `_newTokenURI` and `_newCopyTokenURI` strings, allowing empty or malicious URIs."",
      ""Impact"": ""Incorrect `tokenURI` updates, data corruption, misleading event logs, failure to update actual market URIs, potential for phishing attacks if URIs point to malicious sites, incorrect data emitted in events affecting downstream consumers."",
      ""Location"": ""RCFactory.sol:501, RCFactory.sol:506, RCFactory.sol: Line 413 (updateTokenURI), Function `updateTokenURI`""
    },
    {
      ""Issue"": ""Missing Zero Address / Contract Checks"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions lack necessary checks for zero addresses or whether an address is a contract: 1) `setNftHubAddress` checks for zero address but not if `_newAddress` is a contract. 2) `setReferenceContractAddress` allows setting the address, but if it's later set to zero (e.g., via proxy admin), `createMarket` will fail ungracefully. 3) The `constructor` checks `_treasury` but not `_realitioAddress` or `_arbitratorAddress` for zero address."",
      ""Impact"": ""Contract might become unusable or exhibit unpredictable behavior if critical addresses are set to non-contract addresses or the zero address, leading to failed transactions and potential system disruption."",
      ""Location"": ""RCFactory.sol:446 (setNftHubAddress), RCFactory.sol: Line 572 (setReferenceContractAddress), Constructor""
    },
    {
      ""Issue"": ""Issues with Market Approval Logic (`changeMarketApproval`)"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `changeMarketApproval` function has several potential issues: 1) It allows unpausing a market via `treasury.unPauseMarket` without first checking if the market is already approved or paused, potentially leading to unexpected state or privilege escalation if misused by a governor. 2) It toggles approval status and immediately calls `treasury.unPauseMarket`. This assumes approval directly correlates with unpausing, and disapproval implicitly requires pausing (which isn't explicitly called). The dependency on the treasury's internal logic might lead to inconsistencies. 3) The state update `isMarketApproved[_market]` happens before the external call `treasury.unPauseMarket` and event emission. If the external call reverts, the state remains changed but the event isn't emitted, leading to inconsistency. 4) Potential front-running vulnerability exists where a malicious actor could anticipate an approval transaction."",
      ""Impact"": ""Inconsistent state between factory approval and treasury pause status, potential privilege escalation, manipulation of market availability through front-running, unexpected market behavior."",
      ""Location"": ""RCFactory.sol:389-393, Function `changeMarketApproval`""
    },
    {
      ""Issue"": ""Unprotected `setReferenceContractAddress` can lead to Denial of Service"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setReferenceContractAddress` function is only protected by `onlyUberOwner`. A compromised or malicious UberOwner could set this address to a non-contract or incompatible contract address. This would cause all subsequent calls to `createMarket` to fail during the cloning process, effectively halting new market creation."",
      ""Impact"": ""Denial of Service for market creation, potentially bricking a core functionality of the factory."",
      ""Location"": ""Function `setReferenceContractAddress`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `setPotDistribution`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setPotDistribution` function checks that the sum of distribution cuts (`_artistCut`, `_winnerCut`, etc.) does not exceed `PER_MILLE` (1000). However, it doesn't check individual cuts against `PER_MILLE` or protect against potential integer overflow if extremely large `uint256` values are provided for individual cuts. While unlikely, if the sum overflows it could wrap around and incorrectly pass the `<= PER_MILLE` check. There's also no explicit check preventing negative values (though uint prevents this) or considering underflow if these values are used in subtractions elsewhere."",
      ""Impact"": ""Incorrect pot distribution logic, potentially leading to unfair rewards, fund misallocation, or unexpected behavior in calculations using these values. Risk is low due to the sum check."",
      ""Location"": ""RCFactory.sol: Line 335 (setPotDistribution), Function `setPotDistribution`""
    },
    {
      ""Issue"": ""Lack of Access Control on Configuration Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions `changeMarketCreationGovernorsOnly`, `changeApprovedArtistsOnly`, and `changeApprovedAffilliatesOnly` modify core contract configurations and rely solely on the `onlyOwner` modifier. While secure against external users, assigning these critical settings to a single owner role might be too centralized. Consider introducing more granular, role-based access control (e.g., specific governance roles) for changing fundamental contract behaviors."",
      ""Impact"": ""Centralization risk; a single compromised owner account could maliciously alter core contract configurations. The immediate risk is low due to `onlyOwner` protection."",
      ""Location"": ""changeMarketCreationGovernorsOnly, changeApprovedArtistsOnly, changeApprovedAffilliatesOnly""
    },
    {
      ""Issue"": ""Race Condition in `mintMarketNFT`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `mintMarketNFT` function determines the new token ID based on `nfthub.totalSupply()`. If multiple `mintMarketNFT` transactions are processed within the same block (though typically serialized), they might read the same `totalSupply` value before any mint occurs, potentially leading to attempts to mint the same token ID, causing transaction reverts or collisions."",
      ""Impact"": ""Potential for failed minting transactions or NFT ID collisions, though unlikely under normal network conditions."",
      ""Location"": ""RCFactory.sol: `mintMarketNFT`""
    },
    {
      ""Issue"": ""Lack of Slippage Protection in Sponsorship"",
      ""Severity"": ""Low"",
      ""Description"": ""Within the `createMarket` function, the call `IRCMarket(_newAddress).sponsor()` might involve token transfers or DEX interactions. There is no mechanism to protect against price slippage during this operation. If the value of the sponsorship asset changes significantly between transaction initiation and execution, the effective sponsorship amount could be lower than intended."",
      ""Impact"": ""Potential loss of value during the sponsorship process due to market volatility, potentially leading to underfunded markets or unfair conditions."",
      ""Location"": ""Function `createMarket`""
    },
    {
      ""Issue"": ""Inconsistent usage of `msgSender()`"",
      ""Severity"": ""Info"",
      ""Description"": ""The contract inherits `NativeMetaTransaction` for meta-transaction support, which provides a `msgSender()` function to get the actual initiator. However, some functions use `msg.sender` directly while others use `msgSender()`. This inconsistency can lead to incorrect authorization checks or logic flaws when meta-transactions are used, as `msg.sender` would be the relayer, not the end-user."",
      ""Impact"": ""Potential for incorrect user authentication or authorization bypass when interactions occur via meta-transactions."",
      ""Location"": ""Multiple functions including but not limited to `createMarket`""
    }
  ],
  ""IssueNumber"": 45,
  ""OutputList"": 14
}",262.18598103523254,3812.0,32.0,"---

**[M-02] Parameter updates not propagated**

**Report Description**:
Several functions in the contract are designed to update parameters, but these updates are only applied at the top level and not propagated to other dependent contracts. This inconsistency can lead to unpredictable behavior and potential vulnerabilities. Examples include:
- `setNftHubAddress` in `RCFactory`
- `setOrderbookAddress` in `RCFactory`
- `setLeaderboardAddress` in `RCFactory`
- `setMinRental` in `RCTreasury`

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the issue of parameter updates not being propagated to other contracts. While some responses discuss access control and input validation (e.g., ""Insufficient Access Control on `setOrderbookAddress` and `setLeaderboardAddress`""), they do not cover the core problem of parameter propagation. This is a significant gap in the response list, as the issue could lead to inconsistent contract states and unpredictable behavior.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-02] Parameter updates not propagated**

---","```
None.
```",0.0
