nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
LiquidityPool.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;
pragma abicoder v2;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""../security/Pausable.sol"";
import ""./interfaces/IExecutorManager.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""../interfaces/IERC20Permit.sol"";
import ""./interfaces/ITokenManager.sol"";

contract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {
    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 private constant BASE_DIVISOR = 10000000000; // Basis Points * 100 for better accuracy

    uint256 public baseGas;

    IExecutorManager private executorManager;
    ITokenManager public tokenManager;
    ILiquidityProviders public liquidityProviders;

    struct PermitRequest {
        uint256 nonce;
        uint256 expiry;
        bool allowed;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    mapping(bytes32 => bool) public processedHash;
    mapping(address => uint256) public gasFeeAccumulatedByToken;

    // Gas fee accumulated by token address => executor address
    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;

    // Incentive Pool amount per token address
    mapping(address => uint256) public incentivePool;

    event AssetSent(
        address indexed asset,
        uint256 indexed amount,
        uint256 indexed transferredAmount,
        address target,
        bytes depositHash,
        uint256 fromChainId
    );
    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);
    event Received(address indexed from, uint256 indexed amount);
    event Deposit(
        address indexed from,
        address indexed tokenAddress,
        address indexed receiver,
        uint256 toChainId,
        uint256 amount,
        uint256 reward,
        string tag
    );
    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);
    event TrustedForwarderChanged(address indexed forwarderAddress);
    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);
    event EthReceived(address, uint256);

    // MODIFIERS
    modifier onlyExecutor() {
        require(executorManager.getExecutorStatus(_msgSender()), ""Only executor is allowed"");
        _;
    }

    modifier onlyLiquidityProviders() {
        require(_msgSender() == address(liquidityProviders), ""Only liquidityProviders is allowed"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, ""Token not supported"");
        _;
    }

    function initialize(
        address _executorManagerAddress,
        address _pauser,
        address _trustedForwarder,
        address _tokenManager,
        address _liquidityProviders
    ) public initializer {
        require(_executorManagerAddress != address(0), ""ExecutorManager cannot be 0x0"");
        require(_trustedForwarder != address(0), ""TrustedForwarder cannot be 0x0"");
        require(_liquidityProviders != address(0), ""LiquidityProviders cannot be 0x0"");
        __ERC2771Context_init(_trustedForwarder);
        __ReentrancyGuard_init();
        __Ownable_init();
        __Pausable_init(_pauser);
        executorManager = IExecutorManager(_executorManagerAddress);
        tokenManager = ITokenManager(_tokenManager);
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        baseGas = 21000;
    }

    function setTrustedForwarder(address trustedForwarder) public onlyOwner {
        require(trustedForwarder != address(0), ""TrustedForwarder can't be 0"");
        _trustedForwarder = trustedForwarder;
        emit TrustedForwarderChanged(trustedForwarder);
    }

    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {
        require(_liquidityProviders != address(0), ""LiquidityProviders can't be 0"");
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        emit LiquidityProvidersChanged(_liquidityProviders);
    }

    function setBaseGas(uint128 gas) external onlyOwner {
        baseGas = gas;
    }

    function getExecutorManager() public view returns (address) {
        return address(executorManager);
    }

    function setExecutorManager(address _executorManagerAddress) external onlyOwner {
        require(_executorManagerAddress != address(0), ""Executor Manager cannot be 0"");
        executorManager = IExecutorManager(_executorManagerAddress);
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {
        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);
        
        currentLiquidity =
            liquidityPoolBalance -
            liquidityProviders.totalLPFees(tokenAddress) -
            gasFeeAccumulatedByToken[tokenAddress] -
            incentivePool[tokenAddress];
    }

    /**
     * @dev Function used to deposit tokens into pool to initiate a cross chain token transfer.
     * @param toChainId Chain id where funds needs to be transfered
     * @param tokenAddress ERC20 Token address that needs to be transfered
     * @param receiver Address on toChainId where tokens needs to be transfered
     * @param amount Amount of token being transfered
     */
    function depositErc20(
        uint256 toChainId,
        address tokenAddress,
        address receiver,
        uint256 amount,
        string memory tag
    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&
                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(amount != 0, ""Amount cannot be 0"");
        address sender = _msgSender();

        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);
        if (rewardAmount != 0) {
            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);
        // Emit (amount + reward amount) in event
        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);
    }

    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);
        if (currentLiquidity < providedLiquidity) {
            uint256 liquidityDifference = providedLiquidity - currentLiquidity;
            if (amount >= liquidityDifference) {
                rewardAmount = incentivePool[tokenAddress];
            } else {
                // Multiply by 10000000000 to avoid 0 reward amount for small amount and liquidity difference
                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;
                rewardAmount = rewardAmount / 10000000000;
            }
        }
    }

    /**
     * DAI permit and Deposit.
     */
    function permitAndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            permitOptions.nonce,
            permitOptions.expiry,
            permitOptions.allowed,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    /**
     * EIP2612 and Deposit.
     */
    function permitEIP2612AndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            amount,
            permitOptions.expiry,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    /**
     * @dev Function used to deposit native token into pool to initiate a cross chain token transfer.
     * @param receiver Address on toChainId where tokens needs to be transfered
     * @param toChainId Chain id where funds needs to be transfered
     */
    function depositNative(
        address receiver,
        uint256 toChainId,
        string memory tag
    ) external payable whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&
                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(msg.value != 0, ""Amount cannot be 0"");

        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);
        if (rewardAmount != 0) {
            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);
        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);
    }

    function sendFundsToUser(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash,
        uint256 tokenGasPrice,
        uint256 fromChainId
    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {
        uint256 initialGas = gasleft();
        require(
            tokenManager.getTransferConfig(tokenAddress).min <= amount &&
                tokenManager.getTransferConfig(tokenAddress).max >= amount,
            ""Withdraw amnt not in Cap limits""
        );
        require(receiver != address(0), ""Bad receiver address"");

        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);

        require(!status, ""Already Processed"");
        processedHash[hashSendTransaction] = true;

        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);
        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);

        if (tokenAddress == NATIVE) {
            require(address(this).balance >= amountToTransfer, ""Not Enough Balance"");
            (bool success, ) = receiver.call{value: amountToTransfer}("""");
            require(success, ""Native Transfer Failed"");
        } else {
            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, ""Not Enough Balance"");
            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);
        }

        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);
    }

    /**
     * @dev Internal function to calculate amount of token that needs to be transfered afetr deducting all required fees.
     * Fee to be deducted includes gas fee, lp fee and incentive pool amount if needed.
     * @param initialGas Gas provided initially before any calculations began
     * @param tokenAddress Token address for which calculation needs to be done
     * @param amount Amount of token to be transfered before deducting the fee
     * @param tokenGasPrice Gas price in the token being transfered to be used to calculate gas fee
     * @return amountToTransfer Total amount to be transfered after deducting all fees.
     */
    function getAmountToTransfer(
        uint256 initialGas,
        address tokenAddress,
        uint256 amount,
        uint256 tokenGasPrice
    ) internal returns (uint256 amountToTransfer) {
        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);
        uint256 lpFee;
        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {
            // Here add some fee to incentive pool also
            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;
            incentivePool[tokenAddress] =
                (incentivePool[tokenAddress] +
                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /
                BASE_DIVISOR;
        } else {
            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;
        }
        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;

        liquidityProviders.addLPFee(tokenAddress, lpFee);

        uint256 totalGasUsed = initialGas - gasleft();
        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;
        totalGasUsed = totalGasUsed + baseGas;

        uint256 gasFee = totalGasUsed * tokenGasPrice;
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;
        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;
        amountToTransfer = amount - (transferFeeAmount + gasFee);

        emit FeeDetails(lpFee, transferFeeAmount, gasFee);
    }

    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);

        uint256 resultingLiquidity = currentLiquidity - amount;

        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;
        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;
        // Fee is represented in basis points * 10 for better accuracy
        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; // F(max) * F(e) * L(e)
        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; // F(e) * L(e) + (F(max) - F(e)) * L(r)

        if (denominator == 0) {
            fee = 0;
        } else {
            fee = numerator / denominator;
        }
    }

    function checkHashStatus(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash
    ) public view returns (bytes32 hashSendTransaction, bool status) {
        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));

        status = processedHash[hashSendTransaction];
    }

    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {
        require(tokenAddress != NATIVE, ""Can't withdraw native token fee"");
        // uint256 gasFeeAccumulated = gasFeeAccumulatedByToken[tokenAddress];
        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;
        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;
        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);
        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);
    }

    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {
        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;
        gasFeeAccumulated[NATIVE][_msgSender()] = 0;
        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}("""");
        require(success, ""Native Transfer Failed"");

        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);
    }

    function transfer(
        address _tokenAddress,
        address receiver,
        uint256 _tokenAmount
    ) external whenNotPaused onlyLiquidityProviders nonReentrant {
        require(receiver != address(0), ""Invalid receiver"");
        if (_tokenAddress == NATIVE) {
            require(address(this).balance >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            (bool success, ) = receiver.call{value: _tokenAmount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);
            require(baseToken.balanceOf(address(this)) >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);
        }
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",4025,434,"[H-01] Can deposit native token for free and steal funds

Submitted by cmichel, also found by CertoraInc
LiquidityPool.sol#L151
The depositErc20 function allows setting tokenAddress = NATIVE and does not throw an error. No matter the amount chosen, the SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount); call will not revert because it performs a low-level call to NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, which is an EOA, and the low-level calls to EOAs always succeed. Because the safe* version is used, the EOA not returning any data does not revert either.
This allows an attacker to deposit infinite native tokens by not paying anything. The contract will emit the same Deposit event as a real depositNative call and the attacker receives the native funds on the other chain.
  [H-03] Wrong formula when add fee incentivePool can lead to loss of funds.

Submitted by minhquanym, also found by cmichel, hickuphh3, and WatchPug
LiquidityPool.sol#L319-L322
The `getAmountToTransfer` function of LiquidityPool updates incentivePool[tokenAddress] by adding some fee to it but the formula is wrong and the value of incentivePool[tokenAddress] will be divided by BASE_DIVISOR (10000000000) each time. After just a few time, the value of incentivePool[tokenAddress] will become zero and that amount of tokenAddress token will be locked in contract.
  [M-08] Incentive Pool can be drained without rebalancing the pool

Submitted by kyliek, also found by Ruhum and WatchPug
LiquidityPool.sol#L149-L173 LiquidityPool.sol#L263-L277
`depositErc20()` allows an attacker to specify the destination chain to be the same as the source chain and the receiver account to be the same as the caller account. This enables an attacker to drain the incentive pool without rebalancing the pool back to the equilibrium state.
  [M-18] Possible frontrun on `deposits` on LiquidityPool

Submitted by Cantor_Dust, also found by WatchPug
Rewards are given to a user for depositing either ERC20 tokens or their native token into the LiquidityPool. This reward is used to incentivize users to deposit funds into the liquidity pool when the pool is not in an equilibrium state.
For regular users, this liquidity pool state fluctuates based on the frequency and amount of deposits made to the liquidity pool. If a malicious user can control the state of the liquidity pool before a victim deposits tokens into the liquidity pool, they can gain double rewards.
To gain these double rewards, a malicious user can watch the mempool for transactions that will receive a reward when the deposit occurs. When a malicious user sees that victim deposit, the malicious user can attach a higher fee to their transaction and initiate a deposit. This will allow the malicious user's transaction to front-run before the victim's transaction.
",4,,"pragma solidity 0.8.0;
pragma abicoder v2;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""../security/Pausable.sol"";
import ""./interfaces/IExecutorManager.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""../interfaces/IERC20Permit.sol"";
import ""./interfaces/ITokenManager.sol"";

contract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {
    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 private constant BASE_DIVISOR = 10000000000; 

    uint256 public baseGas;

    IExecutorManager private executorManager;
    ITokenManager public tokenManager;
    ILiquidityProviders public liquidityProviders;

    struct PermitRequest {
        uint256 nonce;
        uint256 expiry;
        bool allowed;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    mapping(bytes32 => bool) public processedHash;
    mapping(address => uint256) public gasFeeAccumulatedByToken;

    
    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;

    
    mapping(address => uint256) public incentivePool;

    event AssetSent(
        address indexed asset,
        uint256 indexed amount,
        uint256 indexed transferredAmount,
        address target,
        bytes depositHash,
        uint256 fromChainId
    );
    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);
    event Received(address indexed from, uint256 indexed amount);
    event Deposit(
        address indexed from,
        address indexed tokenAddress,
        address indexed receiver,
        uint256 toChainId,
        uint256 amount,
        uint256 reward,
        string tag
    );
    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);
    event TrustedForwarderChanged(address indexed forwarderAddress);
    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);
    event EthReceived(address, uint256);

    
    modifier onlyExecutor() {
        require(executorManager.getExecutorStatus(_msgSender()), ""Only executor is allowed"");
        _;
    }

    modifier onlyLiquidityProviders() {
        require(_msgSender() == address(liquidityProviders), ""Only liquidityProviders is allowed"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, ""Token not supported"");
        _;
    }

    function initialize(
        address _executorManagerAddress,
        address _pauser,
        address _trustedForwarder,
        address _tokenManager,
        address _liquidityProviders
    ) public initializer {
        require(_executorManagerAddress != address(0), ""ExecutorManager cannot be 0x0"");
        require(_trustedForwarder != address(0), ""TrustedForwarder cannot be 0x0"");
        require(_liquidityProviders != address(0), ""LiquidityProviders cannot be 0x0"");
        __ERC2771Context_init(_trustedForwarder);
        __ReentrancyGuard_init();
        __Ownable_init();
        __Pausable_init(_pauser);
        executorManager = IExecutorManager(_executorManagerAddress);
        tokenManager = ITokenManager(_tokenManager);
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        baseGas = 21000;
    }

    function setTrustedForwarder(address trustedForwarder) public onlyOwner {
        require(trustedForwarder != address(0), ""TrustedForwarder can't be 0"");
        _trustedForwarder = trustedForwarder;
        emit TrustedForwarderChanged(trustedForwarder);
    }

    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {
        require(_liquidityProviders != address(0), ""LiquidityProviders can't be 0"");
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        emit LiquidityProvidersChanged(_liquidityProviders);
    }

    function setBaseGas(uint128 gas) external onlyOwner {
        baseGas = gas;
    }

    function getExecutorManager() public view returns (address) {
        return address(executorManager);
    }

    function setExecutorManager(address _executorManagerAddress) external onlyOwner {
        require(_executorManagerAddress != address(0), ""Executor Manager cannot be 0"");
        executorManager = IExecutorManager(_executorManagerAddress);
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {
        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);
        
        currentLiquidity =
            liquidityPoolBalance -
            liquidityProviders.totalLPFees(tokenAddress) -
            gasFeeAccumulatedByToken[tokenAddress] -
            incentivePool[tokenAddress];
    }

    
    function depositErc20(
        uint256 toChainId,
        address tokenAddress,
        address receiver,
        uint256 amount,
        string memory tag
    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&
                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(amount != 0, ""Amount cannot be 0"");
        address sender = _msgSender();

        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);
        if (rewardAmount != 0) {
            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);
        
        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);
    }

    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);
        if (currentLiquidity < providedLiquidity) {
            uint256 liquidityDifference = providedLiquidity - currentLiquidity;
            if (amount >= liquidityDifference) {
                rewardAmount = incentivePool[tokenAddress];
            } else {
                
                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;
                rewardAmount = rewardAmount / 10000000000;
            }
        }
    }

    
    function permitAndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            permitOptions.nonce,
            permitOptions.expiry,
            permitOptions.allowed,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    
    function permitEIP2612AndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            amount,
            permitOptions.expiry,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    
    function depositNative(
        address receiver,
        uint256 toChainId,
        string memory tag
    ) external payable whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&
                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(msg.value != 0, ""Amount cannot be 0"");

        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);
        if (rewardAmount != 0) {
            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);
        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);
    }

    function sendFundsToUser(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash,
        uint256 tokenGasPrice,
        uint256 fromChainId
    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {
        uint256 initialGas = gasleft();
        require(
            tokenManager.getTransferConfig(tokenAddress).min <= amount &&
                tokenManager.getTransferConfig(tokenAddress).max >= amount,
            ""Withdraw amnt not in Cap limits""
        );
        require(receiver != address(0), ""Bad receiver address"");

        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);

        require(!status, ""Already Processed"");
        processedHash[hashSendTransaction] = true;

        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);
        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);

        if (tokenAddress == NATIVE) {
            require(address(this).balance >= amountToTransfer, ""Not Enough Balance"");
            (bool success, ) = receiver.call{value: amountToTransfer}("""");
            require(success, ""Native Transfer Failed"");
        } else {
            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, ""Not Enough Balance"");
            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);
        }

        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);
    }

    
    function getAmountToTransfer(
        uint256 initialGas,
        address tokenAddress,
        uint256 amount,
        uint256 tokenGasPrice
    ) internal returns (uint256 amountToTransfer) {
        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);
        uint256 lpFee;
        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {
            
            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;
            incentivePool[tokenAddress] =
                (incentivePool[tokenAddress] +
                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /
                BASE_DIVISOR;
        } else {
            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;
        }
        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;

        liquidityProviders.addLPFee(tokenAddress, lpFee);

        uint256 totalGasUsed = initialGas - gasleft();
        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;
        totalGasUsed = totalGasUsed + baseGas;

        uint256 gasFee = totalGasUsed * tokenGasPrice;
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;
        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;
        amountToTransfer = amount - (transferFeeAmount + gasFee);

        emit FeeDetails(lpFee, transferFeeAmount, gasFee);
    }

    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);

        uint256 resultingLiquidity = currentLiquidity - amount;

        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;
        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;
        
        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; 
        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; 

        if (denominator == 0) {
            fee = 0;
        } else {
            fee = numerator / denominator;
        }
    }

    function checkHashStatus(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash
    ) public view returns (bytes32 hashSendTransaction, bool status) {
        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));

        status = processedHash[hashSendTransaction];
    }

    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {
        require(tokenAddress != NATIVE, ""Can't withdraw native token fee"");
        
        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;
        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;
        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);
        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);
    }

    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {
        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;
        gasFeeAccumulated[NATIVE][_msgSender()] = 0;
        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}("""");
        require(success, ""Native Transfer Failed"");

        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);
    }

    function transfer(
        address _tokenAddress,
        address receiver,
        uint256 _tokenAmount
    ) external whenNotPaused onlyLiquidityProviders nonReentrant {
        require(receiver != address(0), ""Invalid receiver"");
        if (_tokenAddress == NATIVE) {
            require(address(this).balance >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            (bool success, ) = receiver.call{value: _tokenAmount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);
            require(baseToken.balanceOf(address(this)) >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);
        }
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",3573,2,2,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only the owner can call functions protected by the `onlyOwner` modifier."",
        ""Confirm the `executorManager` contract correctly manages executor status and that the `onlyExecutor` modifier functions as intended."",
        ""Ensure the `liquidityProviders` address is correctly set and that the `onlyLiquidityProviders` modifier prevents unauthorized access to restricted functions."",
        ""Review the `Pausable` contract integration and confirm the owner can pause and unpause the contract correctly."",
        ""Verify that the `setTrustedForwarder`, `setLiquidityProviders`, `setBaseGas`, and `setExecutorManager` functions can only be called by the contract owner and function as intended.""
      ]
    },
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Analyze all external calls for potential reentrancy issues, paying close attention to the `sendFundsToUser`, `withdrawErc20GasFee`, `withdrawNativeGasFee`, and `transfer` functions."",
        ""Confirm that the `nonReentrant` modifier adequately protects all critical state changes, particularly those involving token transfers and balance updates."",
        ""Simulate reentrancy attacks on the `sendFundsToUser` function to ensure that `processedHash` is updated before any external calls are made.""
      ]
    },
    {
      ""Area"": ""Arithmetic Over/Underflows"",
      ""Tasks"": [
        ""Examine all arithmetic operations, especially those involving user-supplied inputs, for potential overflows and underflows. Consider using SafeMath or similar libraries, even in 0.8.0, for added clarity."",
        ""Analyze the `getRewardAmount` function for potential overflow issues when calculating `rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference / 10000000000;` if `amount` and `incentivePool` are large."",
        ""Review the fee calculation logic in `getAmountToTransfer` and `getTransferFee` to ensure that intermediate calculations do not overflow or underflow.""
      ]
    },
    {
      ""Area"": ""Token Handling and Balances"",
      ""Tasks"": [
        ""Verify that the contract correctly handles ERC20 token transfers using `SafeERC20Upgradeable.safeTransfer` and `SafeERC20Upgradeable.safeTransferFrom`."",
        ""Ensure that the contract has sufficient balance before transferring tokens or native currency in the `sendFundsToUser` and `transfer` functions."",
        ""Check for potential rounding errors or precision loss in fee calculations that could lead to discrepancies in token balances."",
        ""Verify that `getCurrentLiquidity` accurately reflects the available liquidity by correctly subtracting fees and incentives."",
        ""Ensure that deposits using `permitAndDepositErc20` and `permitEIP2612AndDepositErc20` are properly validated and that the permit signatures are correctly verified.""
      ]
    },
    {
      ""Area"": ""Fee Calculation and Incentive Logic"",
      ""Tasks"": [
        ""Carefully review the fee calculation logic in `getTransferFee` to ensure that the dynamic fee is calculated correctly based on current and supplied liquidity."",
        ""Analyze the `getAmountToTransfer` function to verify the correctness of LP fee, transfer fee, and gas fee calculations, and ensure that the correct amount is transferred to the user."",
         ""Verify that the logic for adding excess fees to the `incentivePool` in `getAmountToTransfer` is accurate and does not lead to unintended consequences. Specifically: Confirm that only the `excess_fee_amount` is divided by `BASE_DIVISOR` before being added to `incentivePool`."",
        ""Confirm that the deposit incentive logic in `getRewardAmount` functions as intended and that the reward amount is calculated fairly based on the liquidity difference."",
        ""Check if front-running is possible to manipulate the `getTransferFee` function by making a large deposit just before a transfer.""
      ]
    },
    {
      ""Area"": ""Replay Protection"",
      ""Tasks"": [
        ""Verify that the `checkHashStatus` function and the `processedHash` mapping effectively prevent replay attacks on the `sendFundsToUser` function."",
        ""Analyze the `checkHashStatus` function to ensure that the hash is generated using all relevant parameters and that it is unique for each transfer."",
        ""Investigate potential vulnerabilities in the replay protection mechanism, such as hash collisions or manipulation of the `depositHash`.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify areas in the code where gas usage can be optimized, such as reducing redundant calculations or using more efficient data structures."",
        ""Analyze the gas cost of the `getTransferFee` function and explore potential optimizations to reduce its complexity."",
        ""Review the use of `gasleft()` in `getAmountToTransfer` and ensure that it accurately reflects the gas used by the transaction."",
        ""Evaluate the storage patterns for `gasFeeAccumulatedByToken`, `gasFeeAccumulated`, and `incentivePool` and consider optimizations such as using transient storage or more efficient data structures."",
        ""Evaluate whether loop unrolling would provide gas savings.""
      ]
    },
    {
      ""Area"": ""External Contract Interactions"",
      ""Tasks"": [
        ""Audit all interactions with external contracts (IExecutorManager, ITokenManager, ILiquidityProviders, IERC20Upgradeable, IERC20Permit) to ensure that they are secure and function as expected."",
        ""Verify that the contract correctly handles errors or unexpected responses from external contracts."",
        ""Assess the trust assumptions associated with each external contract and identify potential risks if any of these contracts are compromised."",
        ""Specifically audit the `transfer` function and ensure the call from `liquidityProviders` is indeed a trusted source. Understand the full range of actions that `liquidityProviders` can take."",
        ""Review all interactions with the `tokenManager` contract and ensure that the token configurations (fees, limits, support status) are properly validated and used."",
        ""Verify the integrity of `depositHash`. How is it generated on the other chain and passed to this contract?""
      ]
    },
     {
      ""Area"": ""Meta-Transaction Support (ERC2771)"",
      ""Tasks"": [
        ""Verify the correct implementation of the ERC2771ContextUpgradeable contract for meta-transaction support."",
        ""Ensure that the trusted forwarder is correctly configured and that only the trusted forwarder can relay meta-transactions."",
        ""Assess the security implications of using a trusted forwarder and identify potential risks if the forwarder is compromised.""
      ]
    },
    {
      ""Area"": ""Upgradeability"",
      ""Tasks"": [
        ""Verify the correct usage of OpenZeppelin Upgradeable libraries and the initializer pattern."",
        ""Ensure that the `initialize` function can only be called once and that all necessary state variables are initialized correctly."",
        ""Assess the impact of potential upgrades on the contract's functionality and security."",
        ""Review the storage layout of the contract and ensure that it is compatible with future upgrades.""
      ]
    },
    {
      ""Area"": ""Error Handling and Logging"",
      ""Tasks"": [
        ""Review all require statements and ensure that they provide informative error messages to the user."",
        ""Check that all important events are emitted and that they contain relevant information for debugging and auditing."",
        ""Ensure that error messages are consistent throughout the contract (e.g., use of custom ERR__* strings)."",
        ""Assess the impact of reverts on gas refunds and ensure that the contract does not unintentionally consume excessive gas due to reverts.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `LiquidityPool` serves as a central hub for managing liquidity used in cross-chain asset transfers. It allows users to deposit ERC20 tokens or native currency (ETH), which are then held in the contract. Authorized 'Executors' can trigger the sending of these assets to users on a destination chain, deducting calculated fees (LP fee, transfer fee, gas fee). The contract includes mechanisms for dynamic fee calculation based on liquidity, incentives for deposits when liquidity is low, replay protection for outgoing transfers, meta-transaction support (ERC2771), pausing functionality, and owner-controlled configuration. It interacts heavily with external contracts for managing executors, token information, and liquidity provider data."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""LiquidityPool"",
    ""Purpose"": ""To manage liquidity for cross-chain asset transfers, handle deposits, facilitate withdrawals by executors, calculate and distribute fees, and provide deposit incentives."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""ReentrancyGuardUpgradeable"",
        ""Pausable"",
        ""OwnableUpgradeable"",
        ""ERC2771ContextUpgradeable""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"",
        ""./metatx/ERC2771ContextUpgradeable.sol"",
        ""../security/Pausable.sol"",
        ""./interfaces/IExecutorManager.sol"",
        ""./interfaces/ILiquidityProviders.sol"",
        ""../interfaces/IERC20Permit.sol"",
        ""./interfaces/ITokenManager.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""NATIVE"",
        ""Type"": ""address"",
        ""Purpose"": ""Constant representing the address for native currency (ETH).""
      },
      {
        ""Name"": ""BASE_DIVISOR"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Constant used as a divisor for percentage calculations (1e10).""
      },
      {
        ""Name"": ""baseGas"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Base gas amount added to gas fee calculations for transfers.""
      },
      {
        ""Name"": ""executorManager"",
        ""Type"": ""IExecutorManager"",
        ""Purpose"": ""Interface to the contract managing authorized executors.""
      },
      {
        ""Name"": ""tokenManager"",
        ""Type"": ""ITokenManager"",
        ""Purpose"": ""Interface to the contract managing supported tokens and their configurations (fees, limits).""
      },
      {
        ""Name"": ""liquidityProviders"",
        ""Type"": ""ILiquidityProviders"",
        ""Purpose"": ""Interface to the contract managing liquidity provider data (balances, fees).""
      },
      {
        ""Name"": ""PermitRequest"",
        ""Type"": ""struct"",
        ""Purpose"": ""Structure to hold parameters for ERC20 permit functions.""
      },
      {
        ""Name"": ""processedHash"",
        ""Type"": ""mapping(bytes32 => bool)"",
        ""Purpose"": ""Tracks processed `sendFundsToUser` transactions to prevent replays.""
      },
      {
        ""Name"": ""gasFeeAccumulatedByToken"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks the total accumulated gas fees per token, deducted from available liquidity.""
      },
      {
        ""Name"": ""gasFeeAccumulated"",
        ""Type"": ""mapping(address => mapping(address => uint256))"",
        ""Purpose"": ""Tracks accumulated gas fees per token, claimable by each executor.""
      },
      {
        ""Name"": ""incentivePool"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks funds allocated as incentives for deposits per token.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyExecutor"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to addresses recognized as executors by `executorManager`."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyLiquidityProviders"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the `liquidityProviders` contract address."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""tokenChecks"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Checks if a token address is valid (non-zero) and supported by `tokenManager`."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract state (for upgradeable proxy pattern). Sets managers, pauser, forwarder, and initial baseGas."",
        ""Parameters"": [""address _executorManagerAddress"", ""address _pauser"", ""address _trustedForwarder"", ""address _tokenManager"", ""address _liquidityProviders""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTrustedForwarder"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the trusted forwarder address (Ownable)."",
        ""Parameters"": [""address trustedForwarder""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLiquidityProviders"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the `liquidityProviders` contract address (Ownable)."",
        ""Parameters"": [""address _liquidityProviders""],
        ""Returns"": []
      },
      {
        ""Name"": ""setBaseGas"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the `baseGas` value used in fee calculations (Ownable)."",
        ""Parameters"": [""uint128 gas""],
        ""Returns"": []
      },
      {
        ""Name"": ""getExecutorManager"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the address of the current `executorManager` contract."",
        ""Parameters"": [],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""setExecutorManager"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the `executorManager` contract address (Ownable)."",
        ""Parameters"": [""address _executorManagerAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""getCurrentLiquidity"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates the currently available liquidity for a token, subtracting fees and incentives."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": [""uint256 currentLiquidity""]
      },
      {
        ""Name"": ""depositErc20"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Handles user deposits of ERC20 tokens. Validates amounts, calculates potential rewards, updates liquidity, transfers tokens in."",
        ""Parameters"": [""uint256 toChainId"", ""address tokenAddress"", ""address receiver"", ""uint256 amount"", ""string memory tag""],
        ""Returns"": []
      },
      {
        ""Name"": ""getRewardAmount"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates the incentive reward for a deposit based on current vs supplied liquidity."",
        ""Parameters"": [""uint256 amount"", ""address tokenAddress""],
        ""Returns"": [""uint256 rewardAmount""]
      },
      {
        ""Name"": ""permitAndDepositErc20"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows depositing ERC20 tokens using a provided permit signature (non-EIP2612 style)."",
        ""Parameters"": [""address tokenAddress"", ""address receiver"", ""uint256 amount"", ""uint256 toChainId"", ""PermitRequest calldata permitOptions"", ""string memory tag""],
        ""Returns"": []
      },
      {
        ""Name"": ""permitEIP2612AndDepositErc20"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows depositing ERC20 tokens using a provided EIP2612 permit signature."",
        ""Parameters"": [""address tokenAddress"", ""address receiver"", ""uint256 amount"", ""uint256 toChainId"", ""PermitRequest calldata permitOptions"", ""string memory tag""],
        ""Returns"": []
      },
      {
        ""Name"": ""depositNative"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Handles user deposits of native currency (ETH). Validates amounts, calculates rewards, updates liquidity."",
        ""Parameters"": [""address receiver"", ""uint256 toChainId"", ""string memory tag""],
        ""Returns"": []
      },
      {
        ""Name"": ""sendFundsToUser"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by executors to send funds to the user on the destination chain. Checks authorization, prevents replays, calculates fees, updates liquidity, transfers funds out."",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount"", ""address payable receiver"", ""bytes memory depositHash"", ""uint256 tokenGasPrice"", ""uint256 fromChainId""],
        ""Returns"": []
      },
      {
        ""Name"": ""getAmountToTransfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates LP fee, transfer fee, and gas fee, determines the net amount to transfer to the user, and updates fee/incentive state."",
        ""Parameters"": [""uint256 initialGas"", ""address tokenAddress"", ""uint256 amount"", ""uint256 tokenGasPrice""],
        ""Returns"": [""uint256 amountToTransfer""]
      },
      {
        ""Name"": ""getTransferFee"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates the dynamic transfer fee percentage based on current vs supplied liquidity and token config."",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount""],
        ""Returns"": [""uint256 fee""]
      },
      {
        ""Name"": ""checkHashStatus"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Checks if a transfer corresponding to a specific deposit hash has already been processed."",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount"", ""address payable receiver"", ""bytes memory depositHash""],
        ""Returns"": [""bytes32 hashSendTransaction"", ""bool status""]
      },
      {
        ""Name"": ""withdrawErc20GasFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows an executor to withdraw their accumulated gas fees for a specific ERC20 token."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawNativeGasFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows an executor to withdraw their accumulated gas fees for native currency (ETH)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""transfer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the `liquidityProviders` contract to transfer funds out of this pool (likely for LP withdrawals or rebalancing)."",
        ""Parameters"": [""address _tokenAddress"", ""address receiver"", ""uint256 _tokenAmount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_msgSender"",
        ""Visibility"": ""internal view virtual override"",
        ""Purpose"": ""Returns the message sender, supporting ERC2771 meta-transactions."",
        ""Parameters"": [],
        ""Returns"": [""address sender""]
      },
      {
        ""Name"": ""_msgData"",
        ""Visibility"": ""internal view virtual override"",
        ""Purpose"": ""Returns the message data, supporting ERC2771 meta-transactions."",
        ""Parameters"": [],
        ""Returns"": [""bytes calldata""]
      },
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Fallback function to receive native Ether."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IExecutorManager: Calls `getExecutorStatus` to verify executors."",
    ""ITokenManager: Calls `getTokensInfo`, `getDepositConfig`, `getTransferConfig` to fetch token parameters (fees, limits, support status, overhead)."",
    ""ILiquidityProviders: Calls `getCurrentLiquidity`, `totalLPFees`, `increaseCurrentLiquidity`, `decreaseCurrentLiquidity`, `addLPFee`, `getSuppliedLiquidityByToken` to interact with LP data."",
    ""IERC20Upgradeable / SafeERC20Upgradeable: Calls `safeTransferFrom`, `safeTransfer`, `balanceOf` for ERC20 token movements."",
    ""IERC20Permit: Calls `permit` (both standard and EIP2612 variations) to enable gasless token approvals."",
    ""Trusted Forwarder (via ERC2771ContextUpgradeable): Relies on a trusted forwarder contract to enable meta-transactions by verifying signatures and relaying calls."",
    ""Native ETH Transfer: Uses low-level `call{value: ...}` to send ETH.""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable Contract: Uses OpenZeppelin Upgradeable libraries and initializer pattern."",
    ""ERC2771 Meta-transactions: Supports gasless transactions via a trusted forwarder."",
    ""Reentrancy Guard: Protects key state-changing functions."",
    ""Pausable: Allows pausing/unpausing critical operations."",
    ""Ownable: Administrative functions are restricted to the owner."",
    ""Dynamic Fee Calculation: Transfer fees adjust based on liquidity utilization."",
    ""Deposit Incentives: Rewards users for depositing when liquidity is below target levels."",
    ""Replay Protection: Uses `processedHash` mapping to prevent double-spending in `sendFundsToUser`."",
    ""Permit Support: Integrates with ERC20 permit standards (including EIP2612) for improved UX."",
    ""Interface-Based Design: Interacts with core logic (tokens, LPs, executors) through interfaces, promoting modularity.""
  ],
  ""Questions"": [
    ""In `getAmountToTransfer`, the calculation adding excess fees to `incentivePool` seems to divide the entire sum (`incentivePool[tokenAddress] + excess_fee_amount`) by `BASE_DIVISOR`. Shouldn't only the `excess_fee_amount` be divided before adding it to the pool? `incentivePool[tokenAddress] = incentivePool[tokenAddress] + ((amount * (transferFeePerc - equilibriumFee)) / BASE_DIVISOR)` appears more correct."",
    ""In `getRewardAmount`, the calculation involves multiplying by `BASE_DIVISOR` and then dividing by it later: `(amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference / 10000000000;`. Is this purely for maintaining precision during the intermediate division by `liquidityDifference`? Could the intermediate multiplication result in overflow if `amount` and `incentivePool` are large?"",
    ""How is the `tokenGasPrice` parameter in `sendFundsToUser` determined and validated? Is it provided by the executor, and if so, how is it prevented from being manipulated?"",
    ""How is the uniqueness and origin of `depositHash` ensured? It's used in `checkHashStatus` for replay protection."",
    ""What is the specific mechanism and trust assumption behind the `liquidityProviders` contract calling the `transfer` function?"",
    ""Gas calculation in `getAmountToTransfer` relies on `gasleft()` difference plus `baseGas` and `transferOverhead`. How robust is this against EVM changes or varying execution costs? How are `baseGas` and `transferOverhead` kept accurate?"",
    ""Error message consistency could be improved (e.g., mix of custom `ERR__*` and plain strings).""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy vulnerability in `withdrawNativeGasFee`"",
      ""Severity"": ""High"",
      ""Description"": ""The `withdrawNativeGasFee` function transfers native tokens to the executor using a `call` without limiting gas, potentially leading to a reentrancy attack if the receiver is a malicious contract. While a reentrancy guard is in place, it only prevents reentrancy within this contract, allowing a malicious contract to re-enter another function in the system that relies on updated state before the external transfer returns, potentially draining more funds than intended."",
      ""Impact"": ""Potential for attackers to drain the contract's native token balance."",
      ""Location"": ""LiquidityPool.sol:353, withdrawNativeGasFee, LiquidityPool.sol#412""
    },
    {
      ""Issue"": ""Missing Access Control on `transfer` function"",
      ""Severity"": ""High"",
      ""Description"": ""The `transfer` function, which allows moving tokens out of the contract, is only protected by the `onlyLiquidityProviders` modifier, lacking validation on the receiver address or the amount being transferred. This means that if the `liquidityProviders` address is compromised, an attacker could drain the contract of all tokens, regardless of any other constraints normally enforced by other functions. Also, the function `transfer` transfers out entire tokenAmount and there is no consideration for fees."",
      ""Impact"": ""Complete drain of contract funds possible if the `liquidityProviders` address is compromised."",
      ""Location"": ""transfer""
    },
    {
      ""Issue"": ""Potential Reentrancy in `sendFundsToUser` due to untrusted receiver"",
      ""Severity"": ""High"",
      ""Description"": ""The `sendFundsToUser` function transfers funds to the receiver using `receiver.call{value: amountToTransfer}(\"" \"")` for native tokens. If the receiver is a malicious contract, this call can trigger a reentrancy attack, potentially allowing the attacker to call back into the `LiquidityPool` contract before the state is updated. This is partially mitigated by the `nonReentrant` modifier, but if the reentrant call is made through a different, trusted contract, the modifier is bypassed."",
      ""Impact"": ""An attacker could potentially drain funds from the contract by repeatedly withdrawing assets before the original withdrawal is marked as processed."",
      ""Location"": ""LiquidityPool.sol:244, LiquidityPool.sol:242, LiquidityPool.sol:sendFundsToUser""
    },
    {
      ""Issue"": ""Incorrect calculation of rewardAmount and Incentive Pool Management"",
      ""Severity"": ""High"",
      ""Description"": ""The calculation of the reward amount within the `getRewardAmount` function contains a multiplication by `10000000000` followed by a division by the same number which has no effect and can be removed to save gas. However, the more concerning aspect is that in the `else` condition, `rewardAmount` is calculated using integer division which can lead to unexpected truncation of reward values and users might receive less reward than intended, potentially discouraging deposits. In `depositErc20` and `depositNative`, the code subtracts `rewardAmount` from `incentivePool[tokenAddress]` *before* the deposit is actually completed and verified."",
      ""Impact"": ""Inaccurate reward calculations lead to users receiving less reward than intended, potential loss of funds due to precision loss, discouraged liquidity deposits. Loss of incentive funds. If the initial transfer fails, the reward is lost."",
      ""Location"": ""getRewardAmount, LiquidityPool.sol:156, LiquidityPool.sol:210""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `permitAndDepositErc20` and `permitEIP2612AndDepositErc20`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `permitAndDepositErc20` and `permitEIP2612AndDepositErc20` functions allow users to approve tokens for deposit using the ERC20 permit functionality. However, there\'s a front-running vulnerability. An attacker could observe a pending `permit` transaction and submit their own transaction with the same permit parameters but a higher `amount` or a different `receiver`. Since the `permit` function only approves the spender (this contract) and doesn\'t enforce specific amounts or receivers, the attacker\'s transaction could be executed using the user\'s signature, leading to unauthorized token transfers."",
      ""Impact"": ""An attacker can steal tokens from a user by front-running their `permit` transaction and using the approved allowance to deposit tokens to an address they control."",
      ""Location"": ""Functions: `permitAndDepositErc20`, `permitEIP2612AndDepositErc20`""
    },
    {
      ""Issue"": ""Missing check for `incentivePool[tokenAddress]` to be greater than `rewardAmount` in `depositErc20` and `depositNative` and Incorrect Incentive Calculation in `getRewardAmount`"",
      ""Severity"": ""Medium"",
      ""Description"": ""Before subtracting `rewardAmount` from `incentivePool[tokenAddress]` in both `depositErc20` and `depositNative` functions, there is no check to ensure that `incentivePool[tokenAddress]` is greater than or equal to `rewardAmount`. If `rewardAmount` is greater than `incentivePool[tokenAddress]`, it will result in underflow. In `getRewardAmount`, if `currentLiquidity < providedLiquidity`, there's a potential rounding error causing the reward amount to be significantly lower than expected due to integer division. If `rewardAmount` is greater than `incentivePool[tokenAddress]`, `incentivePool[tokenAddress]` will underflow."",
      ""Impact"": ""Underflow, leading to incorrect state updates and potential unexpected behavior. Inaccurate rewards for users, potentially discouraging deposits and loss of value. Potential integer overflow."",
      ""Location"": ""LiquidityPool.sol:150, LiquidityPool.sol:226, LiquidityPool.sol:160, LiquidityPool.sol:150, LiquidityPool.sol:226""
    },
    {
      ""Issue"": ""Lack of Access Control for `withdrawNativeGasFee` and `withdrawErc20GasFee`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `withdrawNativeGasFee` and `withdrawErc20GasFee` are only protected by the `onlyExecutor` modifier. This means that only executors can withdraw gas fees. However, it does not prevent an executor from withdrawing gas fees accumulated by *other* executors.  Ideally, there should be an additional layer of control, such as limiting withdrawals to a maximum amount per period or requiring a multi-signature approval for larger withdrawals, to mitigate the risk of unauthorized or excessive withdrawals by a compromised executor."",
      ""Impact"": ""Executors can steal gas fees accumulated by other executors, leading to unfair distribution of rewards."",
      ""Location"": ""LiquidityPool.sol:330, LiquidityPool.sol:316, Functions: `withdrawNativeGasFee`, `withdrawErc20GasFee`""
    },
    {
      ""Issue"": ""Potential Arithmetic Overflow/Underflow in `getRewardAmount` Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `getRewardAmount` function, the calculation `(amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference; rewardAmount = rewardAmount / 10000000000;` can be vulnerable to integer overflow if `amount * incentivePool[tokenAddress] * 10000000000` exceeds the maximum value for a `uint256`. The check `currentLiquidity < providedLiquidity` might prevent it in most cases, but a carefully crafted scenario could still trigger an overflow. Additionally, potential underflow can occur with the line `incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;` in the `depositErc20` and `depositNative` functions without guarantee that `rewardAmount` is less than or equal to `incentivePool[tokenAddress]`."",
      ""Impact"": ""Incorrect reward calculations, potentially leading to users receiving less or more rewards than expected, and possible incorrect accounting of incentive pool amounts."",
      ""Location"": ""LiquidityPool.sol:164, LiquidityPool.sol:136, LiquidityPool.sol:234, Function: `getRewardAmount`, getRewardAmount""
    },
    {
      ""Issue"": ""Potential Division by Zero in `getTransferFee`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `getTransferFee` function calculates the transfer fee based on liquidity and other parameters. The denominator in the fee calculation `equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity` could potentially be zero. While there\'s a check for denominator == 0, returning 0 can have unintended consequences in later calculations where this `fee` is used. The logic of the contract might depend on the calculated `fee` being a valid value, and assigning 0 could lead to unexpected behavior and bypass expected fee structures."",
      ""Impact"": ""Division by zero is prevented by the if statement, but incorrect fee calculation could impact the incentives for liquidity providers or potentially break transfer calculations."",
      ""Location"": ""getTransferFee, LiquidityPool.sol:309, LiquidityPool.sol:311""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `getAmountToTransfer`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In `getAmountToTransfer`, `totalGasUsed` is calculated by adding `initialGas - gasleft()`, `tokenManager.getTokensInfo(tokenAddress).transferOverhead`, and `baseGas`. If these values are large enough, their sum could potentially exceed the maximum value of a `uint256`, leading to an overflow. In `getAmountToTransfer`, the calculation of `incentivePool[tokenAddress]` involves addition `(incentivePool[tokenAddress] + (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) / BASE_DIVISOR;` which could cause an overflow if the sum exceeds the maximum `uint256` value."",
      ""Impact"": ""Incorrect gas fee calculation; Transfer amounts might be miscalculated potentially leading to loss of funds or unexpected behavior. Incorrect reward distribution and potentially incorrect transfer amounts."",
      ""Location"": ""getAmountToTransfer, LiquidityPool.sol:282""
    },
    {
      ""Issue"": ""Reward Calculation Vulnerability with Low Liquidity Difference"",
      ""Severity"": ""Medium"",
      ""Description"": ""In `getRewardAmount`, the division `(amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference` is performed. If `liquidityDifference` is very small (close to zero), the result of this calculation could be significantly larger than intended, even after the division `rewardAmount = rewardAmount / 10000000000;`. This could lead to a disproportionately high reward being allocated if the user deposits an amount that's only slightly larger than the liquidity difference."",
      ""Impact"": ""Users depositing small amounts when liquidity is low could receive excessive rewards, potentially depleting the incentive pool faster than intended."",
      ""Location"": ""LiquidityPool.sol#167""
    },
    {
      ""Issue"": ""Inconsistent gas accounting"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract calculates `totalGasUsed` and thus `gasFee`. However, the gas used to transfer fees to liquidity providers is not accounted for. This means more value may be extracted from the pool than intended."",
      ""Impact"": ""Potential loss of value extracted from the pool, reduced profitability for LPs."",
      ""Location"": ""LiquidityPool.sol:289""
    },
    {
      ""Issue"": ""Missing Safe Math Operations in `getAmountToTransfer`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the function `getAmountToTransfer`, the line `amountToTransfer = amount - (transferFeeAmount + gasFee);` could potentially underflow if `(transferFeeAmount + gasFee)` is greater than `amount`."",
      ""Impact"": ""Underflow in `amountToTransfer`, potentially resulting in a much larger amount being transferred to the user than intended."",
      ""Location"": ""LiquidityPool.sol#298""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `withdrawNativeGasFee` and `withdrawErc20GasFee`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `withdrawNativeGasFee` and `withdrawErc20GasFee` first update the `gasFeeAccumulatedByToken` and `gasFeeAccumulated` mappings to zero *before* transferring the funds to the caller. While a reentrancy guard is in place, it only prevents reentrancy within this contract. If the receiver is a malicious contract, it could potentially re-enter another function in the system that relies on the updated `gasFeeAccumulatedByToken` or `gasFeeAccumulated` values *before* the external transfer returns, leading to unexpected behavior."",
      ""Impact"": ""Potential for incorrect accounting of accumulated gas fees if the receiving address is a malicious contract. An attacker could potentially drain more gas fees than they are entitled to."",
      ""Location"": ""withdrawNativeGasFee, withdrawErc20GasFee""
    },
    {
      ""Issue"": ""Missing input validation for `tokenGasPrice` in `sendFundsToUser`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `sendFundsToUser` function receives `tokenGasPrice` as input, which is used to calculate the `gasFee`. If a malicious executor provides a very large `tokenGasPrice`, the resulting `gasFee` could be significantly inflated, draining the contract\'s funds. There is no validation on the range of `tokenGasPrice`, potentially leading to unexpected behavior and fund exploitation."",
      ""Impact"": ""Potential for excessive gas fees, leading to fund depletion. Malicious executors can exploit the lack of input validation."",
      ""Location"": ""LiquidityPool.sol:242, LiquidityPool.sol:sendFundsToUser""
    },
    {
      ""Issue"": ""Incorrect Incentive Calculation in `getAmountToTransfer`"",
      ""Severity"": ""Low"",
      ""Description"": ""The line `incentivePool[tokenAddress] = (incentivePool[tokenAddress] + (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) / BASE_DIVISOR;` is intended to add the difference between `transferFeePerc` and `equilibriumFee` to `incentivePool`. However, due to the parentheses the `incentivePool[tokenAddress]` is added to `amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee)`, and the result is divided by `BASE_DIVISOR`, leading to an incorrect increment of the incentive pool."",
      ""Impact"": ""Incorrect accounting of fees, affecting the incentive structure for liquidity providers and overall protocol economics."",
      ""Location"": ""LiquidityPool.sol:getAmountToTransfer""
    },
    {
      ""Issue"": ""Potential Precision Loss in `getTransferFee` Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The `getTransferFee` function calculates the fee using integer division. This can lead to precision loss, especially when dealing with small amounts. While the impact might be minimal for large transfers, the accumulated rounding errors over many transactions could become significant and affect the overall accuracy of the fee calculations."",
      ""Impact"": ""Slightly inaccurate fee calculations, leading to minor loss of funds."",
      ""Location"": ""LiquidityPool.sol:306""
    },
    {
      ""Issue"": ""Lack of Input Validation for `baseGas`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setBaseGas` function allows the owner to set the `baseGas` value. There is no validation to ensure that `gas` is a reasonable value. Setting an excessively large `baseGas` value could significantly increase the gas costs of operations performed by the `sendFundsToUser` function, potentially making it economically unviable. Setting it to zero will cause the gas calculation to be incorrect."",
      ""Impact"": ""Unpredictable gas costs and potential denial of service."",
      ""Location"": ""LiquidityPool.sol:99, setBaseGas""
    },
    {
      ""Issue"": ""Missing Zero Address Check for Pauser Address in `initialize`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `initialize` function checks for zero addresses for `_executorManagerAddress`, `_trustedForwarder`, and `_liquidityProviders`, but not for `_pauser`."",
      ""Impact"": ""Potential issues if the Pausable contract relies on `_pauser` having a valid non-zero address."",
      ""Location"": ""LiquidityPool.sol:72""
    },
    {
      ""Issue"": ""Inconsistent Gas Fee Withdrawal Logic"",
      ""Severity"": ""Low"",
      ""Description"": ""Gas fees are tracked per-token and per-executor. However, the event `GasFeeWithdraw` emits `address(this)` as the token address in the `withdrawNativeGasFee` function. This is inconsistent with how ERC20 gas fee withdrawals are handled and can lead to confusion when analyzing logs."",
      ""Impact"": ""Confusion during log analysis."",
      ""Location"": ""Functions: `withdrawNativeGasFee`""
    },
    {
      ""Issue"": ""Potential Loss of Funds Due to Incorrect `GasFeeWithdraw` Emitted Event"",
      ""Severity"": ""Low"",
      ""Description"": ""In both `withdrawNativeGasFee` and `withdrawErc20GasFee`, the `GasFeeWithdraw` event emits the `address(this)` as the token address when withdrawing native tokens, which is incorrect. This should be the native token address (NATIVE)."",
      ""Impact"": ""The event data will be incorrect, potentially causing issues with accounting, monitoring, and auditing of the contract."",
      ""Location"": ""LiquidityPool.sol:withdrawNativeGasFee, LiquidityPool.sol:withdrawErc20GasFee""
    },
    {
      ""Issue"": ""`transfer` function uses require with string literals for error messages"",
      ""Severity"": ""Low"",
      ""Description"": ""The `transfer` function utilizes `require` statements with string literals for error messages (e.g., \""ERR__INSUFFICIENT_BALANCE\""). Using string literals for error messages consumes significantly more gas compared to using custom errors or revert codes."",
      ""Impact"": ""Increased gas costs for failed transactions."",
      ""Location"": ""LiquidityPool.sol:355, LiquidityPool.sol:358""
    },
    {
      ""Issue"": ""Inconsistent Gas Fee Handling in `withdrawNativeGasFee` and `withdrawErc20GasFee`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `withdrawNativeGasFee` function transfers gas fees directly to the msg.sender, while `withdrawErc20GasFee` transfers gas fees to the msg.sender using SafeERC20. "",
      ""Impact"": ""Inconsistent handling of gas fees and potential loss of precision. Incorrect display of the `msg.sender` in event logs."",
      ""Location"": ""LiquidityPool.sol:withdrawNativeGasFee, LiquidityPool.sol:withdrawErc20GasFee""
    },
    {
      ""Issue"": ""Unnecessary multiplication by `10000000000` and division by `10000000000` in `getRewardAmount`"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `getRewardAmount` function, when the `amount` is less than `liquidityDifference`, the code multiplies `amount * incentivePool[tokenAddress]` by `10000000000` and then immediately divides by the same value. This multiplication and division are redundant and can be simplified to improve gas efficiency."",
      ""Impact"": ""Slightly increased gas costs due to unnecessary computations."",
      ""Location"": ""LiquidityPool.sol:164-165""
    },
    {
      ""Issue"": ""Missing check in `transfer` function, it should only allow NATIVE and supported tokens."",
      ""Severity"": ""Medium"",
      ""Description"": ""The `transfer` function is called by `liquidityProviders`, it transfer funds to the specified receiver. It should validate whether the `_tokenAddress` is either `NATIVE` or a supported token."",
      ""Impact"": ""Transfer of non supported token"",
      ""Location"": ""transfer""
    },
    {
      ""Issue"": ""Potential denial of service in `getTransferFee` due to division by zero"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `getTransferFee` function calculates a transfer fee based on liquidity and other parameters. The calculation includes a division where the denominator is `equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity`. While there\'s a check `if (denominator == 0)`, which assigns `fee = 0`, a situation where `denominator` is equal to zero can be forced by carefully selecting values for `equilibriumFee`, `maxFee`, `providedLiquidity`, and `resultingLiquidity`."",
      ""Impact"": ""Incorrect or zero transfer fee calculations, potentially leading to denial of service or unexpected behavior."",
      ""Location"": ""LiquidityPool.sol:278-287, getTransferFee""
    },
    {
      ""Issue"": ""Unbounded Loop Risk in getTransferFee Denominator"",
      ""Severity"": ""Low"",
      ""Description"": ""If `equilibriumFee` equals `maxFee` in `getTransferFee` the calculation `equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity` simplifies to  `equilibriumFee * providedLiquidity`. This means that the fee will *always* return `numerator / (equilibriumFee * providedLiquidity)` and can be precomputed and doesn\'t need the `resultingLiquidity` variable. If `resultingLiquidity` becomes extremely large such that it approaches `type(uint256).max` then `denominator` calculation becomes very large, and a gas griefing attack to cause a denial of service is possible."",
      ""Impact"": ""Potential griefing attack."",
      ""Location"": ""Function: `getTransferFee`""
    },
        {
      ""Issue"": ""Potential DOS due to large transferOverhead"",
      ""Severity"": ""Low"",
      ""Description"": ""The transferOverhead value fetched from tokenManager is used to calculate gasFee inside getAmountToTransfer. A large value for transferOverhead set by a malicious tokenManager could make gasFee excessively high, preventing users from withdrawing any meaningful amount."",
      ""Impact"": ""Potential for DOS due to excessively high gasFee calculations."",
      ""Location"": ""LiquidityPool.sol#284""
    }
  ],
  ""IssueNumber"": 61,
  ""OutputList"": 27
}",261.76460313797,4538.0,33.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] Can deposit native token for free and steal funds**

**Report Description**:  
The `depositErc20` function allows setting `tokenAddress = NATIVE` and does not throw an error. The `SafeERC20Upgradeable.safeTransferFrom` call will not revert because it performs a low-level call to `NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE`, which is an EOA, and low-level calls to EOAs always succeed. This allows an attacker to deposit infinite native tokens without paying anything, leading to fund theft.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific vulnerability. The issue involves a critical flaw in the `depositErc20` function, allowing attackers to exploit the `NATIVE` address for free deposits. This is a significant oversight and should have been identified in the response list.

---

#### **[H-03] Wrong formula when add fee in `incentivePool` can lead to loss of funds**

**Report Description**:  
The `getAmountToTransfer` function updates `incentivePool[tokenAddress]` by adding a fee, but the formula is incorrect. The value of `incentivePool[tokenAddress]` is divided by `BASE_DIVISOR` (10000000000) each time, causing it to quickly become zero. This results in tokens being locked in the contract.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Incentive Calculation in `getAmountToTransfer`""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the incorrect formula in `getAmountToTransfer`. It correctly explains the impact of the division by `BASE_DIVISOR`, which leads to the depletion of the `incentivePool`. This aligns with the issue report.

---

#### **[M-08] Incentive Pool can be drained without rebalancing the pool**

**Report Description**:  
The `depositErc20` function allows an attacker to specify the destination chain as the same as the source chain and the receiver account as the same as the caller account. This enables the attacker to drain the incentive pool without rebalancing the pool back to the equilibrium state.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific vulnerability. The issue involves a critical flaw in the `depositErc20` function, allowing attackers to drain the incentive pool without rebalancing. This is a significant oversight and should have been identified in the response list.

---

#### **[M-18] Possible frontrun on `deposits` on LiquidityPool**

**Report Description**:  
Rewards are given to users for depositing tokens into the LiquidityPool. A malicious user can watch the mempool for transactions that will receive a reward and front-run them by attaching a higher fee to their transaction. This allows the malicious user to gain double rewards.

**Match in Response List**:  
Matches with the issue titled **""Potential Front-Running Vulnerability in `permitAndDepositErc20` and `permitEIP2612AndDepositErc20`""**.

**Validation**:  
**Partially Correct**. The response identifies a front-running vulnerability but focuses on the `permitAndDepositErc20` and `permitEIP2612AndDepositErc20` functions, which are not explicitly mentioned in the issue report. While the core issue of front-running is addressed, the specific context of the `deposit` function in the issue report is not fully covered.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-03] Wrong formula when add fee in `incentivePool` can lead to loss of funds**

**Partially Correct Matches**:

- **[M-18] Possible frontrun on `deposits` on LiquidityPool**

**Missed Issues from Issue Report**:

- **[H-01] Can deposit native token for free and steal funds**
- **[M-08] Incentive Pool can be drained without rebalancing the pool**

---

### **Conclusion**

The response list partially covers the issues in the issue report. While some vulnerabilities are correctly identified, critical issues like **[H-01]** and **[M-08]** are entirely missed. Additionally, the front-running issue **[M-18]** is only partially addressed. The response list should be expanded to cover these gaps for a more comprehensive security assessment.","```
1. Incorrect Incentive Calculation in `getAmountToTransfer`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Incorrect Incentive Calculation in `getAmountToTransfer`"".
   - This issue appears at rank **16** in the ranked list of predictions.

2. **Calculate Precision at rank 16 (P@16)**:
   - Precision at rank \( k \) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Since there is only one true positive up to rank 16, \( P@16 = \frac{1}{16} = 0.0625 \).

3. **Compute Average Precision (AP)**:
   - AP is the average of the precision values for all true positives.
   - Since there is only one true positive, \( AP = P@16 = 0.0625 \).

**Output**:
```
0.0625
```"
LiquidityProviders.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/IWhiteListPeriodManager.sol"";
import ""./interfaces/ILiquidityPool.sol"";

contract LiquidityProviders is
    Initializable,
    ReentrancyGuardUpgradeable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 public constant BASE_DIVISOR = 10**18;

    ILPToken internal lpToken;
    ILiquidityPool internal liquidityPool;
    ITokenManager internal tokenManager;
    IWhiteListPeriodManager internal whiteListPeriodManager;

    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);
    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);
    event EthReceived(address indexed sender, uint256 value);
    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);

    // LP Fee Distribution
    mapping(address => uint256) public totalReserve; // Include Liquidity + Fee accumulated
    mapping(address => uint256) public totalLiquidity; // Include Liquidity only
    mapping(address => uint256) public currentLiquidity; // Include current liquidity, updated on every in and out transfer
    mapping(address => uint256) public totalLPFees;
    mapping(address => uint256) public totalSharesMinted;

    /**
     * @dev Modifier for checking to validate a NFTId and it's ownership
     * @param _tokenId token id to validate
     * @param _transactor typically msgSender(), passed to verify against owner of _tokenId
     */
    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {
        (address token, , ) = lpToken.tokenMetadata(_tokenId);
        require(lpToken.exists(_tokenId), ""ERR__TOKEN_DOES_NOT_EXIST"");
        require(lpToken.ownerOf(_tokenId) == _transactor, ""ERR__TRANSACTOR_DOES_NOT_OWN_NFT"");
        _;
    }

    /**
     * @dev Modifier for checking if msg.sender in liquiditypool
     */
    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityPool), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    /**
     * @dev initalizes the contract, acts as constructor
     * @param _trustedForwarder address of trusted forwarder
     */
    function initialize(
        address _trustedForwarder,
        address _lpToken,
        address _tokenManager,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        _setLPToken(_lpToken);
        _setTokenManager(_tokenManager);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {
        return totalReserve[tokenAddress];
    }

    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {
        return totalLiquidity[tokenAddress];
    }

    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {
        return totalLPFees[tokenAddress];
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {
        return currentLiquidity[tokenAddress];
    }

    /**
     * @dev To be called post initialization, used to set address of NFT Contract
     * @param _lpToken address of lpToken
     */
    function setLpToken(address _lpToken) external onlyOwner {
        _setLPToken(_lpToken);
    }

    /**
     * Internal method to set LP token contract.
     */
    function _setLPToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _increaseCurrentLiquidity(tokenAddress, amount);
    }

    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _decreaseCurrentLiquidity(tokenAddress, amount);
    }

    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] += amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);
    }

    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] -= amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);
    }

    /**
     * Public method to set TokenManager contract.
     */
    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    /**
     * Internal method to set TokenManager contract.
     */
    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    /**
     * @dev To be called post initialization, used to set address of WhiteListPeriodManager Contract
     * @param _whiteListPeriodManager address of WhiteListPeriodManager
     */
    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {
        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);
    }

    /**
     * @dev To be called post initialization, used to set address of LiquidityPool Contract
     * @param _liquidityPool address of LiquidityPool
     */
    function setLiquidityPool(address _liquidityPool) external onlyOwner {
        liquidityPool = ILiquidityPool(_liquidityPool);
    }

    /**
     * @dev Returns price of Base token in terms of LP Shares
     * @param _baseToken address of baseToken
     * @return Price of Base token in terms of LP Shares
     */
    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {
        uint256 supply = totalSharesMinted[_baseToken];
        if (supply > 0) {
            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];
        }
        return BASE_DIVISOR;
    }

    /**
     * @dev Converts shares to token amount
     */

    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {
        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];
    }

    /**
     * @dev Returns the fee accumulated on a given NFT
     * @param _nftId Id of NFT
     * @return accumulated fee
     */
    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {
        require(lpToken.exists(_nftId), ""ERR__INVALID_NFT"");

        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);

        if (totalNFTShares == 0) {
            return 0;
        }
        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated;

        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount 
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        return lpFeeAccumulated;
    }

    /**
     * @dev Records fee being added to total reserve
     * @param _token Address of Token for which LP fee is being added
     * @param _amount Amount being added
     */
    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {
        totalReserve[_token] += _amount;
        totalLPFees[_token] += _amount;
        emit FeeAdded(_token, _amount);
    }

    /**
     * @dev Internal function to add liquidity to a new NFT
     */
    function _addLiquidity(address _token, uint256 _amount) internal {
        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        uint256 nftId = lpToken.mint(_msgSender());
        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);
        lpToken.updateTokenMetadata(nftId, data);
        _increaseLiquidity(nftId, _amount);
    }

    /**
     * @dev Function to mint a new NFT for a user, add native liquidity and store the
     *      record in the newly minted NFT
     */
    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _addLiquidity(NATIVE, msg.value);
    }

    /**
     * @dev Function to mint a new NFT for a user, add token liquidity and store the
     *      record in the newly minted NFT
     * @param _token Address of token for which liquidity is to be added
     * @param _amount Amount of liquidity added
     */
    function addTokenLiquidity(address _token, uint256 _amount)
        external
        nonReentrant
        tokenChecks(_token)
        whenNotPaused
    {
        require(_token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);
        _addLiquidity(_token, _amount);
    }

    /**
     * @dev Internal helper function to increase liquidity in a given NFT
     */
    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {
        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);

        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);

        uint256 mintedSharesAmount;
        // Adding liquidity in the pool for the first time
        if (totalReserve[token] == 0) {
            mintedSharesAmount = BASE_DIVISOR * _amount;
        } else {
            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];
        }

        require(mintedSharesAmount >= BASE_DIVISOR, ""ERR__AMOUNT_BELOW_MIN_LIQUIDITY"");

        totalLiquidity[token] += _amount;
        totalReserve[token] += _amount;
        totalSharesMinted[token] += mintedSharesAmount;

        LpTokenMetadata memory data = LpTokenMetadata(
            token,
            totalSuppliedLiquidity + _amount,
            totalShares + mintedSharesAmount
        );
        lpToken.updateTokenMetadata(_nftId, data);

        // Increase the current liquidity
        _increaseCurrentLiquidity(token, _amount);
        emit LiquidityAdded(token, _amount, _msgSender());
    }

    /**
     * @dev Function to allow LPs to add ERC20 token liquidity to existing NFT
     * @param _nftId ID of NFT for updating the balances
     * @param _amount Token amount to be added
     */
    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(token), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);
        _increaseLiquidity(_nftId, _amount);
    }

    /**
     * @dev Function to allow LPs to add native token liquidity to existing NFT
     */
    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(NATIVE), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token == NATIVE, ""ERR__WRONG_FUNCTION"");
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _increaseLiquidity(_nftId, msg.value);
    }

    /**
     * @dev Function to allow LPs to remove their liquidity from an existing NFT
     *      Also automatically redeems any earned fee
     */
    function removeLiquidity(uint256 _nftId, uint256 _amount)
        external
        nonReentrant
        onlyValidLpToken(_nftId, _msgSender())
        whenNotPaused
    {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        require(_amount != 0, ""ERR__INVALID_AMOUNT"");
        require(nftSuppliedLiquidity >= _amount, ""ERR__INSUFFICIENT_LIQUIDITY"");
        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);
        // Claculate how much shares represent input amount
        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);

        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        
        uint256 lpFeeAccumulated;

        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount 
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        // Calculate amount of lp shares that represent accumulated Fee
        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);

        totalLPFees[_tokenAddress] -= lpFeeAccumulated;
        uint256 amountToWithdraw = _amount + lpFeeAccumulated;
        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;

        // Handle round off errors to avoid dust lp token in contract
        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {
            lpSharesToBurn = totalNFTShares;
        }
        totalReserve[_tokenAddress] -= amountToWithdraw;
        totalLiquidity[_tokenAddress] -= _amount;
        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;

        _decreaseCurrentLiquidity(_tokenAddress, _amount);

        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);

        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);

        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());
    }

    /**
     * @dev Function to allow LPs to claim the fee earned on their NFT
     * @param _nftId ID of NFT where liquidity is recorded
     */
    function claimFee(uint256 _nftId) external onlyValidLpToken(_nftId, _msgSender()) whenNotPaused nonReentrant {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        uint256 lpSharesForSuppliedLiquidity = nftSuppliedLiquidity * getTokenPriceInLPShares(_tokenAddress);

        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
        require(lpFeeAccumulated > 0, ""ERR__NO_REWARDS_TO_CLAIM"");
        // Calculate amount of lp shares that represent accumulated Fee
        uint256 lpSharesRepresentingFee = totalNFTShares - lpSharesForSuppliedLiquidity;

        totalReserve[_tokenAddress] -= lpFeeAccumulated;
        totalSharesMinted[_tokenAddress] -= lpSharesRepresentingFee;
        totalLPFees[_tokenAddress] -= lpFeeAccumulated;

        _burnSharesFromNft(_nftId, lpSharesRepresentingFee, 0, _tokenAddress);
        _transferFromLiquidityPool(_tokenAddress, _msgSender(), lpFeeAccumulated);
        emit FeeClaimed(_tokenAddress, lpFeeAccumulated, _msgSender(), lpSharesRepresentingFee);
    }

    /**
     * @dev Internal Function to burn LP shares and remove liquidity from existing NFT
     */
    function _burnSharesFromNft(
        uint256 _nftId,
        uint256 _shares,
        uint256 _tokenAmount,
        address _tokenAddress
    ) internal {
        (, uint256 nftSuppliedLiquidity, uint256 nftShares) = lpToken.tokenMetadata(_nftId);
        nftShares -= _shares;
        nftSuppliedLiquidity -= _tokenAmount;

        lpToken.updateTokenMetadata(_nftId, LpTokenMetadata(_tokenAddress, nftSuppliedLiquidity, nftShares));
    }

    function _transferFromLiquidityPool(
        address _tokenAddress,
        address _receiver,
        uint256 _tokenAmount
    ) internal {
        liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount);
    }

    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256) {
        (, uint256 totalSuppliedLiquidity, ) = lpToken.tokenMetadata(_nftId);
        return totalSuppliedLiquidity;
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",4555,475,"[H-02] LiquidityProviders.sol The share price of the LP can be manipulated and making future liquidityProviders unable to removeLiquidity()

Submitted by WatchPug
LiquidityProviders.sol#L345-L362
function removeLiquidity(uint256 _nftId, uint256 _amount)
    external
    nonReentrant
    onlyValidLpToken(_nftId, _msgSender())
    whenNotPaused
{
    (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
    require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

    require(_amount != 0, ""ERR__INVALID_AMOUNT"");
    require(nftSuppliedLiquidity >= _amount, ""ERR__INSUFFICIENT_LIQUIDITY"");
    whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);
    // Claculate how much shares represent input amount
    uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);

    // Calculate rewards accumulated
    uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
  [M-01] Unsupported tokens cannot be withdrawn

Submitted by cmichel, also found by kyliek, pedroais, and PPrieditis
LiquidityProviders.sol#L273
Supported tokens can be turned off again by calling TokenManager.removeSupportedToken. Users won't be able to withdraw their liquidity anymore because of this check in removeLiquidity.
  [M-11] LiquidityProviders: Setting new liquidity pool will break contract

Submitted by cmichel, also found by gzeon
LiquidityProviders.sol#L171
Owners can change the liquidityPool variable any time with the setLiquidityPool function. If a liquidity pool was already set and users added liquidity with addTokenLiquidity, the tokens are directly transferred to the liquidity pool and not kept in the LiquidityProviders contract. Changing the liquidityPool to a different contract will make it impossible for the users to withdraw their liquidity using removeLiquidity because the tokens are still in the old liquidityPool and cannot be retrieved.
  [M-12] LiquidityProviders: Setting new LP token will break contract

Submitted by cmichel, also found by gzeon
LiquidityProviders.sol#L116
Owners can change the lpToken variable at any time with the setLpToken function. If an LP token was already set and users added liquidity with addTokenLiquidity and were minted a lpToken NFT, changing the lpToken to a different contract will make it impossible for the users to withdraw their liquidity using removeLiquidity.
All users will lose their funds.

[M-17] wrong condition checking in price calculation

Submitted by CertoraInc
LiquidityProviders.sol#L180-L186
The getTokenPriceInLPShares function calculates the token price in LP shares, but it checks a wrong condition - if supposed to return BASE_DIVISOR if the total reserve is zero, not if the total shares minted is zero. This might leads to a case where the price is calculated incorrectly, or a division by zero is happening.
Proof of Concept
  [M-19] sharesToTokenAmount: Division by zero

Submitted by cmichel, also found by cccz and CertoraInc
LiquidityProviders.sol#L192
The public sharesToTokenAmount function does not check if the denominator totalSharesMinted[_tokenAddress] is zero. Neither do the callers of this function. The function will revert. Calling functions like getFeeAccumulatedOnNft and sharesToTokenAmount from another contract should never revert.
 [M-20] Liquidity providers unable to remove liquidity when the pool is in deficit state

Submitted by kyliek
LiquidityProviders.sol#L388 LiquidityProviders.sol#L392
LP token holders can not redeem their tokens when the pool is in the deficit state, i.e. currentLiquidity << providedLiquidity. This is due to that LP shares are computed based on providedLiquidity and the actual available pool balance is based on currentLiquidity.
",7,,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/IWhiteListPeriodManager.sol"";
import ""./interfaces/ILiquidityPool.sol"";

contract LiquidityProviders is
    Initializable,
    ReentrancyGuardUpgradeable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 public constant BASE_DIVISOR = 10**18;

    ILPToken internal lpToken;
    ILiquidityPool internal liquidityPool;
    ITokenManager internal tokenManager;
    IWhiteListPeriodManager internal whiteListPeriodManager;

    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);
    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);
    event EthReceived(address indexed sender, uint256 value);
    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);

    
    mapping(address => uint256) public totalReserve; 
    mapping(address => uint256) public totalLiquidity; 
    mapping(address => uint256) public currentLiquidity; 
    mapping(address => uint256) public totalLPFees;
    mapping(address => uint256) public totalSharesMinted;

    
    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {
        (address token, , ) = lpToken.tokenMetadata(_tokenId);
        require(lpToken.exists(_tokenId), ""ERR__TOKEN_DOES_NOT_EXIST"");
        require(lpToken.ownerOf(_tokenId) == _transactor, ""ERR__TRANSACTOR_DOES_NOT_OWN_NFT"");
        _;
    }

    
    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityPool), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    
    function initialize(
        address _trustedForwarder,
        address _lpToken,
        address _tokenManager,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        _setLPToken(_lpToken);
        _setTokenManager(_tokenManager);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {
        return totalReserve[tokenAddress];
    }

    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {
        return totalLiquidity[tokenAddress];
    }

    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {
        return totalLPFees[tokenAddress];
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {
        return currentLiquidity[tokenAddress];
    }

    
    function setLpToken(address _lpToken) external onlyOwner {
        _setLPToken(_lpToken);
    }

    
    function _setLPToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _increaseCurrentLiquidity(tokenAddress, amount);
    }

    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _decreaseCurrentLiquidity(tokenAddress, amount);
    }

    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] += amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);
    }

    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] -= amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);
    }

    
    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    
    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    
    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {
        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);
    }

    
    function setLiquidityPool(address _liquidityPool) external onlyOwner {
        liquidityPool = ILiquidityPool(_liquidityPool);
    }

    
    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {
        uint256 supply = totalSharesMinted[_baseToken];
        if (supply > 0) {
            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];
        }
        return BASE_DIVISOR;
    }

    

    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {
        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];
    }

    
    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {
        require(lpToken.exists(_nftId), ""ERR__INVALID_NFT"");

        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);

        if (totalNFTShares == 0) {
            return 0;
        }
        
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated;

        
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        return lpFeeAccumulated;
    }

    
    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {
        totalReserve[_token] += _amount;
        totalLPFees[_token] += _amount;
        emit FeeAdded(_token, _amount);
    }

    
    function _addLiquidity(address _token, uint256 _amount) internal {
        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        uint256 nftId = lpToken.mint(_msgSender());
        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);
        lpToken.updateTokenMetadata(nftId, data);
        _increaseLiquidity(nftId, _amount);
    }

    
    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _addLiquidity(NATIVE, msg.value);
    }

    
    function addTokenLiquidity(address _token, uint256 _amount)
        external
        nonReentrant
        tokenChecks(_token)
        whenNotPaused
    {
        require(_token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);
        _addLiquidity(_token, _amount);
    }

    
    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {
        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);

        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);

        uint256 mintedSharesAmount;
        
        if (totalReserve[token] == 0) {
            mintedSharesAmount = BASE_DIVISOR * _amount;
        } else {
            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];
        }

        require(mintedSharesAmount >= BASE_DIVISOR, ""ERR__AMOUNT_BELOW_MIN_LIQUIDITY"");

        totalLiquidity[token] += _amount;
        totalReserve[token] += _amount;
        totalSharesMinted[token] += mintedSharesAmount;

        LpTokenMetadata memory data = LpTokenMetadata(
            token,
            totalSuppliedLiquidity + _amount,
            totalShares + mintedSharesAmount
        );
        lpToken.updateTokenMetadata(_nftId, data);

        
        _increaseCurrentLiquidity(token, _amount);
        emit LiquidityAdded(token, _amount, _msgSender());
    }

    
    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(token), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);
        _increaseLiquidity(_nftId, _amount);
    }

    
    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(NATIVE), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token == NATIVE, ""ERR__WRONG_FUNCTION"");
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _increaseLiquidity(_nftId, msg.value);
    }

    
    function removeLiquidity(uint256 _nftId, uint256 _amount)
        external
        nonReentrant
        onlyValidLpToken(_nftId, _msgSender())
        whenNotPaused
    {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        require(_amount != 0, ""ERR__INVALID_AMOUNT"");
        require(nftSuppliedLiquidity >= _amount, ""ERR__INSUFFICIENT_LIQUIDITY"");
        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);
        
        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);

        
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        
        uint256 lpFeeAccumulated;

        
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        
        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);

        totalLPFees[_tokenAddress] -= lpFeeAccumulated;
        uint256 amountToWithdraw = _amount + lpFeeAccumulated;
        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;

        
        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {
            lpSharesToBurn = totalNFTShares;
        }
        totalReserve[_tokenAddress] -= amountToWithdraw;
        totalLiquidity[_tokenAddress] -= _amount;
        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;

        _decreaseCurrentLiquidity(_tokenAddress, _amount);

        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);

        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);

        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());
    }

    
    function claimFee(uint256 _nftId) external onlyValidLpToken(_nftId, _msgSender()) whenNotPaused nonReentrant {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        uint256 lpSharesForSuppliedLiquidity = nftSuppliedLiquidity * getTokenPriceInLPShares(_tokenAddress);

        
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
        require(lpFeeAccumulated > 0, ""ERR__NO_REWARDS_TO_CLAIM"");
        
        uint256 lpSharesRepresentingFee = totalNFTShares - lpSharesForSuppliedLiquidity;

        totalReserve[_tokenAddress] -= lpFeeAccumulated;
        totalSharesMinted[_tokenAddress] -= lpSharesRepresentingFee;
        totalLPFees[_tokenAddress] -= lpFeeAccumulated;

        _burnSharesFromNft(_nftId, lpSharesRepresentingFee, 0, _tokenAddress);
        _transferFromLiquidityPool(_tokenAddress, _msgSender(), lpFeeAccumulated);
        emit FeeClaimed(_tokenAddress, lpFeeAccumulated, _msgSender(), lpSharesRepresentingFee);
    }

    
    function _burnSharesFromNft(
        uint256 _nftId,
        uint256 _shares,
        uint256 _tokenAmount,
        address _tokenAddress
    ) internal {
        (, uint256 nftSuppliedLiquidity, uint256 nftShares) = lpToken.tokenMetadata(_nftId);
        nftShares -= _shares;
        nftSuppliedLiquidity -= _tokenAmount;

        lpToken.updateTokenMetadata(_nftId, LpTokenMetadata(_tokenAddress, nftSuppliedLiquidity, nftShares));
    }

    function _transferFromLiquidityPool(
        address _tokenAddress,
        address _receiver,
        uint256 _tokenAmount
    ) internal {
        liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount);
    }

    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256) {
        (, uint256 totalSuppliedLiquidity, ) = lpToken.tokenMetadata(_nftId);
        return totalSuppliedLiquidity;
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",3709,1,6,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only the owner can call `setLpToken`, `setTokenManager`, `setWhiteListPeriodManager`, and `setLiquidityPool`."",
        ""Confirm that the `onlyLiquidityPool` modifier correctly restricts access to `increaseCurrentLiquidity`, `decreaseCurrentLiquidity`, and `addLPFee` functions."",
        ""Ensure that the pauser role, set during `initialize`, functions as intended to pause and unpause the contract, preventing unintended actions during maintenance or emergencies."",
        ""Verify that the `onlyValidLpToken` modifier accurately checks token existence and ownership to prevent unauthorized modifications.""
      ]
    },
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Analyze the potential for reentrancy attacks in `addNativeLiquidity`, `addTokenLiquidity`, `increaseTokenLiquidity`, `increaseNativeLiquidity`, `removeLiquidity`, and `claimFee` despite the `nonReentrant` modifier. Specifically, examine interactions with the `liquidityPool`, `lpToken`, and `whiteListPeriodManager` for reentrancy possibilities through callback functions."",
        ""Examine if external calls within the `liquidityPool.transfer` call in `_transferFromLiquidityPool` can be exploited for reentrancy.""
      ]
    },
    {
      ""Area"": ""Arithmetic Overflows/Underflows"",
      ""Tasks"": [
        ""Review calculations in `getTokenPriceInLPShares`, `sharesToTokenAmount`, `getFeeAccumulatedOnNft`, `_increaseLiquidity`, and `removeLiquidity` for potential overflows/underflows, especially with large liquidity amounts or small share values. Consider using SafeMath or similar libraries even with Solidity 0.8.0 to improve code clarity."",
        ""Analyze the `unchecked` blocks in `getFeeAccumulatedOnNft` and `removeLiquidity`. Verify the condition `nftSuppliedLiquidity > eligibleLiquidity` can *never* be true. Add assertions or checks to guarantee this invariant and prevent unexpected behavior if it is violated."",
        ""Check for potential division by zero errors, particularly in `getTokenPriceInLPShares` and `sharesToTokenAmount`, and ensure appropriate handling.""
      ]
    },
    {
      ""Area"": ""Token and Value Handling"",
      ""Tasks"": [
        ""Verify that all token transfers use `SafeERC20Upgradeable` to prevent issues with tokens that do not adhere to the ERC-20 standard."",
        ""Confirm that the `NATIVE` address is handled correctly when adding/removing liquidity and claiming fees. Ensure consistent and secure handling of ETH."",
        ""Analyze the logic in `removeLiquidity` where `totalNFTShares - lpSharesToBurn < BASE_DIVISOR` leads to burning all remaining shares. Verify this behavior is intended and does not result in loss of principal if the remaining token amount is non-zero."",
        ""In `addNativeLiquidity` and `increaseNativeLiquidity`, verify if the value sent along with the transaction is equal to the amount that is used to mint LP shares.""
      ]
    },
    {
      ""Area"": ""External Contract Interactions"",
      ""Tasks"": [
        ""Audit the `ILPToken` contract interface and its implementation. Ensure the NFT metadata (especially token address, supplied liquidity, and shares) is consistent and cannot be manipulated."",
        ""Review the `ILiquidityPool` contract interface and its implementation. Pay close attention to the `transfer` function's security and ensure it prevents unauthorized token transfers or reentrancy attacks."",
        ""Examine the `ITokenManager` contract interface and its implementation. Confirm that the `getTokensInfo` function correctly determines supported tokens and that the returned data is reliable."",
        ""Analyze the `IWhiteListPeriodManager` contract interface and its implementation. Understand the logic of `beforeLiquidityAddition` and `beforeLiquidityRemoval` hooks and assess their potential impact on liquidity operations and potential for denial-of-service attacks."",
        ""Review the interaction with the trusted forwarder in `ERC2771ContextUpgradeable` to ensure proper meta-transaction handling and prevent spoofing of transaction origins.""
      ]
    },
    {
      ""Area"": ""Logic and Calculations"",
      ""Tasks"": [
        ""Analyze the calculation of `mintedSharesAmount` in `_increaseLiquidity`. Verify that the logic accurately reflects the value of liquidity added and prevents inflation or deflation of LP shares."",
        ""Review the calculation of `lpFeeAccumulated` in `getFeeAccumulatedOnNft` and `removeLiquidity` to ensure fair and accurate fee distribution."",
        ""Confirm that the `getTokenPriceInLPShares` function returns reasonable values and doesn't lead to unexpected behavior in share calculations, especially when liquidity is low or reserves are depleted."",
        ""Verify that `sharesToTokenAmount` function correctly converts shares into token amounts.""
      ]
    },
    {
      ""Area"": ""Pausability"",
      ""Tasks"": [
        ""Test the `whenNotPaused` modifier on all relevant functions to ensure they are effectively paused and unpaused by the Pausable contract."",
         ""Analyze the contract state when the contract is paused to ensure that pausing doesn't leave the contract in an inconsistent or vulnerable state.""
      ]
    },
    {
      ""Area"": ""Upgradeability"",
      ""Tasks"": [
        ""Verify that the `initializer` function can only be called once."",
        ""Check that the contract state is properly initialized in the `initializer` function."",
        ""Ensure that the storage layout is upgrade-safe, and that adding new state variables in future upgrades will not break existing functionality.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `LiquidityProviders` manages liquidity provisioning for a system, likely a DEX or lending platform. It handles adding/removing liquidity for both native ETH and ERC20 tokens, tracks liquidity provider shares via an external NFT contract (`ILPToken`), calculates and allows claiming of accrued fees, and interacts with other system components like a `LiquidityPool` (holding funds), `TokenManager` (for supported tokens), and potentially a `WhiteListPeriodManager`. It uses OpenZeppelin upgradeable contracts for common patterns like ownership, pausing, reentrancy protection, and meta-transactions (ERC2771)."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""LiquidityProviders"",
    ""Purpose"": ""To manage the addition, removal, and accounting of liquidity provided by users for different tokens, tracking LP positions via NFTs and handling fee distribution."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Initializable"",
        ""ReentrancyGuardUpgradeable"",
        ""ERC2771ContextUpgradeable"",
        ""OwnableUpgradeable"",
        ""Pausable""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"",
        ""./metatx/ERC2771ContextUpgradeable.sol"",
        ""../security/Pausable.sol"",
        ""./interfaces/ILPToken.sol"",
        ""./interfaces/ITokenManager.sol"",
        ""./interfaces/IWhiteListPeriodManager.sol"",
        ""./interfaces/ILiquidityPool.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""NATIVE"",
        ""Type"": ""address internal constant"",
        ""Purpose"": ""Represents the address for native Ether (ETH).""
      },
      {
        ""Name"": ""BASE_DIVISOR"",
        ""Type"": ""uint256 public constant"",
        ""Purpose"": ""A constant (10^18) likely used for precision in share calculations.""
      },
      {
        ""Name"": ""lpToken"",
        ""Type"": ""ILPToken internal"",
        ""Purpose"": ""Interface to the external contract managing LP position NFTs.""
      },
      {
        ""Name"": ""liquidityPool"",
        ""Type"": ""ILiquidityPool internal"",
        ""Purpose"": ""Interface to the external contract holding the actual liquidity funds.""
      },
      {
        ""Name"": ""tokenManager"",
        ""Type"": ""ITokenManager internal"",
        ""Purpose"": ""Interface to the external contract managing supported tokens and their info.""
      },
      {
        ""Name"": ""whiteListPeriodManager"",
        ""Type"": ""IWhiteListPeriodManager internal"",
        ""Purpose"": ""Interface to an external contract potentially imposing restrictions on liquidity operations.""
      },
      {
        ""Name"": ""totalReserve"",
        ""Type"": ""mapping(address => uint256) public"",
        ""Purpose"": ""Tracks the total amount of each token held (liquidity + fees).""
      },
      {
        ""Name"": ""totalLiquidity"",
        ""Type"": ""mapping(address => uint256) public"",
        ""Purpose"": ""Tracks the total principal liquidity supplied for each token (excluding fees).""
      },
      {
        ""Name"": ""currentLiquidity"",
        ""Type"": ""mapping(address => uint256) public"",
        ""Purpose"": ""Tracks the currently available liquidity for operations (updated by LiquidityPool).""
      },
      {
        ""Name"": ""totalLPFees"",
        ""Type"": ""mapping(address => uint256) public"",
        ""Purpose"": ""Tracks the total accumulated fees for each token.""
      },
      {
        ""Name"": ""totalSharesMinted"",
        ""Type"": ""mapping(address => uint256) public"",
        ""Purpose"": ""Tracks the total number of LP shares minted for each token across all LPs.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyValidLpToken"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the specified NFT ID exists and is owned by the transactor."",
        ""Parameters"": [""uint256 _tokenId"", ""address _transactor""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyLiquidityPool"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function execution to only the `liquidityPool` contract."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""tokenChecks"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Validates that the token address is not zero and is supported by the `tokenManager`."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract state (for upgradeability). Sets trusted forwarder, dependency addresses, owner, and pauser."",
        ""Parameters"": [""address _trustedForwarder"", ""address _lpToken"", ""address _tokenManager"", ""address _pauser""],
        ""Returns"": []
      },
      {
        ""Name"": ""addNativeLiquidity"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows users to add native ETH liquidity, minting a new LP NFT."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""addTokenLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to add ERC20 token liquidity, minting a new LP NFT."",
        ""Parameters"": [""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""increaseTokenLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to add more ERC20 liquidity to an existing LP NFT."",
        ""Parameters"": [""uint256 _nftId"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""increaseNativeLiquidity"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows users to add more native ETH liquidity to an existing LP NFT."",
        ""Parameters"": [""uint256 _nftId""],
        ""Returns"": []
      },
      {
        ""Name"": ""removeLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to remove a specified amount of principal liquidity and accrued fees associated with their LP NFT."",
        ""Parameters"": [""uint256 _nftId"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to claim only the accumulated fees associated with their LP NFT without removing principal."",
        ""Parameters"": [""uint256 _nftId""],
        ""Returns"": []
      },
      {
        ""Name"": ""addLPFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by the `liquidityPool` to record newly accrued fees for a token."",
        ""Parameters"": [""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""increaseCurrentLiquidity"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Increases the `currentLiquidity` count for a token (callable only by `liquidityPool`)."",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""decreaseCurrentLiquidity"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Decreases the `currentLiquidity` count for a token (callable only by `liquidityPool`)."",
        ""Parameters"": [""address tokenAddress"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLpToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to update the `lpToken` contract address."",
        ""Parameters"": [""address _lpToken""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTokenManager"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to update the `tokenManager` contract address."",
        ""Parameters"": [""address _tokenManager""],
        ""Returns"": []
      },
      {
        ""Name"": ""setWhiteListPeriodManager"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to update the `whiteListPeriodManager` contract address."",
        ""Parameters"": [""address _whiteListPeriodManager""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLiquidityPool"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to update the `liquidityPool` contract address."",
        ""Parameters"": [""address _liquidityPool""],
        ""Returns"": []
      },
      {
        ""Name"": ""getTokenPriceInLPShares"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates the 'price' of 1 unit of base token in terms of LP shares."",
        ""Parameters"": [""address _baseToken""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""sharesToTokenAmount"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Converts a given number of LP shares back into the equivalent amount of the underlying token."",
        ""Parameters"": [""uint256 _shares"", ""address _tokenAddress""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getFeeAccumulatedOnNft"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates the pending fee amount claimable for a specific LP NFT."",
        ""Parameters"": [""uint256 _nftId""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_transferFromLiquidityPool"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Helper function to call the `transfer` function on the `liquidityPool` contract."",
        ""Parameters"": [""address _tokenAddress"", ""address _receiver"", ""uint256 _tokenAmount""],
        ""Returns"": []
      },
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Fallback function to receive ETH, emits an event."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""`ILPToken`: Mints NFTs, updates/reads NFT metadata (token address, supplied liquidity, shares), checks ownership/existence."",
    ""`ILiquidityPool`: Receives token/ETH transfers when liquidity is added, executes token/ETH transfers when liquidity/fees are removed/claimed. Also calls this contract (`LiquidityProviders`) to update `currentLiquidity` and add fees."",
    ""`ITokenManager`: Checks if a token is supported (`getTokensInfo`)."",
    ""`IWhiteListPeriodManager`: Calls `beforeLiquidityAddition` and `beforeLiquidityRemoval` hooks."",
    ""`IERC20Upgradeable`: Interacts with ERC20 tokens for `transferFrom` and `allowance` checks."",
    ""`Trusted Forwarder`: Used by ERC2771Context for meta-transaction support (_msgSender verification).""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable Contract: Uses OpenZeppelin Initializable pattern."",
    ""LP Position as NFT: Leverages an external ERC721 contract (`ILPToken`) to represent user liquidity positions."",
    ""Separation of Concerns: Logic/accounting (this contract) is separate from fund holding (`LiquidityPool`)."",
    ""Share-Based Accounting: Uses an internal share system (`totalSharesMinted`, shares per NFT) proportional to reserves to track value and fees."",
    ""Reentrancy Guard: Protects key state-changing functions."",
    ""Pausable: Allows pausing critical operations."",
    ""Ownable: Configuration functions are owner-restricted."",
    ""ERC2771 Meta-transactions: Supports gasless transactions via a trusted forwarder.""
  ],
  ""Questions"": [
    ""What are the specific implementations and security measures of the `ILiquidityPool`, `ILPToken`, `ITokenManager`, and `IWhiteListPeriodManager` contracts?"",
    ""How is division precision handled in `getTokenPriceInLPShares`, `sharesToTokenAmount`, and related calculations? Are there potential issues with rounding errors or loss of value, especially for small amounts?"",
    ""The `unchecked` block in `getFeeAccumulatedOnNft` and `removeLiquidity` assumes `eligibleLiquidity >= nftSuppliedLiquidity`. What guarantees this invariant? What happens if it's violated due to edge cases or external contract behavior?"",
    ""In `removeLiquidity`, when `totalNFTShares - lpSharesToBurn < BASE_DIVISOR`, all remaining shares are burnt (`lpSharesToBurn = totalNFTShares`). Is this intended? Could it lead to minor amounts of principal liquidity being irrecoverable if the corresponding token amount is non-zero but very small?"",
    ""What logic does `whiteListPeriodManager` implement? Could its hooks (`beforeLiquidityAddition`/`Removal`) cause denial of service or unexpected reverts?"",
    ""Are there limits on the amount of liquidity (`_amount`) that can be added in a single transaction to prevent potential overflows in share calculations (e.g., `_amount * totalSharesMinted[token]`)?"",
    ""How does the `LiquidityPool` contract's `transfer` function handle potential failures or reentrancy if the receiver is a malicious contract?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability due to External Calls"",
      ""Severity"": ""High"",
      ""Description"": ""The `_transferFromLiquidityPool` function calls `liquidityPool.transfer`, an external call that could lead to reentrancy if the `liquidityPool` contract calls back into the `LiquidityProviders` contract before the state variables are updated. The `removeLiquidity` and `claimFee` functions also interact with the `liquidityPool` contract by calling the `transfer` function after state variables have been modified. Even though the contract uses `ReentrancyGuardUpgradeable`, it only protects the external functions. `addNativeLiquidity`, `addTokenLiquidity`, `increaseTokenLiquidity`, and `increaseNativeLiquidity` make external calls to `liquidityPool` or the ERC20 token contract, which could also lead to reentrancy."",
      ""Impact"": ""A malicious liquidity pool contract could drain funds from the `LiquidityProviders` contract, disrupt liquidity management, and compromise the security of the protocol. Malicious actors could potentially drain the contract of funds or manipulate the state of the contract to their advantage."",
      ""Location"": ""`_transferFromLiquidityPool`, `removeLiquidity`, `claimFee`, `addNativeLiquidity`, `addTokenLiquidity`, `increaseTokenLiquidity`, and `increaseNativeLiquidity` functions""
    },
    {
      ""Issue"": ""Lack of Input Validation in Setter Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setWhiteListPeriodManager`, `setLiquidityPool`, `setLpToken`, and `setTokenManager` functions allow the owner to set the addresses for external contracts. However, there is no validation to ensure that the provided addresses are not zero addresses or that the contracts at those addresses implement the expected interfaces. This could lead to unexpected behavior or contract failure if an invalid address is set."",
      ""Impact"": ""Setting an incorrect or malicious address for external contracts can disrupt the normal functioning of the `LiquidityProviders` contract, potentially leading to loss of funds or denial of service."",
      ""Location"": ""`setWhiteListPeriodManager`, `setLiquidityPool`, `setLpToken`, and `setTokenManager` functions, `initialize` function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Arithmetic Operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the function `sharesToTokenAmount`, the multiplication `_shares * totalReserve[_tokenAddress]` can potentially lead to an integer overflow. Similarly, integer underflow can occur in `getFeeAccumulatedOnNft` when `eligibleLiquidity - nftSuppliedLiquidity` if `nftSuppliedLiquidity > eligibleLiquidity`. Although unchecked is used, this is intentional to return zero. The calculation of `mintedSharesAmount` in `_increaseLiquidity` can also overflow. Calculations in `removeLiquidity` and `claimFee` can also underflow."",
      ""Impact"": ""Integer overflow or underflow can lead to incorrect calculations of token amounts or fees, potentially resulting in users receiving less than they are entitled to or, in the case of overflow, more than they are entitled to (in other contracts)."",
      ""Location"": ""`sharesToTokenAmount`, `getFeeAccumulatedOnNft`, `_increaseLiquidity`, `removeLiquidity`, and `claimFee` functions""
    },
    {
      ""Issue"": ""Lack of Slippage Control in `removeLiquidity`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `removeLiquidity` function calculates the amount of tokens to be withdrawn based on the provided `_amount` parameter and the internal calculations. However, there is no mechanism for the user to specify a minimum acceptable amount of tokens they are willing to receive (slippage control). This lack of slippage control could leave users vulnerable to front-running attacks or other scenarios where the calculated output amount changes unfavorably between the transaction submission and execution."",
      ""Impact"": ""Users may receive less tokens than expected when removing liquidity due to price fluctuations or malicious attacks."",
      ""Location"": ""`removeLiquidity` function""
    },
    {
      ""Issue"": ""Missing Access Control on `increaseCurrentLiquidity` and `decreaseCurrentLiquidity`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `increaseCurrentLiquidity` and `decreaseCurrentLiquidity` are only protected by the `onlyLiquidityPool` modifier. If the `liquidityPool` contract is compromised or contains vulnerabilities, it could call these functions with arbitrary amounts, leading to incorrect `currentLiquidity` values. With the use of `_msgSender()` the access control can be easily spoofed."",
      ""Impact"": ""A compromised `liquidityPool` contract could manipulate `currentLiquidity` values, leading to incorrect calculations and potentially enabling exploits in other functions that rely on this value."",
      ""Location"": ""`increaseCurrentLiquidity`, `decreaseCurrentLiquidity` and `_msgSender()` functions""
    },
    {
      ""Issue"": ""Incorrect Fee Calculation in `getFeeAccumulatedOnNft` and `removeLiquidity`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The calculation of `lpFeeAccumulated` in `getFeeAccumulatedOnNft` and `removeLiquidity` functions might lead to unexpected results due to potential underflow and flawed logic. The condition `if(nftSuppliedLiquidity > eligibleLiquidity)` may lead to zero fees accumulated even if there were fees. The inconsistency between using `getTokenPriceInLPShares` (which is `totalSharesMinted / totalReserve`) in other places and the direct calculation can further contribute to these errors."",
      ""Impact"": ""Incorrect fee calculations, potentially leading to users receiving incorrect rewards or being charged incorrectly when removing liquidity. The underflow could also affect the overall accounting of the contract."",
      ""Location"": ""`getFeeAccumulatedOnNft` function, `removeLiquidity` function""
    },
    {
      ""Issue"": ""Potential Division by Zero in Share and Price Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `sharesToTokenAmount` function divides by `totalSharesMinted[_tokenAddress]`. The `getTokenPriceInLPShares` divides by `totalReserve[_baseToken]`. If either divisor is zero, the division will revert the transaction."",
      ""Impact"": ""Denial of Service (DoS) by preventing users from removing liquidity."",
      ""Location"": ""`sharesToTokenAmount` and `getTokenPriceInLPShares` functions""
    },
    {
      ""Issue"": ""Centralization Risk: Reliance on External Contracts"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract heavily relies on external contracts such as `ILPToken`, `ITokenManager`, `IWhiteListPeriodManager`, and `ILiquidityPool`. If any of these contracts are compromised or malfunction, the `LiquidityProviders` contract will be affected. The contract relies on the proper implementation of the WhiteListPeriodManager, which could be vulnerable if misconfigured."",
      ""Impact"": ""Potential for significant disruptions to the platform\'s functionality and loss of funds if any of the external contracts are compromised."",
      ""Location"": ""Throughout the contract, wherever external contract functions are called.""
    },
    {
      ""Issue"": ""Lack of Check for Sufficient Balance Before Transferring From Liquidity Pool"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_transferFromLiquidityPool` function does not check if the `liquidityPool` has sufficient balance of the specified token before attempting to transfer. If the `liquidityPool` does not have enough tokens, the transfer will fail, and the user will not receive their tokens."",
      ""Impact"": ""Users may not be able to withdraw their liquidity if the liquidity pool doesn't have enough balance."",
      ""Location"": ""function `_transferFromLiquidityPool`""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `increaseNativeLiquidity` and `increaseTokenLiquidity`"",
      ""Severity"": ""Medium"",
      ""Description"": ""A user could monitor the mempool for `increaseNativeLiquidity` and `increaseTokenLiquidity` transactions, and front-run the original transaction by submitting their own transaction with a higher gas price."",
      ""Impact"": ""Front-running could allow a malicious actor to manipulate the LP token price or extract value at the expense of other users."",
      ""Location"": ""Functions `increaseNativeLiquidity`, `increaseTokenLiquidity`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Share Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `_increaseLiquidity` function, the calculation of `mintedSharesAmount` involves multiplying `_amount` by `totalSharesMinted[token]` and then dividing by `totalReserve[token]`. If `_amount * totalSharesMinted[token]` is large enough, it could potentially lead to an integer overflow before the division, resulting in a significantly smaller `mintedSharesAmount` than expected. Similar issues can occur when calculating fees when removing liquidity"",
      ""Impact"": ""Incorrect calculation of minted shares, potentially leading to incorrect accounting of user\'s liquidity position and affecting their ability to remove liquidity or claim fees."",
      ""Location"": ""_increaseLiquidity function""
    },
     {
      ""Issue"": ""Rounding Errors in Share Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The calculations for `mintedSharesAmount` in `_increaseLiquidity` involve integer division, which can lead to rounding errors. These errors can accumulate over time and cause minor discrepancies in the calculated amounts."",
      ""Impact"": ""Minor inaccuracies in the calculated amounts, which may slightly disadvantage users over time."",
      ""Location"": ""function `_increaseLiquidity`""
    },
    {
      ""Issue"": ""Unprotected `EthReceived` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `receive()` function allows the contract to receive ETH. However, it lacks any specific logic other than emitting an event. An unexpected or large amount of ETH being sent directly to the contract could lead to unexpected state changes. It is recommended to revert the transaction if ETH is sent unintentionally."",
      ""Impact"": ""Unintentional or malicious sending of ETH to the contract may cause unexpected behavior, especially if other parts of the system are not designed to properly account for the ETH held directly by this contract. While not immediately exploitable, it increases the attack surface and potential for future vulnerabilities."",
      ""Location"": ""`receive()` function""
    },
     {
      ""Issue"": ""Potential Denial of Service in `removeLiquidity` and `claimFee` due to extreme `getTokenPriceInLPShares` values."",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `removeLiquidity` and `claimFee` rely on `getTokenPriceInLPShares` to determine share values. If `totalSharesMinted[_baseToken]` is significantly larger than `totalReserve[_baseToken]`, the result of `getTokenPriceInLPShares` could be very close to zero (due to integer division). In the `removeLiquidity` function the if statement will always evaluate to true if lpSharesToBurn is larger than totalNFTShares."",
      ""Impact"": ""Possible DoS if the `getTokenPriceInLPShares` results in unexpected values because it causes inconsistent state changes."",
      ""Location"": ""LiquidityProviders.sol:removeLiquidity, LiquidityProviders.sol:claimFee, LiquidityProviders.sol:getTokenPriceInLPShares""
    },
     {
      ""Issue"": ""Potential for denial of service in edge case"",
      ""Severity"": ""Low"",
      ""Description"": ""The claimFee function calculates the amount of lpFeeAccumulated based on a subtraction. `uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;`. If the `totalNFTShares` is very small, and then the calculated `eligibleLiquidity` is also very small, then this can result in someone constantly claiming trivial amounts of fee, causing high gas usage and potentially blocking others from using the contract."",
      ""Impact"": ""Potentially high gas usage can block people from interacting with the contract"",
      ""Location"": ""claimFee function""
    },
    {
      ""Issue"": ""Missing input validation in `_addLiquidity` and `_increaseLiquidity` functions for zero address when minting NFT"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_addLiquidity` and `_increaseLiquidity` functions mint an NFT via `lpToken.mint(_msgSender())`. There isn't a direct validation to ensure that it's not a zero address before minting the NFT. If, due to some unforeseen circumstances, the `_msgSender()` resolves to the zero address, the NFT will be assigned to the zero address, leading to a permanent loss of control over the NFT."",
      ""Impact"": ""Loss of control over newly minted NFTs if the sender is unexpectedly the zero address."",
      ""Location"": ""LiquidityProviders.sol:_addLiquidity, LiquidityProviders.sol:_increaseLiquidity""
    },
    {
      ""Issue"": ""Potential Denial of Service in `increaseTokenLiquidity` and `increaseNativeLiquidity` due to token transfer failure"",
      ""Severity"": ""Low"",
      ""Description"": ""If the `SafeERC20Upgradeable.safeTransferFrom` call in `increaseTokenLiquidity` or the native transfer in `increaseNativeLiquidity` fails after `msg.value` has been transfered to the contract (and liquidityPool), the contract will be in an inconsistent state. Specifically, the user\'s NFT will have increased liquidity recorded for it, but the contract will not have the funds."",
      ""Impact"": ""The `increaseTokenLiquidity` and `increaseNativeLiquidity` functions may become unusable for certain tokens or users if the token transfer consistently fails. The users NFT is permanently in a inconsistent state."",
      ""Location"": ""`increaseTokenLiquidity` and `increaseNativeLiquidity` functions""
    },
    {
      ""Issue"": ""Unchecked Arithmetic in `getFeeAccumulatedOnNft`"",
      ""Severity"": ""Informational"",
      ""Description"": ""The function `getFeeAccumulatedOnNft` has an unchecked block:  `unchecked { lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity; }`. While the code has a check `if(nftSuppliedLiquidity > eligibleLiquidity)` to prevent underflow on the subtraction, it\'s still good practice to document the reasoning behind using the `unchecked` block. This increases code readability and maintainability."",
      ""Impact"": ""Lack of clarity about the rationale behind using an `unchecked` block."",
      ""Location"": ""getFeeAccumulatedOnNft function""
    },
    {
      ""Issue"": ""Unnecessary checked arithmetic in `removeLiquidity`"",
      ""Severity"": ""Info"",
      ""Description"": ""Since Solidity 0.8.0, arithmetic operations revert on overflow/underflow. The explicit check `if(nftSuppliedLiquidity > eligibleLiquidity)` followed by an unchecked block appears unnecessary since `eligibleLiquidity - nftSuppliedLiquidity` will only execute if `eligibleLiquidity >= nftSuppliedLiquidity` due to the previous if statement, meaning the `unchecked` block is redundant."",
      ""Impact"": ""Code clarity. Removing the explicit check and the `unchecked` block can simplify the code and make it more readable."",
      ""Location"": ""Function `removeLiquidity`""
    }
  ],
  ""IssueNumber"": 48,
  ""OutputList"": 19
}",238.2484579086304,3806.0,32.0,"### **[H-02] LiquidityProviders.sol: The share price of the LP can be manipulated, making future liquidity providers unable to removeLiquidity()**

**Report Description**:  
The `removeLiquidity` function in `LiquidityProviders.sol` calculates the amount of tokens to be withdrawn based on the share price of the LP token. However, the share price can be manipulated, leading to incorrect calculations. This manipulation can make future liquidity providers unable to withdraw their liquidity, as the share price may not accurately reflect the underlying token reserves. This issue arises due to the reliance on `getTokenPriceInLPShares`, which divides `totalSharesMinted` by `totalReserve`. If `totalReserve` is manipulated or becomes zero, the share price calculation will be incorrect, potentially leading to denial of service for liquidity providers.

**Match in Response List**:  
Matches with the issue titled **""Potential Division by Zero in Share and Price Calculations""**.

**Validation**:  
**Correct**. The response accurately identifies the risk of division by zero in the `getTokenPriceInLPShares` function, which directly impacts the share price calculation. This aligns with the issue described in the report, where manipulation of the share price can prevent liquidity providers from withdrawing their funds.

---

### **[M-01] Unsupported tokens cannot be withdrawn**

**Report Description**:  
The `removeLiquidity` function in `LiquidityProviders.sol` includes a check to ensure that the token being withdrawn is supported (`require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");`). However, if a supported token is later removed via `TokenManager.removeSupportedToken`, users will be unable to withdraw their liquidity. This creates a permanent lock of funds for users who deposited tokens that are no longer supported.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of unsupported tokens being locked in the contract. This is a critical oversight, as it directly impacts user funds and contract functionality.

---

### **[M-11] LiquidityProviders: Setting new liquidity pool will break contract**

**Report Description**:  
The `setLiquidityPool` function allows the owner to change the `liquidityPool` address. However, if users have already added liquidity to the previous liquidity pool, changing the address will make it impossible for users to withdraw their liquidity. This is because the tokens are stored in the old liquidity pool, and the new pool will not have access to these funds.

**Match in Response List**:  
Matches with the issue titled **""Centralization Risk: Reliance on External Contracts""**.

**Validation**:  
**Partially Correct**. The response identifies the centralization risk associated with relying on external contracts, but it does not specifically address the issue of changing the `liquidityPool` address and its impact on user withdrawals. The response could be improved by explicitly mentioning this scenario.

---

### **[M-12] LiquidityProviders: Setting new LP token will break contract**

**Report Description**:  
The `setLpToken` function allows the owner to change the `lpToken` address. If users have already added liquidity and received LP tokens from the previous `lpToken` contract, changing the address will make it impossible for users to withdraw their liquidity. This is because the new `lpToken` contract will not recognize the old LP tokens, leading to a permanent loss of funds.

**Match in Response List**:  
Matches with the issue titled **""Centralization Risk: Reliance on External Contracts""**.

**Validation**:  
**Partially Correct**. Similar to [M-11], the response identifies the centralization risk but does not specifically address the issue of changing the `lpToken` address and its impact on user withdrawals. The response could be improved by explicitly mentioning this scenario.

---

### **[M-17] Wrong condition checking in price calculation**

**Report Description**:  
The `getTokenPriceInLPShares` function checks if `totalSharesMinted` is zero instead of checking if `totalReserve` is zero. This is incorrect because the function should return `BASE_DIVISOR` if `totalReserve` is zero, not `totalSharesMinted`. This flaw can lead to incorrect price calculations or division by zero errors.

**Match in Response List**:  
Matches with the issue titled **""Potential Division by Zero in Share and Price Calculations""**.

**Validation**:  
**Correct**. The response accurately identifies the risk of division by zero in the `getTokenPriceInLPShares` function, which aligns with the issue described in the report. The response could be improved by explicitly mentioning the incorrect condition check.

---

### **[M-19] sharesToTokenAmount: Division by zero**

**Report Description**:  
The `sharesToTokenAmount` function divides by `totalSharesMinted[_tokenAddress]` without checking if it is zero. If `totalSharesMinted[_tokenAddress]` is zero, the function will revert, preventing users from withdrawing their liquidity. This issue is not handled by the callers of this function, leading to potential denial of service.

**Match in Response List**:  
Matches with the issue titled **""Potential Division by Zero in Share and Price Calculations""**.

**Validation**:  
**Correct**. The response accurately identifies the risk of division by zero in the `sharesToTokenAmount` function, which aligns with the issue described in the report.

---

### **[M-20] Liquidity providers unable to remove liquidity when the pool is in deficit state**

**Report Description**:  
The `removeLiquidity` function calculates the amount of tokens to be withdrawn based on `providedLiquidity`, but the actual available balance in the pool is based on `currentLiquidity`. If the pool is in a deficit state (`currentLiquidity << providedLiquidity`), liquidity providers will be unable to withdraw their tokens, as the pool does not have enough funds to cover the withdrawals.

**Match in Response List**:  
Matches with the issue titled **""Lack of Check for Sufficient Balance Before Transferring From Liquidity Pool""**.

**Validation**:  
**Correct**. The response accurately identifies the risk of insufficient balance in the liquidity pool, which aligns with the issue described in the report. The response could be improved by explicitly mentioning the deficit state scenario.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] LiquidityProviders.sol: The share price of the LP can be manipulated, making future liquidity providers unable to removeLiquidity()**
- **[M-17] Wrong condition checking in price calculation**
- **[M-19] sharesToTokenAmount: Division by zero**
- **[M-20] Liquidity providers unable to remove liquidity when the pool is in deficit state**

**Partially Correct Matches**:

- **[M-11] LiquidityProviders: Setting new liquidity pool will break contract**
- **[M-12] LiquidityProviders: Setting new LP token will break contract**

**Missed Issues from Issue Report**:

- **[M-01] Unsupported tokens cannot be withdrawn**

--- 

This analysis highlights the strengths and gaps in the response list, providing actionable insights for improving the coverage and accuracy of the findings.","```
1. Potential Division by Zero in Share and Price Calculations
2. Lack of Check for Sufficient Balance Before Transferring From Liquidity Pool
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Potential Division by Zero in Share and Price Calculations"" appears at rank 7.
   - ""Lack of Check for Sufficient Balance Before Transferring From Liquidity Pool"" appears at rank 9.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 7: \( P@7 = \frac{1}{7} \approx 0.1429 \)
   - For rank 9: \( P@9 = \frac{2}{9} \approx 0.2222 \)

3. **Average the precision values to compute the Average Precision (AP)**:
   \[
   AP = \frac{0.1429 + 0.2222}{2} \approx 0.1826
   \]

**Output**:
```
0.1826
```"
LiquidityFarming.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ILiquidityProviders.sol"";

contract HyphenLiquidityFarming is
    Initializable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable,
    ReentrancyGuardUpgradeable,
    IERC721ReceiverUpgradeable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    ILPToken public lpToken;
    ILiquidityProviders public liquidityProviders;

    struct NFTInfo {
        address payable staker;
        uint256 rewardDebt;
        uint256 unpaidRewards;
        bool isStaked;
    }

    struct PoolInfo {
        uint256 accTokenPerShare;
        uint256 lastRewardTime;
    }

    struct RewardsPerSecondEntry {
        uint256 rewardsPerSecond;
        uint256 timestamp;
    }

    /// @notice Mapping to track the rewarder pool.
    mapping(address => PoolInfo) public poolInfo;

    /// @notice Info of each NFT that is staked.
    mapping(uint256 => NFTInfo) public nftInfo;

    /// @notice Reward rate per base token
    //mapping(address => uint256) public rewardPerSecond;

    /// @notice Reward Token
    mapping(address => address) public rewardTokens;

    /// @notice Staker => NFTs staked
    mapping(address => uint256[]) public nftIdsStaked;

    /// @notice Token => Total Shares Staked
    mapping(address => uint256) public totalSharesStaked;

    /// @notice Token => Reward Rate Updation history
    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;

    uint256 private constant ACC_TOKEN_PRECISION = 1e12;
    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);
    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);
    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);
    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);
    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);
    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);
    event LogNativeReceived(address indexed sender, uint256 value);

    function initialize(
        address _trustedForwarder,
        address _pauser,
        ILiquidityProviders _liquidityProviders,
        ILPToken _lpToken
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        liquidityProviders = _liquidityProviders;
        lpToken = _lpToken;
    }

    /// @notice Initialize the rewarder pool.
    /// @param _baseToken Base token to be used for the rewarder pool.
    /// @param _rewardToken Reward token to be used for the rewarder pool.
    /// @param _rewardPerSecond Reward rate per base token.
    function initalizeRewardPool(
        address _baseToken,
        address _rewardToken,
        uint256 _rewardPerSecond
    ) external onlyOwner {
        require(rewardTokens[_baseToken] == address(0), ""ERR__POOL_ALREADY_INITIALIZED"");
        require(_baseToken != address(0), ""ERR__BASE_TOKEN_IS_ZERO"");
        require(_rewardToken != address(0), ""ERR_REWARD_TOKEN_IS_ZERO"");
        rewardTokens[_baseToken] = _rewardToken;
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);
    }

    function _sendErc20AndGetSentAmount(
        IERC20Upgradeable _token,
        uint256 _amount,
        address _to
    ) private returns (uint256) {
        uint256 recepientBalance = _token.balanceOf(_to);
        _token.safeTransfer(_to, _amount);
        return _token.balanceOf(_to) - recepientBalance;
    }

    /// @notice Update the reward state of a nft, and if possible send reward funds to _to.
    /// @param _nftId NFT ID that is being locked
    /// @param _to Address to which rewards will be credited.
    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {
        NFTInfo storage nft = nftInfo[_nftId];
        require(nft.isStaked, ""ERR__NFT_NOT_STAKED"");

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = updatePool(baseToken);
        uint256 pending;
        uint256 amountSent;
        if (amount > 0) {
            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
            if (rewardTokens[baseToken] == NATIVE) {
                uint256 balance = address(this).balance;
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    (bool success, ) = _to.call{value: balance}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = balance;
                } else {
                    nft.unpaidRewards = 0;
                    (bool success, ) = _to.call{value: pending}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = pending;
                }
            } else {
                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);
                uint256 balance = rewardToken.balanceOf(address(this));
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);
                } else {
                    nft.unpaidRewards = 0;
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);
                }
            }
        }
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;
        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);
    }

    /// @notice Sets the sushi per second to be distributed. Can only be called by the owner.
    /// @param _rewardPerSecond The amount of Sushi to be distributed per second.
    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);
    }

    /// @notice Allows owner to reclaim/withdraw any tokens (including reward tokens) held by this contract
    /// @param _token Token to reclaim, use 0x00 for Ethereum
    /// @param _amount Amount of tokens to reclaim
    /// @param _to Receiver of the tokens, first of his name, rightful heir to the lost tokens,
    /// reightful owner of the extra tokens, and ether, protector of mistaken transfers, mother of token reclaimers,
    /// the Khaleesi of the Great Token Sea, the Unburnt, the Breaker of blockchains.
    function reclaimTokens(
        address _token,
        uint256 _amount,
        address payable _to
    ) external nonReentrant onlyOwner {
        require(_to != address(0), ""ERR__TO_IS_ZERO"");
        if (_token == NATIVE) {
            (bool success, ) = payable(_to).call{value: _amount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable(_token).safeTransfer(_to, _amount);
        }
    }

    /// @notice Deposit LP tokens
    /// @param _nftId LP token nftId to deposit.
    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();

        require(
            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),
            ""ERR__NOT_APPROVED""
        );

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        require(rewardTokens[baseToken] != address(0), ""ERR__POOL_NOT_INITIALIZED"");
        require(rewardRateLog[baseToken].length != 0, ""ERR__POOL_NOT_INITIALIZED"");

        NFTInfo storage nft = nftInfo[_nftId];
        require(!nft.isStaked, ""ERR__NFT_ALREADY_STAKED"");

        lpToken.safeTransferFrom(msgSender, address(this), _nftId);

        PoolInfo memory pool = updatePool(baseToken);
        nft.isStaked = true;
        nft.staker = _to;
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;

        nftIdsStaked[_to].push(_nftId);
        totalSharesStaked[baseToken] += amount;

        emit LogDeposit(msgSender, baseToken, _nftId);
    }

    /// @notice Withdraw LP tokens
    /// @param _nftId LP token nftId to withdraw.
    /// @param _to The receiver of `amount` withdraw benefit.
    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();
        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;
        uint256 index;
        for (index = 0; index < nftsStakedLength; ++index) {
            if (nftIdsStaked[msgSender][index] == _nftId) {
                break;
            }
        }

        require(index != nftsStakedLength, ""ERR__NFT_NOT_STAKED"");
        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];
        nftIdsStaked[msgSender].pop();

        _sendRewardsForNft(_nftId, _to);
        delete nftInfo[_nftId];

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();
        totalSharesStaked[baseToken] -= amount;

        lpToken.safeTransferFrom(address(this), msgSender, _nftId);

        emit LogWithdraw(msgSender, baseToken, _nftId, _to);
    }

    /// @notice Extract all rewards without withdrawing LP tokens
    /// @param _nftId LP token nftId for which rewards are to be withdrawn
    /// @param _to The receiver of withdraw benefit.
    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        require(nftInfo[_nftId].staker == _msgSender(), ""ERR__NOT_OWNER"");
        _sendRewardsForNft(_nftId, _to);
    }

    /// @notice Calculates an up to date value of accTokenPerShare
    /// @notice An updated value of accTokenPerShare is comitted to storage every time a new NFT is deposited, withdrawn or rewards are extracted
    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {
        uint256 accumulator = 0;
        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;
        uint256 counter = block.timestamp;
        uint256 i = rewardRateLog[_baseToken].length - 1;
        while (true) {
            if (lastUpdatedTime >= counter) {
                break;
            }
            unchecked {
                accumulator +=
                    rewardRateLog[_baseToken][i].rewardsPerSecond *
                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));
            }
            counter = rewardRateLog[_baseToken][i].timestamp;
            if (i == 0) {
                break;
            }
            --i;
        }

        // We know that during all the periods that were included in the current iterations,
        // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the
        // updates to the pool that happened after the lastUpdatedTime.
        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];
        return accumulator + poolInfo[_baseToken].accTokenPerShare;
    }

    /// @notice View function to see pending Token
    /// @param _nftId NFT for which pending tokens are to be viewed
    /// @return pending reward for a given user.
    function pendingToken(uint256 _nftId) external view returns (uint256) {
        NFTInfo storage nft = nftInfo[_nftId];
        if (!nft.isStaked) {
            return 0;
        }

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = poolInfo[baseToken];
        uint256 accToken1PerShare = pool.accTokenPerShare;
        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {
            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);
        }
        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
    }

    /// @notice Update reward variables of the given pool.
    /// @return pool Returns the pool that was updated.
    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {
        pool = poolInfo[_baseToken];
        if (block.timestamp > pool.lastRewardTime) {
            if (totalSharesStaked[_baseToken] > 0) {
                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);
            }
            pool.lastRewardTime = block.timestamp;
            poolInfo[_baseToken] = pool;
            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);
        }
    }

    /// @notice View function to see the tokens staked by a given user.
    /// @param _user Address of user.
    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {
        nftIds = nftIdsStaked[_user];
    }

    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {
        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {
        return bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)""));
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit LogNativeReceived(_msgSender(), msg.value);
    }

    function max(uint256 _a, uint256 _b) private pure returns (uint256) {
        return _a >= _b ? _a : _b;
    }
}",3691,373,"[H-04] Deleting nft Info can cause users' nft.unpaidRewards to be permanently erased
 In `_sendRewardsForNft()`, when `address(this).balance` is insufficient at the moment, `nft.unpaidRewards = pending - balance` will be recorded and the user can get it back at the next time.
However, at L244, the whole nftInfo is being deleted, so that nft.unpaidRewards will also get erased.
There is no way for the user to get back this unpaidRewards anymore
  [H-05] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss

Submitted by WatchPug, also found by hyh
LiquidityFarming.sol#L265-L291
function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) 
  [M-04] Owners have absolute control over protocol

Submitted by throttle, also found by cccz, cmichel, danb, defsec, hickuphh3, IllIllI, pedroais, and Ruhum
LiquidityFarming.sol#L174-L192
Owners have full control over the protocol.

[M-06] DoS by gas limit

Submitted by danb, also found by benk10 and pedroais
LiquidityFarming.sol#L220 LiquidityFarming.sol#L233
In `deposit` function it is possible to push to nftIdsStaked of anyone, an attacker can deposit too many nfts to another user, and when the user will try to withdraw an nft at the end of the list, they will iterate on the list and revert because of gas limit.
 [M-10] Call to non-existing contracts returns success

Submitted by CertoraInc, also found by kenta and wuwe1
LiquidityFarming.sol#L140 LiquidityFarming.sol#L145 LiquidityFarming.sol#L187
Low level calls (call, delegate call and static call) return success if the called contract doesn’t exist (not deployed or destructed).
This makes a user be able to send his funds to non-existing addresses.
 [M-14] LiquidityFarming.sol Unbounded for loops can potentially freeze users' funds in edge cases

Submitted by WatchPug
In the current implementation of withdraw(), it calls _sendRewardsForNft() at L243 which calls updatePool() at L129 which calls getUpdatedAccTokenPerShare() at L319.
getUpdatedAccTokenPerShare() will loop over rewardRateLog to calculate an up to date value of accTokenPerShare.
LiquidityFarming.sol#L270-L285
",6,,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ILiquidityProviders.sol"";

contract HyphenLiquidityFarming is
    Initializable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable,
    ReentrancyGuardUpgradeable,
    IERC721ReceiverUpgradeable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    ILPToken public lpToken;
    ILiquidityProviders public liquidityProviders;

    struct NFTInfo {
        address payable staker;
        uint256 rewardDebt;
        uint256 unpaidRewards;
        bool isStaked;
    }

    struct PoolInfo {
        uint256 accTokenPerShare;
        uint256 lastRewardTime;
    }

    struct RewardsPerSecondEntry {
        uint256 rewardsPerSecond;
        uint256 timestamp;
    }

    
    mapping(address => PoolInfo) public poolInfo;

    
    mapping(uint256 => NFTInfo) public nftInfo;

    
    

    
    mapping(address => address) public rewardTokens;

    
    mapping(address => uint256[]) public nftIdsStaked;

    
    mapping(address => uint256) public totalSharesStaked;

    
    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;

    uint256 private constant ACC_TOKEN_PRECISION = 1e12;
    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);
    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);
    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);
    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);
    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);
    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);
    event LogNativeReceived(address indexed sender, uint256 value);

    function initialize(
        address _trustedForwarder,
        address _pauser,
        ILiquidityProviders _liquidityProviders,
        ILPToken _lpToken
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        liquidityProviders = _liquidityProviders;
        lpToken = _lpToken;
    }

    
    
    
    
    function initalizeRewardPool(
        address _baseToken,
        address _rewardToken,
        uint256 _rewardPerSecond
    ) external onlyOwner {
        require(rewardTokens[_baseToken] == address(0), ""ERR__POOL_ALREADY_INITIALIZED"");
        require(_baseToken != address(0), ""ERR__BASE_TOKEN_IS_ZERO"");
        require(_rewardToken != address(0), ""ERR_REWARD_TOKEN_IS_ZERO"");
        rewardTokens[_baseToken] = _rewardToken;
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);
    }

    function _sendErc20AndGetSentAmount(
        IERC20Upgradeable _token,
        uint256 _amount,
        address _to
    ) private returns (uint256) {
        uint256 recepientBalance = _token.balanceOf(_to);
        _token.safeTransfer(_to, _amount);
        return _token.balanceOf(_to) - recepientBalance;
    }

    
    
    
    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {
        NFTInfo storage nft = nftInfo[_nftId];
        require(nft.isStaked, ""ERR__NFT_NOT_STAKED"");

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = updatePool(baseToken);
        uint256 pending;
        uint256 amountSent;
        if (amount > 0) {
            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
            if (rewardTokens[baseToken] == NATIVE) {
                uint256 balance = address(this).balance;
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    (bool success, ) = _to.call{value: balance}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = balance;
                } else {
                    nft.unpaidRewards = 0;
                    (bool success, ) = _to.call{value: pending}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = pending;
                }
            } else {
                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);
                uint256 balance = rewardToken.balanceOf(address(this));
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);
                } else {
                    nft.unpaidRewards = 0;
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);
                }
            }
        }
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;
        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);
    }

    
    
    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);
    }

    
    
    
    
    
    
    function reclaimTokens(
        address _token,
        uint256 _amount,
        address payable _to
    ) external nonReentrant onlyOwner {
        require(_to != address(0), ""ERR__TO_IS_ZERO"");
        if (_token == NATIVE) {
            (bool success, ) = payable(_to).call{value: _amount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable(_token).safeTransfer(_to, _amount);
        }
    }

    
    
    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();

        require(
            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),
            ""ERR__NOT_APPROVED""
        );

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        require(rewardTokens[baseToken] != address(0), ""ERR__POOL_NOT_INITIALIZED"");
        require(rewardRateLog[baseToken].length != 0, ""ERR__POOL_NOT_INITIALIZED"");

        NFTInfo storage nft = nftInfo[_nftId];
        require(!nft.isStaked, ""ERR__NFT_ALREADY_STAKED"");

        lpToken.safeTransferFrom(msgSender, address(this), _nftId);

        PoolInfo memory pool = updatePool(baseToken);
        nft.isStaked = true;
        nft.staker = _to;
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;

        nftIdsStaked[_to].push(_nftId);
        totalSharesStaked[baseToken] += amount;

        emit LogDeposit(msgSender, baseToken, _nftId);
    }

    
    
    
    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();
        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;
        uint256 index;
        for (index = 0; index < nftsStakedLength; ++index) {
            if (nftIdsStaked[msgSender][index] == _nftId) {
                break;
            }
        }

        require(index != nftsStakedLength, ""ERR__NFT_NOT_STAKED"");
        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];
        nftIdsStaked[msgSender].pop();

        _sendRewardsForNft(_nftId, _to);
        delete nftInfo[_nftId];

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();
        totalSharesStaked[baseToken] -= amount;

        lpToken.safeTransferFrom(address(this), msgSender, _nftId);

        emit LogWithdraw(msgSender, baseToken, _nftId, _to);
    }

    
    
    
    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        require(nftInfo[_nftId].staker == _msgSender(), ""ERR__NOT_OWNER"");
        _sendRewardsForNft(_nftId, _to);
    }

    
    
    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {
        uint256 accumulator = 0;
        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;
        uint256 counter = block.timestamp;
        uint256 i = rewardRateLog[_baseToken].length - 1;
        while (true) {
            if (lastUpdatedTime >= counter) {
                break;
            }
            unchecked {
                accumulator +=
                    rewardRateLog[_baseToken][i].rewardsPerSecond *
                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));
            }
            counter = rewardRateLog[_baseToken][i].timestamp;
            if (i == 0) {
                break;
            }
            --i;
        }

        
        
        
        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];
        return accumulator + poolInfo[_baseToken].accTokenPerShare;
    }

    
    
    
    function pendingToken(uint256 _nftId) external view returns (uint256) {
        NFTInfo storage nft = nftInfo[_nftId];
        if (!nft.isStaked) {
            return 0;
        }

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = poolInfo[baseToken];
        uint256 accToken1PerShare = pool.accTokenPerShare;
        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {
            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);
        }
        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
    }

    
    
    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {
        pool = poolInfo[_baseToken];
        if (block.timestamp > pool.lastRewardTime) {
            if (totalSharesStaked[_baseToken] > 0) {
                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);
            }
            pool.lastRewardTime = block.timestamp;
            poolInfo[_baseToken] = pool;
            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);
        }
    }

    
    
    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {
        nftIds = nftIdsStaked[_user];
    }

    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {
        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {
        return bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)""));
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit LogNativeReceived(_msgSender(), msg.value);
    }

    function max(uint256 _a, uint256 _b) private pure returns (uint256) {
        return _a >= _b ? _a : _b;
    }
}",3032,2,4,"{
  ""task_list"": [
    {
      ""Area"": ""Reward Calculation and Distribution"",
      ""Tasks"": [
        ""Verify the correctness of the `getUpdatedAccTokenPerShare` function. Pay close attention to edge cases where `totalSharesStaked[_baseToken]` is zero and when the current timestamp is earlier than the first entry in `rewardRateLog[_baseToken]`."",
        ""Analyze the `_sendRewardsForNft` function to ensure that reward distribution is accurate, especially when dealing with native ETH and ERC20 tokens and insufficient contract balances. Verify that `unpaidRewards` is correctly updated."",
        ""Check for potential rounding errors in reward calculations that could lead to loss of precision or incorrect reward distribution. Analyze the impact of `ACC_TOKEN_PRECISION`."",
        ""Simulate reward accumulation and distribution over extended periods with varying reward rates to ensure stability and accuracy."",
        ""Investigate the logic within `_sendRewardsForNft` when `pending > balance` for both native ETH and ERC20 rewards. Ensure that users receive maximum possible rewards and the remaining `unpaidRewards` are tracked correctly."",
        ""Verify that rewards are correctly calculated and distributed when reward rates are changed frequently via `setRewardPerSecond`.""
      ]
    },
    {
      ""Area"": ""Access Control and Ownership"",
      ""Tasks"": [
        ""Confirm that only the contract owner can call functions with the `onlyOwner` modifier."",
        ""Verify the integrity of the `initialize` function to ensure the owner, pauser, trusted forwarder, liquidityProviders, and lpToken are set correctly and only once."",
        ""Assess the potential impact of a malicious or compromised owner. Can the owner drain funds, halt the contract indefinitely, or unfairly manipulate reward distribution?"",
        ""Ensure the `_pauser` role from the `Pausable` contract functions as intended and that pausing/unpausing works correctly.""
      ]
    },
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Analyze all external calls (e.g., to `lpToken`, reward tokens, and during ETH transfers) for potential reentrancy vulnerabilities, despite the use of `nonReentrant` modifier."",
        ""Specifically examine the interaction with the reward token in `_sendErc20AndGetSentAmount`. If the reward token implements a callback on transfer, it could potentially re-enter the contract."",
        ""Consider the reentrancy implications if the LP token or reward token contracts are malicious or have unexpected behavior.""
      ]
    },
    {
      ""Area"": ""Pausability and Emergency States"",
      ""Tasks"": [
        ""Verify that the `whenNotPaused` modifier functions correctly across all relevant functions."",
        ""Evaluate the impact of pausing the contract on users who have staked NFTs. What happens to reward accumulation during the paused state, and how are rewards handled upon unpausing?"",
        ""Assess the recovery procedures and potential risks associated with the contract being paused indefinitely. Consider adding an emergency unpause mechanism with a timelock."",
        ""If the contract is paused, can a malicious owner extract all assets using `reclaimTokens`? This could be undesirable and needs careful consideration.""
      ]
    },
    {
      ""Area"": ""NFT Staking and Withdrawal Logic"",
      ""Tasks"": [
        ""Investigate the logic in `deposit` and `withdraw` functions to ensure that NFT transfers and state updates are performed correctly."",
        ""Analyze the gas costs associated with the linear search in the `withdraw` function for large numbers of staked NFTs. Consider using a more efficient data structure like a mapping to track NFT ownership for faster lookups."",
        ""Verify that the `lpToken.tokenMetadata(_nftId)` function returns consistent and reliable data. Any inconsistencies could lead to incorrect reward calculations or unexpected behavior."",
        ""Ensure that the `isApprovedForAll` and `getApproved` checks in `deposit` function correctly prevent unauthorized staking of NFTs."",
        ""Confirm that the `extractRewards` function correctly identifies the NFT owner (`nftInfo[_nftId].staker == _msgSender()`).""
      ]
    },
    {
      ""Area"": ""Token Handling and Reclaim Functionality"",
      ""Tasks"": [
        ""Carefully review the `reclaimTokens` function to ensure that it cannot be used to drain the contract of staked LP tokens. Consider limiting reclaimable tokens to only reward tokens and ETH."",
        ""Verify that the `_sendErc20AndGetSentAmount` function handles fee-on-transfer tokens correctly. If the recipient receives less than the intended amount, ensure that the logic accounts for this difference."",
        ""In `reclaimTokens`, verify that the `_amount` parameter is not larger than the contract's balance of the respective token to prevent underflow."",
        ""Ensure that the `receive()` function is safe and does not introduce any vulnerabilities. Log all native ETH received for auditability.""
      ]
    },
    {
      ""Area"": ""Upgradeability Considerations"",
      ""Tasks"": [
        ""Verify that the initialization logic in `initialize` function follows the upgradeable contract pattern and is only called once."",
        ""Consider potential storage collision issues when upgrading the contract. Add new state variables carefully to avoid overwriting existing data."",
        ""Evaluate the impact of upgrades on existing stakers and their accumulated rewards. Develop a migration strategy to ensure a seamless transition during upgrades."",
        ""During upgrades, ensure the reward rate log is maintained or migrated appropriately. Abrupt changes in reward rate logs could cause issues for users.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Profile gas usage of critical functions like `deposit`, `withdraw`, and `extractRewards` to identify potential areas for optimization."",
        ""Consider using more efficient data structures and algorithms where possible to reduce gas costs."",
        ""Minimize the number of storage reads and writes, as these are expensive operations."",
        ""Evaluate the use of assembly code for gas-intensive operations, if applicable."",
        ""Review the order of operations in functions to potentially reduce gas costs. For example, performing cheaper operations before more expensive ones."",
        ""The `max` function is very simple. Is it better to inline it for gas savings?""
      ]
    },
    {
      ""Area"": ""External Interactions & Dependencies"",
      ""Tasks"": [
        ""Review the interfaces for `ILPToken` and `ILiquidityProviders` and verify that the assumed behavior matches the actual implementations."",
        ""Assess the risks associated with relying on external contracts. If these contracts are compromised or have unexpected behavior, it could affect the `HyphenLiquidityFarming` contract."",
        ""Consider adding checks to ensure that external contract addresses are valid and that they implement the expected interfaces."",
        ""Verify that the `BASE_DIVISOR` value from the `ILiquidityProviders` contract is within a reasonable range and does not introduce any vulnerabilities. What is it supposed to represent? Is it only used for scaling, or does it have other semantic meanings?"",
        ""What happens if the ILPToken contract is upgraded? How does it affect the existing stakers within `HyphenLiquidityFarming`?""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `HyphenLiquidityFarming` is an upgradeable smart contract designed for staking ERC721 LP tokens (represented by `ILPToken`) to earn rewards. It supports multiple reward pools, one for each 'base token' associated with the LP NFTs. Rewards can be either native ETH or ERC20 tokens. The contract uses OpenZeppelin Upgradeable libraries for standard functionalities like ownership, pausing, reentrancy protection, and meta-transactions (ERC2771). Rewards are calculated based on the share value derived from the NFT metadata and the time staked, using an accumulator pattern (`accTokenPerShare`) that handles variable reward rates over time."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""HyphenLiquidityFarming"",
    ""Purpose"": ""To allow users to stake specific ERC721 LP tokens and earn rewards based on their stake amount and duration. It manages multiple reward pools distinguished by the base token associated with the LP NFT."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Initializable"",
        ""ERC2771ContextUpgradeable"",
        ""OwnableUpgradeable"",
        ""Pausable"",
        ""ReentrancyGuardUpgradeable"",
        ""IERC721ReceiverUpgradeable""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"",
        ""./metatx/ERC2771ContextUpgradeable.sol"",
        ""../security/Pausable.sol"",
        ""./interfaces/ILPToken.sol"",
        ""./interfaces/ILiquidityProviders.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""lpToken"",
        ""Type"": ""ILPToken"",
        ""Purpose"": ""Interface to the ERC721 LP token contract being staked.""
      },
      {
        ""Name"": ""liquidityProviders"",
        ""Type"": ""ILiquidityProviders"",
        ""Purpose"": ""Interface to a contract providing context or parameters (like BASE_DIVISOR).""
      },
      {
        ""Name"": ""poolInfo"",
        ""Type"": ""mapping(address => PoolInfo)"",
        ""Purpose"": ""Stores reward calculation state (accumulated tokens per share, last update time) for each base token pool.""
      },
      {
        ""Name"": ""nftInfo"",
        ""Type"": ""mapping(uint256 => NFTInfo)"",
        ""Purpose"": ""Stores staking details for each staked NFT ID (staker address, reward debt, unpaid rewards, staked status).""
      },
      {
        ""Name"": ""rewardTokens"",
        ""Type"": ""mapping(address => address)"",
        ""Purpose"": ""Maps a base token address to its corresponding reward token address (can be NATIVE address for ETH).""
      },
      {
        ""Name"": ""nftIdsStaked"",
        ""Type"": ""mapping(address => uint256[])"",
        ""Purpose"": ""Stores an array of NFT IDs staked by each user address.""
      },
      {
        ""Name"": ""totalSharesStaked"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Stores the total amount of shares (derived from NFT amounts) staked for each base token pool.""
      },
      {
        ""Name"": ""rewardRateLog"",
        ""Type"": ""mapping(address => RewardsPerSecondEntry[])"",
        ""Purpose"": ""Stores a historical log of reward rates (rewards per second and timestamp) for each base token pool.""
      },
      {
        ""Name"": ""ACC_TOKEN_PRECISION"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Precision factor used in reward accumulation calculations.""
      },
      {
        ""Name"": ""NATIVE"",
        ""Type"": ""address internal constant"",
        ""Purpose"": ""Represents native currency (ETH) for reward token identification.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract state (upgradeable pattern). Sets trusted forwarder, pauser, and external contract addresses."",
        ""Parameters"": [""address _trustedForwarder"", ""address _pauser"", ""ILiquidityProviders _liquidityProviders"", ""ILPToken _lpToken""],
        ""Returns"": []
      },
      {
        ""Name"": ""initalizeRewardPool"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner-only function to set up a new reward pool for a specific base token."",
        ""Parameters"": [""address _baseToken"", ""address _rewardToken"", ""uint256 _rewardPerSecond""],
        ""Returns"": []
      },
       {
        ""Name"": ""_sendErc20AndGetSentAmount"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal helper to send ERC20 tokens and return the actual amount received by the recipient (useful for fee-on-transfer tokens)."",
        ""Parameters"": [""IERC20Upgradeable _token"", ""uint256 _amount"", ""address _to""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_sendRewardsForNft"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates pending rewards for a specific NFT, sends them (handling partial sends if contract balance is low), and updates the NFT's reward debt and unpaid rewards."",
        ""Parameters"": [""uint256 _nftId"", ""address payable _to""],
        ""Returns"": []
      },
      {
        ""Name"": ""setRewardPerSecond"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Owner-only function to update the reward rate for an existing pool, logging the change."",
        ""Parameters"": [""address _baseToken"", ""uint256 _rewardPerSecond""],
        ""Returns"": []
      },
      {
        ""Name"": ""reclaimTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner-only function to withdraw arbitrary ERC20 tokens or native ETH from the contract."",
        ""Parameters"": [""address _token"", ""uint256 _amount"", ""address payable _to""],
        ""Returns"": []
      },
      {
        ""Name"": ""deposit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to stake an LP NFT. Transfers the NFT to the contract, updates pool and NFT state."",
        ""Parameters"": [""uint256 _nftId"", ""address payable _to""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to unstake an NFT. Sends pending rewards, transfers the NFT back to the user, and updates state."",
        ""Parameters"": [""uint256 _nftId"", ""address payable _to""],
        ""Returns"": []
      },
      {
        ""Name"": ""extractRewards"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to claim pending rewards for a staked NFT without unstaking it."",
        ""Parameters"": [""uint256 _nftId"", ""address payable _to""],
        ""Returns"": []
      },
      {
        ""Name"": ""getUpdatedAccTokenPerShare"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates the current accumulated reward tokens per share for a pool, considering historical reward rates."",
        ""Parameters"": [""address _baseToken""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""pendingToken"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Calculates the amount of rewards pending for a specific staked NFT."",
        ""Parameters"": [""uint256 _nftId""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""updatePool"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the reward state (accTokenPerShare, lastRewardTime) for a specific pool based on the current block time."",
        ""Parameters"": [""address _baseToken""],
        ""Returns"": [""PoolInfo memory pool""]
      },
      {
        ""Name"": ""getNftIdsStaked"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the list of NFT IDs staked by a specific user."",
        ""Parameters"": [""address _user""],
        ""Returns"": [""uint256[] memory nftIds""]
      },
      {
        ""Name"": ""getRewardRatePerSecond"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the current reward rate per second for a specific pool."",
        ""Parameters"": [""address _baseToken""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""onERC721Received"",
        ""Visibility"": ""external pure"",
        ""Purpose"": ""Standard ERC721 receiver hook to allow receiving NFTs via safeTransferFrom."",
        ""Parameters"": [""address"", ""address"", ""uint256"", ""bytes calldata""],
        ""Returns"": [""bytes4""]
      },
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows the contract to receive native ETH deposits (likely for funding rewards)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyOwner"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the contract owner."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""whenNotPaused"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Prevents function execution when the contract is paused."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""nonReentrant"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Protects functions against reentrancy attacks."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ILPToken: Calls `tokenMetadata`, `safeTransferFrom`, `isApprovedForAll`, `getApproved`."",
    ""ILiquidityProviders: Calls `BASE_DIVISOR`."",
    ""IERC20Upgradeable (Reward Token): Calls `balanceOf`, `safeTransfer`."",
    ""IERC20Upgradeable (Arbitrary Token): Calls `safeTransfer` in `reclaimTokens`."",
    ""Native ETH Transfers: Uses low-level `.call{value: ...}` for sending rewards and in `reclaimTokens`."",
    ""_trustedForwarder (ERC2771): Implicit interaction via `_msgSender()` for meta-transactions.""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable Contract Pattern (using OpenZeppelin Initializable)."",
    ""ERC721 NFT Staking."",
    ""Accumulator-based Reward Calculation (`accTokenPerShare`) handling variable reward rates."",
    ""Support for both Native ETH and ERC20 Rewards."",
    ""Unpaid Reward Tracking (handles insufficient contract balance during reward payout)."",
    ""ERC2771 Meta-transaction Support."",
    ""Standard Security Features: Ownable, Pausable, ReentrancyGuard.""
  ],
  ""Questions"": [
    ""What is the exact structure and meaning of the data returned by `lpToken.tokenMetadata(nftId)`? Specifically the middle return value and the scaling factor `liquidityProviders.BASE_DIVISOR()`."",
    ""Is the calculation in `_sendErc20AndGetSentAmount` necessary for the expected reward tokens, or just defensive programming for potential fee-on-transfer tokens?"",
    ""In `withdraw`, the search for the NFT ID in `nftIdsStaked` uses a linear scan. Could this lead to excessive gas costs if a user stakes a very large number of NFTs?"",
    ""The `getUpdatedAccTokenPerShare` function uses `unchecked` arithmetic. Have potential edge cases (e.g., large time gaps, zero `totalSharesStaked`, overflow with high rates) been thoroughly tested?"",
    ""Is the `reclaimTokens` function intended to allow the owner to withdraw *any* token, including potentially the staked `lpToken` NFTs themselves? This could be risky if not intended."",
    ""If a native ETH or ERC20 reward transfer fails within `_sendRewardsForNft` (e.g., recipient contract rejects ETH), the entire transaction reverts. Is this the intended behavior, or should the failure be handled differently (e.g., update `unpaidRewards` without reverting)?"",
    ""What happens if `totalSharesStaked[_baseToken]` becomes 0 while `block.timestamp > pool.lastRewardTime`? `getUpdatedAccTokenPerShare` includes a division by `totalSharesStaked[_baseToken]`, potentially causing a division-by-zero error (though the `updatePool` function checks if `totalSharesStaked > 0` before calling it, this interaction requires care).""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy vulnerability in `_sendRewardsForNft` function when reward token is native"",
      ""Severity"": ""High"",
      ""Description"": ""The `_sendRewardsForNft` function sends rewards to the user using either native token transfer or ERC20 transfer. Native token transfers via `_to.call{value: pending}("""")` can trigger reentrancy attacks if the recipient is a malicious contract. The contract inherits `ReentrancyGuardUpgradeable`, but the function is not marked with `nonReentrant`. Therefore, the recipient can call back into the contract before the state is updated, potentially manipulating the contract’s state during the reward distribution process and potentially draining funds or causing unexpected state changes. Furthermore, this low-level call does not check the return value, which can lead to silent failures if the transfer fails."",
      ""Impact"": ""Loss of funds, state corruption, denial of service. Potential for an attacker to drain the contract of rewards by re-entering the contract during the reward distribution process."",
      ""Location"": ""_sendRewardsForNft function""
    },
    {
      ""Issue"": ""Unbounded Loop in `withdraw` function can lead to denial of service"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `withdraw` function iterates through `nftIdsStaked[msgSender]` to find the index of `_nftId`. If a user has a large number of NFTs staked, this loop could consume a significant amount of gas, potentially leading to a denial of service (DoS) if the gas cost exceeds the block gas limit. This also impacts upgradability as it could make withdraw impossible. Also, the withdrawn NFT is transferred to `msgSender` and rewards are calculated based on `msgSender`, however, it should be transferred to `_to` and rewards should be calculated based on `_to`."",
      ""Impact"": ""Denial of Service. High gas consumption. Incorrectly managed staked NFT list; potential for double withdrawal or denial of withdrawal."",
      ""Location"": ""HyphenLiquidityFarming.sol:284-290, withdraw function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `getUpdatedAccTokenPerShare` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""In `getUpdatedAccTokenPerShare`, the accumulator calculation `accumulator += rewardRateLog[_baseToken][i].rewardsPerSecond * (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));` could potentially lead to an integer overflow if `rewardRateLog[_baseToken][i].rewardsPerSecond` and `(counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp))` are large enough. Though solidity 0.8.0 has default overflow protection, using unchecked can revert unexpectedly with very large numbers. Also, `accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];` may overflow as well.  If `totalSharesStaked[_baseToken]` is 0, it leads to division by zero. If `totalSharesStaked[_baseToken]` is zero, this will cause a division-by-zero error, halting the function and potentially disrupting the contract\'s operations. While there is a check in the `updatePool` function `if (totalSharesStaked[_baseToken] > 0)`, this check doesn't prevent a zero value if shares are withdrawn to zero after that check, but before `getUpdatedAccTokenPerShare` is called. The unchecked block in line 267 could cause issues if the the subtraction results in underflow, although that requires a very specific set of condition and large rewards per second values."",
      ""Impact"": ""Incorrect reward calculation, potential denial of service (if overflow causes revert).  Division by zero reverts can block legitimate users from claiming rewards. The contract\'s reward calculation will fail, and users might be unable to withdraw rewards or deposit tokens."",
      ""Location"": ""HyphenLiquidityFarming.sol:getUpdatedAccTokenPerShare, getUpdatedAccTokenPerShare""
    },
    {
      ""Issue"": ""Missing Input Validation for `_rewardPerSecond` in `initalizeRewardPool` and `setRewardPerSecond`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `initalizeRewardPool` and `setRewardPerSecond` functions, which are onlyOwner functions, do not perform input validation on the `_rewardPerSecond` parameter. Setting a zero value or very high reward rate could lead to rapid depletion of reward tokens or effectively halt reward distribution. Setting this value to zero will stop reward distributions, effectively bricking the rewards. Consider using some sort of mechanism to control the maximum possible reward rate to prevent accidental draining of funds."",
      ""Impact"": ""Owner could unintentionally or maliciously set an unreasonably high reward rate, leading to premature exhaustion of reward tokens. Alternatively, setting the reward rate to zero would prevent users from earning any rewards. Incorrect reward rate settings can lead to unintended consequences, such as rapid depletion of rewards or a complete halt to reward distribution. Setting `_rewardPerSecond` to zero stops reward distribution. Extremely high values can drain the contract balance quickly. This affects the usability of the contract. The owner can grief the users."",
      ""Location"": ""initalizeRewardPool function (lines 107-112), setRewardPerSecond function (lines 158-160), initalizeRewardPool function, setRewardPerSecond function, `initalizeRewardPool` and `setRewardPerSecond` functions, HyphenLiquidityFarming.sol:66, HyphenLiquidityFarming.sol:122""
    },
    {
      ""Issue"": ""Lack of Access Control on `setRewardPerSecond`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setRewardPerSecond` function allows the owner to arbitrarily change the reward rate for a given base token. Frequent or significant changes to the reward rate could potentially be used maliciously to front-run user deposit/withdrawal transactions, causing rewards to be miscalculated or siphoning off rewards. Consider using a more controlled mechanism for updating reward rates (e.g., a curve or a schedule)."",
      ""Impact"": ""Potential for abuse, incorrect reward distribution, complete halting of rewards.Destabilization of the farming mechanism, potential loss of funds if owner's account is compromised."",
      ""Location"": ""HyphenLiquidityFarming.sol:186-188, setRewardPerSecond function""
    },
    {
      ""Issue"": ""Missing checks for zero address in `initalizeRewardPool` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `initalizeRewardPool` function checks if `_baseToken` and `_rewardToken` is not zero address. However, this check can be bypassed by passing the address of the native token (`NATIVE`) as the zero address. This will cause unexpected behavior and potential exploits. Also If _rewardPerSecond is set to zero the pool will be created but no rewards will be distributed. While the function checks that `_baseToken` and `_rewardToken` are not the zero address, it lacks checks within other functions where rewardTokens[_baseToken] is accessed."",
      ""Impact"": ""Malicious user can use the zero address as either `_baseToken` or `_rewardToken` to cause unexpected behavior and potential exploits. Potential for contract breakage, unexpected behavior. If reward per second is set to zero during initialization will lead to pool creation with no rewards being emitted"",
      ""Location"": ""initalizeRewardPool function (lines 109-110), HyphenLiquidityFarming.sol:105-110""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in reward calculation within `_sendRewardsForNft`"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `_sendRewardsForNft` function, the line `pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;` is susceptible to underflow. If `((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION)` is less than `nft.rewardDebt`, an underflow will occur, wrapping around to a large value, potentially allowing a user to claim excessive rewards. While OpenZeppelin's SafeMath is used for token transfers, the intermediate calculation is not protected. The unchecked block in line 267 could cause issues if the the subtraction results in underflow, although that requires a very specific set of condition and large rewards per second values."",
      ""Impact"": ""Users might be able to claim significantly more rewards than they are entitled to due to integer underflow. In the lines where `nft.unpaidRewards` are being set to pending - balance or balance - pending, there is no check to see if there is underflow, and the unchecked keyword is used which could cause unexpected results. Incorrect reward calculation, potentially leading to users receiving less or more rewards than they are entitled to."",
      ""Location"": ""_sendRewardsForNft function (line 134), HyphenLiquidityFarming.sol:89, HyphenLiquidityFarming.sol:91, HyphenLiquidityFarming.sol:96, HyphenLiquidityFarming.sol:101, HyphenLiquidityFarming.sol:253""
    },
    {
      ""Issue"": ""Potential Loss of Precision in reward calculation due to division before multiplication"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `deposit` and `withdraw` functions, the amount is divided by `liquidityProviders.BASE_DIVISOR()` before being used in further calculations, specifically `(amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;` . If `amount` is smaller than `liquidityProviders.BASE_DIVISOR()`, this division will result in rounding down to zero, and information loss. This loss of precision can be mitigated by multiplication before division. In several places, especially when dividing `amount` from `lpToken.tokenMetadata(_nftId)` by `liquidityProviders.BASE_DIVISOR()`, integer division might lead to loss of precision. This loss could result in slightly lower rewards being distributed than intended. Although the impact is likely to be small on individual users, the cumulative effect could be significant over time."",
      ""Impact"": ""Rounding errors in reward calculation, potentially reducing rewards for users. Reduced accuracy of reward distribution, potentially impacting user returns. Smaller rewards than expected."",
      ""Location"": ""HyphenLiquidityFarming.sol:213, 296, deposit, withdraw, _sendRewardsForNft, pendingToken""
    },
    {
      ""Issue"": ""Potential front-running risk in `deposit` function"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `deposit` function, the check for approval of the NFT (`lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this)`) occurs before the actual transfer (`lpToken.safeTransferFrom(msgSender, address(this), _nftId)`).  A malicious actor could monitor the transaction pool, observe a deposit transaction, and then transfer the NFT to another address before the original transaction is mined, causing the original transaction to fail. An attacker could monitor the mempool for pending `deposit` transactions and front-run them.  If an attacker deposited just before another user's deposit, the `updatePool` function called in `deposit` could update the pool's `accTokenPerShare` based on attacker's share.This may slightly change reward distribution, especially if the attacker's deposit is significant and the original user's deposit is small."",
      ""Impact"": ""The deposit transaction will revert if a front-runner transfers the NFT before the original depositor transaction is mined, leading to user frustration. Slight changes in reward distribution. The attacker may receive higher rewards than expected."",
      ""Location"": ""deposit function (lines 183-186), deposit function""
    },
    {
      ""Issue"": ""Lack of slippage control when transferring Native Tokens in `_sendRewardsForNft`"",
      ""Severity"": ""Low"",
      ""Description"": ""When the reward token is native ETH, the `_sendRewardsForNft` function directly transfers ETH using `_to.call{value: pending}(\""\""). If this transfer fails (e.g., due to the recipient being a contract that rejects ETH), the function reverts, and the user cannot claim their rewards. A more robust implementation might involve checking the recipient's code before attempting to transfer ETH or using a try-catch block with a fallback mechanism."",
      ""Impact"": ""Users may not be able to claim rewards if the recipient address is a contract that cannot receive ETH. Potential for loss of funds due to MEV"",
      ""Location"": ""_sendRewardsForNft function, HyphenLiquidityFarming.sol:93""
    },
    {
      ""Issue"": ""Vulnerability in NFT Withdrawal Logic"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `withdraw` function, the logic for removing an NFT ID from the `nftIdsStaked` array is flawed. Specifically, `nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1]` copies the last element of the array to the index being removed and then `pop()`s the last element. This works fine if the element being removed is *not* the last element. However, if the element being removed *is* the last element, then the last element is copied to itself, and then popped, which is correct. But If there are duplicate NFT ids, then it might lead to unexpected issues."",
      ""Impact"": ""Incorrectly managed staked NFT list; potential for double withdrawal or denial of withdrawal."",
      ""Location"": ""HyphenLiquidityFarming.sol:188, HyphenLiquidityFarming.sol:200""
    },
    {
      ""Issue"": ""Missing zero address check in `reclaimTokens` for token address"",
      ""Severity"": ""Low"",
      ""Description"": ""The `reclaimTokens` function checks for zero address only for `_to`. A zero address check for `_token` parameter is missing. If the owner accidentally sets `_token` to address(0), it might lead to unexpected behaviors or reverts when attempting to transfer from address(0)."",
      ""Impact"": ""Potential unexpected reverts during token reclamation. If the owner mistakenly set _token as a zero address when calling reclaimTokens, native tokens could be lost."",
      ""Location"": ""HyphenLiquidityFarming.sol:reclaimTokens, HyphenLiquidityFarming.sol:128""
    },
    {
      ""Issue"": ""Missing Input Validation for `_amount` in `reclaimTokens` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `reclaimTokens` function allows the owner to transfer tokens (including native ETH) out of the contract. There is no check to ensure that the `_amount` being reclaimed is less than or equal to the contract's balance of the specified `_token`. If the `_amount` exceeds the balance, the `safeTransfer` function will revert, however if it is native token transfer it may cause unexpected behavior as the contract does not check its current balance before calling `payable(_to).call{value: _amount}(\""\""). It would be safer to cap `_amount` to the contract's balance of `_token`."",
      ""Impact"": ""Attempting to reclaim more tokens than the contract holds will cause the transaction to fail. In the case of native token, the owner might make an error, thinking funds were transferred when they weren't. Potential for accidental draining of more tokens than intended."",
      ""Location"": ""reclaimTokens function, reclaimTokens function""
    },
    {
      ""Issue"": ""Potential incorrect reward distribution due to integer division"",
      ""Severity"": ""Low"",
      ""Description"": ""The `amount` of the LP tokens is divided by `liquidityProviders.BASE_DIVISOR()` during deposit and withdraw operations: `amount /= liquidityProviders.BASE_DIVISOR();`. Since this is integer division, precision could be lost. Although the `BASE_DIVISOR` is probably chosen carefully so precision loss is minimized, reward distribution might be affected."",
      ""Impact"": ""Reduced accuracy of reward distribution, potentially impacting user returns."",
      ""Location"": ""deposit, withdraw, _sendRewardsForNft, pendingToken""
    },
        {
      ""Issue"": ""Stale PoolInfo Possible"",
      ""Severity"": ""Low"",
      ""Description"": ""The `updatePool` function updates `poolInfo` using the current `block.timestamp`. There's no mechanism to force a pool update after an extended period of inactivity if no one calls the `deposit`, `withdraw` or `extractRewards` functions. This might lead to stale `accTokenPerShare` values being used, potentially affecting the accuracy of reward calculations when staking resumes. Call updatePool on some regular interval to prevent this."",
      ""Impact"": ""Inaccurate reward calculations for users who stake after a period of inactivity. Incorrect reward calculation."",
      ""Location"": ""`HyphenLiquidityFarming.sol:updatePool`, HyphenLiquidityFarming.sol:348-355""
    },
    {
      ""Issue"": ""Potential front-running vulnerability in `setRewardPerSecond`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setRewardPerSecond` function allows the owner to update the reward rate. If an attacker can front-run a legitimate `setRewardPerSecond` transaction with a malicious value, they could potentially manipulate the reward distribution to their benefit, even temporarily. While the owner can correct it, users might get affected within that period."",
      ""Impact"": ""Temporary manipulation of reward rates to the attacker's advantage."",
      ""Location"": ""`HyphenLiquidityFarming.sol:setRewardPerSecond, Vulnerability to Front-Running in `setRewardPerSecond,Lack of Access Control on `setRewardPerSecond` function`""
    },
     {
      ""Issue"": ""Potential for Griefing Attack in `withdraw` function via manipulating `nftIdsStaked`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `withdraw` function, the NFT to be unstaked is removed from the `nftIdsStaked` array by swapping it with the last element and then popping the last element. This approach has potential for a griefing attack. If the user has multiple NFTs staked and the order of withdrawal matters to the user (e.g., different NFTs have different reward characteristics), an attacker could front-run the withdrawal and manipulate the order of NFTs in the array, forcing the user to withdraw a different NFT than intended.  This can be exacerbated if there are other functions that depend on the order of `nftIdsStaked`."",
      ""Impact"": ""User forced to withdraw the wrong NFT, potentially receiving lower rewards, or losing out on other benefits."",
      ""Location"": ""withdraw function, specifically the logic for removing the NFT from the nftIdsStaked array.""
    },
    {
        ""Issue"": ""Missing Zero-Address Check for `_to` in `reclaimTokens`"",
        ""Severity"": ""Medium"",
        ""Description"": ""While the `reclaimTokens` function checks for zero address in `_to`, it only checks for `address(0)` and not the `NATIVE` address, which is essentially the same from the EVM perspective. Sending tokens to the zero address will result in permanent loss of funds, as the tokens cannot be recovered."",
        ""Impact"": ""Permanent loss of funds if the owner mistakenly reclaims tokens to the zero address. Prevents the owner to reclaim native tokens to a zero address."",
        ""Location"": ""Function: `reclaimTokens`. Specific line: `require(_to != address(0), \""ERR__TO_IS_ZERO\"");`""
    },
    {
       ""Issue"": ""Incorrect Reward Calculation in _sendRewardsForNft when rewards are greater than the contract balance"",
       ""Severity"": ""Medium"",
       ""Description"": ""In the _sendRewardsForNft function, when calculating the amount of rewards to send for both native and ERC20 tokens, if the calculated pending rewards are greater than the contract balance, it reduces unpaidRewards. This calculation can result in an incorrect reward amount, leading to less rewards being paid out than what is actually owed."",
       ""Impact"": ""Users might receive less rewards than they are entitled to if the contract doesn't have sufficient balance to cover rewards at a given time."",
       ""Location"": ""`HyphenLiquidityFarming.sol:_sendRewardsForNft`""
    }
  ],
  ""IssueNumber"": 43,
  ""OutputList"": 17
}",251.773992061615,4490.0,35.0,"### **[H-04] Deleting NFT Info can cause users' NFT.unpaidRewards to be permanently erased**

**Report Description**:  
In `_sendRewardsForNft()`, when `address(this).balance` is insufficient at the moment, `nft.unpaidRewards = pending - balance` is recorded, allowing the user to claim it later. However, at L244, the entire `nftInfo` is deleted, erasing `nft.unpaidRewards` permanently. This means users cannot reclaim these unpaid rewards.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this issue. The permanent loss of `unpaidRewards` due to the deletion of `nftInfo` is a critical oversight and should have been identified as a high-severity issue.

---

### **[H-05] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss**

**Report Description**:  
In `getUpdatedAccTokenPerShare()`, precision loss can occur when calculating rewards if the total shares are too large. This can lead to users losing a significant portion or all of their rewards due to incorrect calculations.

**Match in Response List**:  
Matches with the issue titled **""Potential Loss of Precision in reward calculation due to division before multiplication""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of precision loss in reward calculations but does not explicitly mention the impact of large total shares. The severity is also marked as **Low**, whereas the issue report classifies it as **High**.

---

### **[M-04] Owners have absolute control over protocol**

**Report Description**:  
Owners have full control over the protocol, allowing them to manipulate or halt operations. This centralization poses a significant risk to users.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control on `setRewardPerSecond`""**.

**Validation**:  
**Partially Correct**. The response highlights the lack of access control in `setRewardPerSecond`, but it does not address the broader issue of owners having absolute control over the entire protocol. The severity is also marked as **Medium**, which aligns with the issue report.

---

### **[M-06] DoS by gas limit**

**Report Description**:  
In the `deposit` function, an attacker can push too many NFTs to another user's `nftIdsStaked` array. When the user tries to withdraw an NFT at the end of the list, the iteration will consume excessive gas, potentially causing a DoS.

**Match in Response List**:  
Matches with the issue titled **""Unbounded Loop in `withdraw` function can lead to denial of service""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of unbounded loops leading to DoS. It also correctly explains the impact of high gas consumption and potential denial of withdrawal.

---

### **[M-10] Call to non-existing contracts returns success**

**Report Description**:  
Low-level calls (`call`, `delegatecall`, `staticcall`) return success even if the called contract does not exist. This can allow users to send funds to non-existing addresses.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this issue. The ability to send funds to non-existing addresses is a significant security concern and should have been identified.

---

### **[M-14] LiquidityFarming.sol Unbounded for loops can potentially freeze users' funds in edge cases**

**Report Description**:  
In `withdraw()`, the function calls `_sendRewardsForNft()`, which calls `updatePool()`, which in turn calls `getUpdatedAccTokenPerShare()`. The latter loops over `rewardRateLog`, potentially consuming excessive gas and freezing users' funds in edge cases.

**Match in Response List**:  
Matches with the issue titled **""Unbounded Loop in `withdraw` function can lead to denial of service""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of unbounded loops leading to high gas consumption and potential denial of service. The description aligns with the issue report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- **[M-06] DoS by gas limit**
- **[M-14] LiquidityFarming.sol Unbounded for loops can potentially freeze users' funds in edge cases**

**Partially Correct Matches**:
- **[H-05] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss**
- **[M-04] Owners have absolute control over protocol**

**Missed Issues from Issue Report**:
- **[H-04] Deleting NFT Info can cause users' NFT.unpaidRewards to be permanently erased**
- **[M-10] Call to non-existing contracts returns success**

--- 

The response list covers some issues but misses critical vulnerabilities like the permanent loss of `unpaidRewards` and the ability to send funds to non-existing addresses. Additionally, some matches are only partially correct, as they do not fully address the scope or severity of the reported issues.","```
1. Unbounded Loop in `withdraw` function can lead to denial of service
2. Unbounded Loop in `withdraw` function can lead to denial of service
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives**:
   - The true positives are:
     - ""Unbounded Loop in `withdraw` function can lead to denial of service""
     - ""Unbounded Loop in `withdraw` function can lead to denial of service""
   - Both true positives appear at rank 2 in the ranked list of predictions.

2. **Calculate the precision at each rank where a true positive appears**:
   - At rank 2, the precision \( P@2 \) is calculated as:
     \[
     P@2 = \frac{\text{Number of true positives up to rank 2}}{\text{Rank}} = \frac{2}{2} = 1.0
     \]

3. **Compute the Average Precision (AP)**:
   - Since both true positives appear at the same rank, the AP is simply the precision at that rank:
     \[
     AP = 1.0
     \]

**Output**:
```
1.0
```"
WhitelistPeriodManager.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/ILPToken.sol"";

contract WhitelistPeriodManager is Initializable, OwnableUpgradeable, Pausable, ERC2771ContextUpgradeable {
    ILiquidityProviders private liquidityProviders;
    ITokenManager private tokenManager;
    ILPToken private lpToken;
    bool public areWhiteListRestrictionsEnabled;

    /* LP Status */
    // EOA? -> status, stores addresses that we want to ignore, like staking contracts.
    mapping(address => bool) public isExcludedAddress;
    // Token -> TVL
    mapping(address => uint256) private totalLiquidity;
    // Token -> TVL
    mapping(address => mapping(address => uint256)) public totalLiquidityByLp;

    /* Caps */
    // Token Address -> Limit
    mapping(address => uint256) public perTokenTotalCap;
    // Token Address -> Limit
    mapping(address => uint256) public perTokenWalletCap;

    event ExcludedAddressStatusUpdated(address indexed lp, bool indexed status);
    event TotalCapUpdated(address indexed token, uint256 totalCap);
    event PerTokenWalletCap(address indexed token, uint256 perCommunityWalletCap);
    event WhiteListStatusUpdated(bool status);

    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityProviders), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier onlyLpNft() {
        require(_msgSender() == address(lpToken), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    /**
     * @dev initalizes the contract, acts as constructor
     * @param _trustedForwarder address of trusted forwarder
     */
    function initialize(
        address _trustedForwarder,
        address _liquidityProviders,
        address _tokenManager,
        address _lpToken,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        areWhiteListRestrictionsEnabled = true;
        _setLiquidityProviders(_liquidityProviders);
        _setTokenManager(_tokenManager);
        _setLpToken(_lpToken);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    /**
     * @dev Internal Function which checks for various caps before allowing LP to add liqudity
     */
    function _beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        // Per Token Total Cap or PTTC
        require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), ""ERR__LIQUIDITY_EXCEEDS_PTTC"");
        require(
            ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]),
            ""ERR__LIQUIDITY_EXCEEDS_PTWC""
        );
        totalLiquidity[_token] += _amount;
        totalLiquidityByLp[_token][_lp] += _amount;
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to add liqudity. Only callable by LiquidityPoolManager
     */
    function beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityAddition(_lp, _token, _amount);
    }

    /**
     * @dev Internal Function which checks for various caps before allowing LP to remove liqudity
     */
    function _beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        totalLiquidityByLp[_token][_lp] -= _amount;
        totalLiquidity[_token] -= _amount;
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to remove liqudity. Only callable by LiquidityPoolManager
     */
    function beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityRemoval(_lp, _token, _amount);
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to transfer their LpNFT. Only callable by LpNFT contract
     */
    function beforeLiquidityTransfer(
        address _from,
        address _to,
        address _token,
        uint256 _amount
    ) external onlyLpNft whenNotPaused {
        // Release limit from  _from
        _beforeLiquidityRemoval(_from, _token, _amount);

        // Block limit of _to
        _beforeLiquidityAddition(_to, _token, _amount);
    }

    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    function _setLiquidityProviders(address _liquidityProviders) internal {
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
    }

    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {
        _setLiquidityProviders(_liquidityProviders);
    }

    function _setLpToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function setLpToken(address _lpToken) external onlyOwner {
        _setLpToken(_lpToken);
    }

    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external onlyOwner {
        require(_addresses.length == _status.length, ""ERR__LENGTH_MISMATCH"");
        for (uint256 i = 0; i < _addresses.length; ++i) {
            isExcludedAddress[_addresses[i]] = _status[i];
            emit ExcludedAddressStatusUpdated(_addresses[i], _status[i]);
        }
    }

    function setTotalCap(address _token, uint256 _totalCap) public tokenChecks(_token) onlyOwner {
        require(totalLiquidity[_token] <= _totalCap, ""ERR__TOTAL_CAP_LESS_THAN_SL"");
        require(_totalCap >= perTokenWalletCap[_token], ""ERR__TOTAL_CAP_LT_PTWC"");
        if (perTokenTotalCap[_token] != _totalCap) {
            perTokenTotalCap[_token] = _totalCap;
            emit TotalCapUpdated(_token, _totalCap);
        }
    }

    /**
     * @dev Special care must be taken when calling this function
     *      There are no checks for _perTokenWalletCap (since it's onlyOwner), but it's essential that it
     *      should be >= max lp provided by an lp.
     *      Checking this on chain will probably require implementing a bbst, which needs more bandwidth
     *      Call the view function getMaxCommunityLpPositon() separately before changing this value
     */
    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) public tokenChecks(_token) onlyOwner {
        require(_perTokenWalletCap <= perTokenTotalCap[_token], ""ERR__PWC_GT_PTTC"");
        if (perTokenWalletCap[_token] != _perTokenWalletCap) {
            perTokenWalletCap[_token] = _perTokenWalletCap;
            emit PerTokenWalletCap(_token, _perTokenWalletCap);
        }
    }

    function setCap(
        address _token,
        uint256 _totalCap,
        uint256 _perTokenWalletCap
    ) public onlyOwner {
        setTotalCap(_token, _totalCap);
        setPerTokenWalletCap(_token, _perTokenWalletCap);
    }

    function setCaps(
        address[] memory _tokens,
        uint256[] memory _totalCaps,
        uint256[] memory _perTokenWalletCaps
    ) external onlyOwner {
        require(
            _tokens.length == _totalCaps.length && _totalCaps.length == _perTokenWalletCaps.length,
            ""ERR__LENGTH_MISMACH""
        );
        for (uint256 i = 0; i < _tokens.length; ++i) {
            setCap(_tokens[i], _totalCaps[i], _perTokenWalletCaps[i]);
        }
    }

    /**
     * @dev Enables (or disables) reverts if liquidity exceeds caps.
     *      Even if this is disabled, the contract will continue to track LP's positions
     */
    function setAreWhiteListRestrictionsEnabled(bool _status) external onlyOwner {
        areWhiteListRestrictionsEnabled = _status;
        emit WhiteListStatusUpdated(_status);
    }

    /**
     * @dev Returns the maximum amount a single community LP has provided
     */
    function getMaxCommunityLpPositon(address _token) external view returns (uint256) {
        uint256 totalSupply = lpToken.totalSupply();
        uint256 maxLp = 0;
        for (uint256 i = 1; i <= totalSupply; ++i) {
            uint256 liquidity = totalLiquidityByLp[_token][lpToken.ownerOf(i)];
            if (liquidity > maxLp) {
                maxLp = liquidity;
            }
        }
        return maxLp;
    }

    /**
     * @dev returns the value of if (areWhiteListEnabled) then (_cond)
     */
    function ifEnabled(bool _cond) private view returns (bool) {
        return !areWhiteListRestrictionsEnabled || (areWhiteListRestrictionsEnabled && _cond);
    }

    /**
     * @dev Meta-Transaction Helper, returns msgSender
     */
    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    /**
     * @dev Meta-Transaction Helper, returns msgData
     */
    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }
}

",2422,291,"[M-05] Frontrunning of setPerTokenWalletCap edge case

The `setPerTokenWalletCap()` function in WhitelistPeriodManager.sol contains a comment stating:
Special care must be taken when calling this function
There are no checks for _perTokenWalletCap (since it's onlyOwner), but it's essential that it should be >= max lp provided by an lp.
Checking this on chain will probably require implementing a bbst, which needs more bandwidth
Call the view function getMaxCommunityLpPositon() separately before changing this value

Even if the manual step of calling the getMaxCommunityLpPositon() function is properly performed, it is possible for a user to add liquidity to increase the maxLp value in between when the getMaxCommunityLpPositon() function is called and when the setPerTokenWalletCap() function is called. Because this process is manual, this doesn't need to be bot frontrunning in the same block as when the setPerTokenWalletCap() function is called, but can be cause by poor timing of an innocent unknowing user adding liquidity to the protocol. If this condition occurs, the liquidity provider will have provided more liquidity than the perTokenWalletCap limit, breaking the assumptions for this variable and leading to some denial of service conditions.
  [M-15] WhitelistPeriodManager: Improper state handling of exclusion removals

Submitted by hickuphh3, also found by throttle
WhitelistPeriodManager.sol#L178-L184 WhitelistPeriodManager.sol#L115-L125
The totalLiquidity and totalLiquidityByLp mappings are not updated when an address is removed from the isExcludedAddress mapping. While this affects the enforcement of the cap limits and the getMaxCommunityLpPositon() function, the worst impact this has is that the address cannot have liquidity removed / transferred due to subtraction overflow.
In particular, users can be prevented from withdrawing their staked LP tokens from the liquidity farming contract should it become non-excluded.
  [M-16] WhitelistPeriodManager: Improper state handling of exclusion additions

Submitted by hickuphh3
WhitelistPeriodManager.sol#L178-L184 WhitelistPeriodManager.sol#L83-L99
The totalLiquidity and totalLiquidityByLp mappings are not updated when an address is added to the isExcludedAddress mapping. This affects the enforcement of the cap limits and the getMaxCommunityLpPositon() function, which implicitly assumes that whitelisted addresses will have 0 liquidity, for addresses with non-zero liquidity at the time of addition to the whitelist.
",3,,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/ILPToken.sol"";

contract WhitelistPeriodManager is Initializable, OwnableUpgradeable, Pausable, ERC2771ContextUpgradeable {
    ILiquidityProviders private liquidityProviders;
    ITokenManager private tokenManager;
    ILPToken private lpToken;
    bool public areWhiteListRestrictionsEnabled;

    
    
    mapping(address => bool) public isExcludedAddress;
    
    mapping(address => uint256) private totalLiquidity;
    
    mapping(address => mapping(address => uint256)) public totalLiquidityByLp;

    
    
    mapping(address => uint256) public perTokenTotalCap;
    
    mapping(address => uint256) public perTokenWalletCap;

    event ExcludedAddressStatusUpdated(address indexed lp, bool indexed status);
    event TotalCapUpdated(address indexed token, uint256 totalCap);
    event PerTokenWalletCap(address indexed token, uint256 perCommunityWalletCap);
    event WhiteListStatusUpdated(bool status);

    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityProviders), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier onlyLpNft() {
        require(_msgSender() == address(lpToken), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    
    function initialize(
        address _trustedForwarder,
        address _liquidityProviders,
        address _tokenManager,
        address _lpToken,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        areWhiteListRestrictionsEnabled = true;
        _setLiquidityProviders(_liquidityProviders);
        _setTokenManager(_tokenManager);
        _setLpToken(_lpToken);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    
    function _beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        
        require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), ""ERR__LIQUIDITY_EXCEEDS_PTTC"");
        require(
            ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]),
            ""ERR__LIQUIDITY_EXCEEDS_PTWC""
        );
        totalLiquidity[_token] += _amount;
        totalLiquidityByLp[_token][_lp] += _amount;
    }

    
    function beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityAddition(_lp, _token, _amount);
    }

    
    function _beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        totalLiquidityByLp[_token][_lp] -= _amount;
        totalLiquidity[_token] -= _amount;
    }

    
    function beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityRemoval(_lp, _token, _amount);
    }

    
    function beforeLiquidityTransfer(
        address _from,
        address _to,
        address _token,
        uint256 _amount
    ) external onlyLpNft whenNotPaused {
        
        _beforeLiquidityRemoval(_from, _token, _amount);

        
        _beforeLiquidityAddition(_to, _token, _amount);
    }

    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    function _setLiquidityProviders(address _liquidityProviders) internal {
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
    }

    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {
        _setLiquidityProviders(_liquidityProviders);
    }

    function _setLpToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function setLpToken(address _lpToken) external onlyOwner {
        _setLpToken(_lpToken);
    }

    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external onlyOwner {
        require(_addresses.length == _status.length, ""ERR__LENGTH_MISMATCH"");
        for (uint256 i = 0; i < _addresses.length; ++i) {
            isExcludedAddress[_addresses[i]] = _status[i];
            emit ExcludedAddressStatusUpdated(_addresses[i], _status[i]);
        }
    }

    function setTotalCap(address _token, uint256 _totalCap) public tokenChecks(_token) onlyOwner {
        require(totalLiquidity[_token] <= _totalCap, ""ERR__TOTAL_CAP_LESS_THAN_SL"");
        require(_totalCap >= perTokenWalletCap[_token], ""ERR__TOTAL_CAP_LT_PTWC"");
        if (perTokenTotalCap[_token] != _totalCap) {
            perTokenTotalCap[_token] = _totalCap;
            emit TotalCapUpdated(_token, _totalCap);
        }
    }

    
    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) public tokenChecks(_token) onlyOwner {
        require(_perTokenWalletCap <= perTokenTotalCap[_token], ""ERR__PWC_GT_PTTC"");
        if (perTokenWalletCap[_token] != _perTokenWalletCap) {
            perTokenWalletCap[_token] = _perTokenWalletCap;
            emit PerTokenWalletCap(_token, _perTokenWalletCap);
        }
    }

    function setCap(
        address _token,
        uint256 _totalCap,
        uint256 _perTokenWalletCap
    ) public onlyOwner {
        setTotalCap(_token, _totalCap);
        setPerTokenWalletCap(_token, _perTokenWalletCap);
    }

    function setCaps(
        address[] memory _tokens,
        uint256[] memory _totalCaps,
        uint256[] memory _perTokenWalletCaps
    ) external onlyOwner {
        require(
            _tokens.length == _totalCaps.length && _totalCaps.length == _perTokenWalletCaps.length,
            ""ERR__LENGTH_MISMACH""
        );
        for (uint256 i = 0; i < _tokens.length; ++i) {
            setCap(_tokens[i], _totalCaps[i], _perTokenWalletCaps[i]);
        }
    }

    
    function setAreWhiteListRestrictionsEnabled(bool _status) external onlyOwner {
        areWhiteListRestrictionsEnabled = _status;
        emit WhiteListStatusUpdated(_status);
    }

    
    function getMaxCommunityLpPositon(address _token) external view returns (uint256) {
        uint256 totalSupply = lpToken.totalSupply();
        uint256 maxLp = 0;
        for (uint256 i = 1; i <= totalSupply; ++i) {
            uint256 liquidity = totalLiquidityByLp[_token][lpToken.ownerOf(i)];
            if (liquidity > maxLp) {
                maxLp = liquidity;
            }
        }
        return maxLp;
    }

    
    function ifEnabled(bool _cond) private view returns (bool) {
        return !areWhiteListRestrictionsEnabled || (areWhiteListRestrictionsEnabled && _cond);
    }

    
    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    
    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }
}",1958,0,3,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only the owner can call functions protected by `onlyOwner` modifier."",
        ""Confirm the correct initialization of the `OwnableUpgradeable` contract during `initialize()`."",
        ""Analyze the custom `Pausable` contract from `../security/Pausable.sol`. Identify its functionalities and differences compared to `PausableUpgradeable` from OpenZeppelin. Verify that the `_pauser` address is correctly set during initialization and that pausing/unpausing functions work as expected."",
        ""Ensure that the `onlyLiquidityPool` and `onlyLpNft` modifiers correctly restrict access to functions, preventing unauthorized calls from arbitrary addresses by confirming that `liquidityProviders` and `lpToken` state variables are set correctly upon initialization and updated correctly by the `setLiquidityProviders` and `setLpToken` functions respectively."",
        ""Review the `setTokenManager`, `setLiquidityProviders`, and `setLpToken` functions to ensure that they can only be called by the contract owner and that they correctly update the corresponding state variables.""
      ]
    },
    {
      ""Area"": ""Liquidity Cap Enforcement"",
      ""Tasks"": [
        ""Verify that the `_beforeLiquidityAddition` function correctly enforces the `perTokenTotalCap` and `perTokenWalletCap` limits, considering the `isExcludedAddress` mapping."",
        ""Analyze the `ifEnabled` function to ensure that the whitelist restrictions are correctly applied based on the `areWhiteListRestrictionsEnabled` flag."",
        ""Investigate the scenario where `setPerTokenWalletCap` is called with a value lower than the current liquidity held by an LP. Determine the impact and if this is the intended behavior."",
        ""Trace the flow of liquidity addition and removal via `beforeLiquidityAddition` and `beforeLiquidityRemoval` functions respectively. Check if the values of `totalLiquidity` and `totalLiquidityByLp` are correctly updated in all scenarios. Analyze potential race conditions or rounding errors in the calculations."",
        ""Examine the `beforeLiquidityTransfer` function to ensure that liquidity caps are properly enforced during LP token transfers, especially considering the interaction between `_beforeLiquidityRemoval` and `_beforeLiquidityAddition`."",
        ""Verify that setting `areWhiteListRestrictionsEnabled` to `false` effectively disables all liquidity cap restrictions and that setting it to `true` re-enables them.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit the `_isSupportedToken` function to ensure that it correctly retrieves token information from the `tokenManager` contract and that the `supportedToken` flag is accurately reflecting the token's status."",
        ""Analyze the `getMaxCommunityLpPositon` function for potential gas inefficiencies due to iterating through all LP tokens. Consider alternative approaches or limitations on the number of LPs to mitigate gas costs. Assess the DoS risk associated with a large number of LPs."",
        ""Verify that the contract addresses for `liquidityProviders`, `tokenManager`, and `lpToken` are properly validated during initialization and updates to prevent potential attacks using malicious contracts implementing the interfaces.""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Assess the need for `ReentrancyGuardUpgradeable`. Even if not directly inherited, analyze if the external functions (`beforeLiquidityAddition`, `beforeLiquidityRemoval`, `beforeLiquidityTransfer`) are vulnerable to reentrancy attacks through the calling contracts (`liquidityProviders` and `lpToken`). Add `ReentrancyGuardUpgradeable` if necessary."",
        ""Check for potential integer overflow/underflow vulnerabilities in arithmetic operations, especially when handling liquidity amounts. Consider using SafeMath or similar libraries even in solidity 0.8.0 for added safety and clarity."",
        ""Analyze the `setIsExcludedAddressStatus` function to ensure that it correctly updates the `isExcludedAddress` mapping and emits the `ExcludedAddressStatusUpdated` event. Check for potential issues with array lengths and out-of-bounds access."",
        ""Review all require statements to ensure proper error handling and prevent unexpected state changes. Ensure the error messages are informative and helpful for debugging.""
      ]
    },
    {
      ""Area"": ""Upgradeability"",
      ""Tasks"": [
        ""Confirm that all state variables are properly initialized in the `initialize()` function to prevent storage collision issues during upgrades."",
        ""Ensure that the `initializer` modifier is used correctly and that the `initialize()` function can only be called once."",
        ""Verify that the upgrade process will not break any existing functionality or data integrity.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the gas costs of key functions, such as `beforeLiquidityAddition`, `beforeLiquidityRemoval`, `beforeLiquidityTransfer`, and `getMaxCommunityLpPositon`, and identify potential areas for optimization."",
        ""Consider using more efficient data structures or algorithms to reduce gas consumption, especially in functions that iterate through large datasets."",
        ""Evaluate the use of caching or other techniques to reduce redundant calculations or storage accesses.""
      ]
    },
    {
     ""Area"": ""ERC2771 Context and Trusted Forwarder"",
     ""Tasks"": [
       ""Verify the `_msgSender()` and `_msgData()` functions are correctly overridden and return the expected values when using a trusted forwarder."",
       ""Ensure that the `trustedForwarder` address is correctly initialized and that only the trusted forwarder can relay transactions."",
       ""Assess the security implications of using a trusted forwarder and potential risks associated with its compromise.""
     ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `WhitelistPeriodManager` acts as a gatekeeper for liquidity provision operations within a larger DeFi system. It enforces token-specific total supply caps and per-wallet caps during a period when whitelist restrictions are active. It integrates with other contracts (`LiquidityProviders`, `TokenManager`, `LPToken`) via interfaces and supports meta-transactions (ERC2771). It features ownership control, pausability (using a custom implementation), and the ability to exclude specific addresses from cap restrictions. The contract is designed to be upgradeable using the OpenZeppelin Initializable pattern."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""WhitelistPeriodManager"",
    ""Purpose"": ""To enforce total and per-wallet liquidity caps for different tokens during a specific phase (controlled by `areWhiteListRestrictionsEnabled`). It tracks liquidity added by LPs and checks against configured limits before allowing liquidity addition or transfer operations initiated by other system contracts."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Initializable (OZ)"",
        ""OwnableUpgradeable (OZ)"",
        ""Pausable (Custom - ../security/Pausable.sol)"",
        ""ERC2771ContextUpgradeable (OZ)""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""../security/Pausable.sol"",
        ""./metatx/ERC2771ContextUpgradeable.sol"",
        ""./interfaces/ILiquidityProviders.sol"",
        ""./interfaces/ITokenManager.sol"",
        ""./interfaces/ILPToken.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""liquidityProviders"",
        ""Type"": ""ILiquidityProviders"",
        ""Purpose"": ""Interface to the contract managing liquidity pools.""
      },
      {
        ""Name"": ""tokenManager"",
        ""Type"": ""ITokenManager"",
        ""Purpose"": ""Interface to the contract managing supported tokens and their info.""
      },
      {
        ""Name"": ""lpToken"",
        ""Type"": ""ILPToken"",
        ""Purpose"": ""Interface to the LP Token (likely NFT) contract.""
      },
      {
        ""Name"": ""areWhiteListRestrictionsEnabled"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to enable/disable cap restrictions.""
      },
      {
        ""Name"": ""isExcludedAddress"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Mapping to track addresses excluded from whitelist/cap checks.""
      },
      {
        ""Name"": ""totalLiquidity"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks the total liquidity deposited for each token address.""
      },
      {
        ""Name"": ""totalLiquidityByLp"",
        ""Type"": ""mapping(address => mapping(address => uint256))"",
        ""Purpose"": ""Tracks the liquidity deposited by each LP for each token address.""
      },
      {
        ""Name"": ""perTokenTotalCap"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Stores the maximum total liquidity allowed per token.""
      },
      {
        ""Name"": ""perTokenWalletCap"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Stores the maximum liquidity allowed per LP wallet per token.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyLiquidityPool"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function execution to the `liquidityProviders` contract."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyLpNft"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function execution to the `lpToken` contract."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""tokenChecks"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Validates that the token address is non-zero and supported via `tokenManager`."",
        ""Parameters"": [""address tokenAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract state (for upgradeable proxy pattern). Sets up owner, pauser, contract dependencies, and enables restrictions."",
        ""Parameters"": [""_trustedForwarder"", ""_liquidityProviders"", ""_tokenManager"", ""_lpToken"", ""_pauser""],
        ""Returns"": []
      },
      {
        ""Name"": ""_isSupportedToken"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if a token is supported by querying `tokenManager`."",
        ""Parameters"": [""address _token""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_beforeLiquidityAddition"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal logic to check caps and update liquidity tracking upon addition. Skips checks for excluded addresses."",
        ""Parameters"": [""address _lp"", ""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""beforeLiquidityAddition"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Hook called by `liquidityProviders` before adding liquidity. Enforces caps."",
        ""Parameters"": [""address _lp"", ""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_beforeLiquidityRemoval"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal logic to update liquidity tracking upon removal. Skips checks for excluded addresses."",
        ""Parameters"": [""address _lp"", ""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""beforeLiquidityRemoval"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Hook called by `liquidityProviders` before removing liquidity. Updates tracking."",
        ""Parameters"": [""address _lp"", ""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""beforeLiquidityTransfer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Hook called by `lpToken` before transferring LP ownership. Updates liquidity tracking for both sender and receiver, enforcing caps on the receiver."",
        ""Parameters"": [""address _from"", ""address _to"", ""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTokenManager"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the `tokenManager` contract address (Owner only)."",
        ""Parameters"": [""address _tokenManager""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLiquidityProviders"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the `liquidityProviders` contract address (Owner only)."",
        ""Parameters"": [""address _liquidityProviders""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLpToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the `lpToken` contract address (Owner only)."",
        ""Parameters"": [""address _lpToken""],
        ""Returns"": []
      },
      {
        ""Name"": ""setIsExcludedAddressStatus"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the exclusion status for multiple addresses (Owner only)."",
        ""Parameters"": [""address[] _addresses"", ""bool[] _status""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTotalCap"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the total liquidity cap for a specific token (Owner only). Includes validation."",
        ""Parameters"": [""address _token"", ""uint256 _totalCap""],
        ""Returns"": []
      },
      {
        ""Name"": ""setPerTokenWalletCap"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the per-wallet liquidity cap for a specific token (Owner only). Includes validation."",
        ""Parameters"": [""address _token"", ""uint256 _perTokenWalletCap""],
        ""Returns"": []
      },
      {
        ""Name"": ""setCap"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Convenience function to set both total and per-wallet caps for a token (Owner only)."",
        ""Parameters"": [""address _token"", ""uint256 _totalCap"", ""uint256 _perTokenWalletCap""],
        ""Returns"": []
      },
      {
        ""Name"": ""setCaps"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets caps for multiple tokens in a batch (Owner only)."",
        ""Parameters"": [""address[] _tokens"", ""uint256[] _totalCaps"", ""uint256[] _perTokenWalletCaps""],
        ""Returns"": []
      },
      {
        ""Name"": ""setAreWhiteListRestrictionsEnabled"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Enables or disables the enforcement of caps (Owner only)."",
        ""Parameters"": [""bool _status""],
        ""Returns"": []
      },
      {
        ""Name"": ""getMaxCommunityLpPositon"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Calculates the maximum liquidity held by any single non-excluded LP for a given token by iterating through LP tokens."",
        ""Parameters"": [""address _token""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""ifEnabled"",
        ""Visibility"": ""private view"",
        ""Purpose"": ""Helper function to conditionally apply checks based on `areWhiteListRestrictionsEnabled`."",
        ""Parameters"": [""bool _cond""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_msgSender"",
        ""Visibility"": ""internal view virtual override"",
        ""Purpose"": ""Returns the message sender, supporting ERC2771 meta-transactions."",
        ""Parameters"": [],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""_msgData"",
        ""Visibility"": ""internal view virtual override"",
        ""Purpose"": ""Returns the message data, supporting ERC2771 meta-transactions."",
        ""Parameters"": [],
        ""Returns"": [""bytes calldata""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Calls `tokenManager.getTokensInfo(address)` to check token validity."",
    ""Calls `lpToken.totalSupply()` to get the total number of LP tokens."",
    ""Calls `lpToken.ownerOf(uint256)` to get the owner of a specific LP token."",
    ""Is called by the `liquidityProviders` contract (expected addresses for `beforeLiquidityAddition`, `beforeLiquidityRemoval`)."",
    ""Is called by the `lpToken` contract (expected address for `beforeLiquidityTransfer`).""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable Contract Pattern (Initializable)"",
    ""Ownable Access Control (OwnableUpgradeable)"",
    ""Pausable Mechanism (Custom `Pausable` implementation)"",
    ""ERC2771 Meta-transaction Support (`ERC2771ContextUpgradeable`)"",
    ""Conditional Logic (`ifEnabled`) based on `areWhiteListRestrictionsEnabled` flag"",
    ""Interface-based interaction with external system components"",
    ""Address Exclusion List (`isExcludedAddress`)"",
    ""Cap Enforcement (Total per token, Per wallet per token)""
  ],
  ""Questions"": [
    ""What is the specific implementation and behavior of the custom `Pausable` contract from `../security/Pausable.sol`? How does it differ from OpenZeppelin's `PausableUpgradeable` (which is imported but not directly inherited)?"",
    ""Is ReentrancyGuard necessary? The contract imports `ReentrancyGuardUpgradeable` but doesn't inherit it. Are the functions callable by external contracts (`beforeLiquidityAddition`, `beforeLiquidityRemoval`, `beforeLiquidityTransfer`) susceptible to reentrancy through the calling contracts?"",
    ""The function `getMaxCommunityLpPositon` iterates through all LP tokens using `totalSupply` and `ownerOf`. This can be very gas-intensive for a large number of LPs. Is this function intended only for off-chain use, or are the potential gas costs/DoS risks acceptable for its on-chain use case?"",
    ""When `setPerTokenWalletCap` is called to lower the cap, what happens if an existing LP already holds more liquidity than the new cap? The current logic doesn't prevent this state, it only prevents *further* additions. Is this the intended behavior?"",
    ""How is the overall 'whitelist period' managed? Is toggling `areWhiteListRestrictionsEnabled` the only mechanism, or is it tied to other time-based logic elsewhere?"",
    ""What mechanism ensures the addresses set for `liquidityProviders`, `tokenManager`, and `lpToken` are correct and implement the expected interfaces?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Lack of Access Control on Sensitive Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Functions involving fund transfers and role management, such as `crossDeposit`, `crossWithdraw`, `crossBorrow`, `crossOvercollateralizedBorrow`, `initialize` do not implement any access control mechanisms, allowing any user to call these functions and manipulate funds or change the logic without authorization."",
      ""Impact"": ""Unauthorized access could lead to fund mismanagement, unauthorized fund transfers, unauthorized modification of key contract parameters, and potential financial loss to the protocol."",
      ""Location"": ""Functions `crossDeposit`, `crossWithdraw`, `crossBorrow`, `crossOvercollateralizedBorrow`, `initialize`""
    },
    {
      ""Issue"": ""Missing Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `crossDeposit` lacks proper input validation. Specifically, it does not check if the `amount` parameter is zero or negative. Providing such invalid input could lead to unexpected behavior, potential division by zero errors, or denial-of-service attacks."",
      ""Impact"": ""The absence of input validation for amount in the `crossDeposit` function can cause unexpected behavior, DoS or logical issues."",
      ""Location"": ""Function `crossDeposit`""
    }
  ],
  ""IssueNumber"": 4,
  ""OutputList"": 2
}",66.8295829296112,3744.0,8.0,"### **[M-05] Frontrunning of setPerTokenWalletCap edge case**

**Report Description**:
The `setPerTokenWalletCap()` function in `WhitelistPeriodManager.sol` lacks checks to ensure that `_perTokenWalletCap` is greater than or equal to the maximum liquidity provided by a liquidity provider (LP). Although the function is `onlyOwner`, a manual step of calling `getMaxCommunityLpPositon()` is recommended before setting the cap. However, a user could add liquidity between the time `getMaxCommunityLpPositon()` is called and `setPerTokenWalletCap()` is executed, leading to a situation where the `_perTokenWalletCap` is set below the actual maximum liquidity. This could result in denial of service conditions and break the assumptions for the `_perTokenWalletCap` variable.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of frontrunning or improper handling of `_perTokenWalletCap` in `WhitelistPeriodManager.sol`. The provided responses focus on access control and input validation, which are unrelated to this specific issue.

---

### **[M-15] WhitelistPeriodManager: Improper state handling of exclusion removals**

**Report Description**:
When an address is removed from the `isExcludedAddress` mapping in `WhitelistPeriodManager.sol`, the `totalLiquidity` and `totalLiquidityByLp` mappings are not updated. This oversight affects the enforcement of cap limits and the `getMaxCommunityLpPositon()` function. The worst impact is that users may be unable to withdraw their staked LP tokens due to subtraction overflow, particularly if the address becomes non-excluded.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of improper state handling when removing addresses from the `isExcludedAddress` mapping. The responses focus on access control and input validation, which are unrelated to this specific issue.

---

### **[M-16] WhitelistPeriodManager: Improper state handling of exclusion additions**

**Report Description**:
When an address is added to the `isExcludedAddress` mapping in `WhitelistPeriodManager.sol`, the `totalLiquidity` and `totalLiquidityByLp` mappings are not updated. This affects the enforcement of cap limits and the `getMaxCommunityLpPositon()` function, which assumes that whitelisted addresses have zero liquidity. If an address with non-zero liquidity is added to the whitelist, this assumption is violated, leading to incorrect enforcement of liquidity caps.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of improper state handling when adding addresses to the `isExcludedAddress` mapping. The responses focus on access control and input validation, which are unrelated to this specific issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-05] Frontrunning of setPerTokenWalletCap edge case**
- **[M-15] WhitelistPeriodManager: Improper state handling of exclusion removals**
- **[M-16] WhitelistPeriodManager: Improper state handling of exclusion additions**

---

### **Conclusion**
The `response_list` does not adequately address the issues raised in the `issue` report. The responses focus on access control and input validation, which are unrelated to the specific vulnerabilities identified in the `WhitelistPeriodManager.sol` contract. As a result, all three issues are marked as **Incorrect** due to the lack of relevant coverage in the response list.","```
None.
```",0.0
TokenManager.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""../metatx/ERC2771Context.sol"";
import ""../interfaces/ITokenManager.sol"";

contract TokenManager is ITokenManager, ERC2771Context, Ownable, Pausable {
    mapping(address => TokenInfo) public tokensInfo;

    event FeeChanged(address indexed tokenAddress, uint256 indexed equilibriumFee, uint256 indexed maxFee);

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokensInfo[tokenAddress].supportedToken, ""Token not supported"");

        _;
    }

    /**
     * First key is toChainId and second key is token address being deposited on current chain
     */
    mapping(uint256 => mapping(address => TokenConfig)) public depositConfig;

    /**
     * Store min/max amount of token to transfer based on token address
     */
    mapping(address => TokenConfig) public transferConfig;

    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {
        // Empty Constructor
    }

    function getEquilibriumFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].equilibriumFee;
    }

    function getMaxFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].maxFee;
    }

    function changeFee(
        address tokenAddress,
        uint256 _equilibriumFee,
        uint256 _maxFee
    ) external override onlyOwner whenNotPaused {
        require(_equilibriumFee != 0, ""Equilibrium Fee cannot be 0"");
        require(_maxFee != 0, ""Max Fee cannot be 0"");
        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;
        tokensInfo[tokenAddress].maxFee = _maxFee;
        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);
    }

    function setTokenTransferOverhead(address tokenAddress, uint256 gasOverhead)
        external
        tokenChecks(tokenAddress)
        onlyOwner
    {
        tokensInfo[tokenAddress].transferOverhead = gasOverhead;
    }

    /**
     * Set DepositConfig for the given combination of toChainId, tokenAddress.
     * This is used while depositing token in Liquidity Pool. Based on the destination chainid
     * min and max deposit amount is checked.
     */
    function setDepositConfig(
        uint256[] memory toChainId,
        address[] memory tokenAddresses,
        TokenConfig[] memory tokenConfig
    ) external onlyOwner {
        require(
            (toChainId.length == tokenAddresses.length) && (tokenAddresses.length == tokenConfig.length),
            "" ERR_ARRAY_LENGTH_MISMATCH""
        );
        for (uint256 index = 0; index < tokenConfig.length; ++index) {
            depositConfig[toChainId[index]][tokenAddresses[index]].min = tokenConfig[index].min;
            depositConfig[toChainId[index]][tokenAddresses[index]].max = tokenConfig[index].max;
        }
    }

    function addSupportedToken(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit,
        uint256 equilibriumFee,
        uint256 maxFee
    ) external onlyOwner {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        tokensInfo[tokenAddress].supportedToken = true;
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
        tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];
        tokensInfo[tokenAddress].equilibriumFee = equilibriumFee;
        tokensInfo[tokenAddress].maxFee = maxFee;
    }

    function removeSupportedToken(address tokenAddress) external tokenChecks(tokenAddress) onlyOwner {
        tokensInfo[tokenAddress].supportedToken = false;
    }

    function updateTokenCap(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit
    ) external tokenChecks(tokenAddress) onlyOwner {
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
    }

    function getTokensInfo(address tokenAddress) public view override returns (TokenInfo memory) {
        TokenInfo memory tokenInfo = TokenInfo(
            tokensInfo[tokenAddress].transferOverhead,
            tokensInfo[tokenAddress].supportedToken,
            tokensInfo[tokenAddress].equilibriumFee,
            tokensInfo[tokenAddress].maxFee,
            transferConfig[tokenAddress]
        );
        return tokenInfo;
    }

    function getDepositConfig(uint256 toChainId, address tokenAddress)
        public
        view
        override
        returns (TokenConfig memory)
    {
        return depositConfig[toChainId][tokenAddress];
    }

    function getTransferConfig(address tokenAddress) public view override returns (TokenConfig memory) {
        return transferConfig[tokenAddress];
    }

    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address sender) {
        return ERC2771Context._msgSender();
    }

    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {
        return ERC2771Context._msgData();
    }
}",1169,146,"[M-09] Improper Upper Bound Definition on the Fee
 function changeFee()
Submitted by defsec, also found by catchup, danb, Dravee, gzeon, hickuphh3, hubble, peritoflores, Ruhum, and throttle
The equilibriumFee and maxFee does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions or the LP user will lost all funds when paying the fee.
Proof of Concept

Navigate to the following contract.
TokenManager.sol#L52
Owner can identify fee amount. That directly affect to LP management. LiquidityPool.sol#L352
Here you can see there is no upper bound has been defined.
",1,,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""../metatx/ERC2771Context.sol"";
import ""../interfaces/ITokenManager.sol"";

contract TokenManager is ITokenManager, ERC2771Context, Ownable, Pausable {
    mapping(address => TokenInfo) public tokensInfo;

    event FeeChanged(address indexed tokenAddress, uint256 indexed equilibriumFee, uint256 indexed maxFee);

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokensInfo[tokenAddress].supportedToken, ""Token not supported"");

        _;
    }

    
    mapping(uint256 => mapping(address => TokenConfig)) public depositConfig;

    
    mapping(address => TokenConfig) public transferConfig;

    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {
        
    }

    function getEquilibriumFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].equilibriumFee;
    }

    function getMaxFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].maxFee;
    }

    function changeFee(
        address tokenAddress,
        uint256 _equilibriumFee,
        uint256 _maxFee
    ) external override onlyOwner whenNotPaused {
        require(_equilibriumFee != 0, ""Equilibrium Fee cannot be 0"");
        require(_maxFee != 0, ""Max Fee cannot be 0"");
        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;
        tokensInfo[tokenAddress].maxFee = _maxFee;
        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);
    }

    function setTokenTransferOverhead(address tokenAddress, uint256 gasOverhead)
        external
        tokenChecks(tokenAddress)
        onlyOwner
    {
        tokensInfo[tokenAddress].transferOverhead = gasOverhead;
    }

    
    function setDepositConfig(
        uint256[] memory toChainId,
        address[] memory tokenAddresses,
        TokenConfig[] memory tokenConfig
    ) external onlyOwner {
        require(
            (toChainId.length == tokenAddresses.length) && (tokenAddresses.length == tokenConfig.length),
            "" ERR_ARRAY_LENGTH_MISMATCH""
        );
        for (uint256 index = 0; index < tokenConfig.length; ++index) {
            depositConfig[toChainId[index]][tokenAddresses[index]].min = tokenConfig[index].min;
            depositConfig[toChainId[index]][tokenAddresses[index]].max = tokenConfig[index].max;
        }
    }

    function addSupportedToken(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit,
        uint256 equilibriumFee,
        uint256 maxFee
    ) external onlyOwner {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        tokensInfo[tokenAddress].supportedToken = true;
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
        tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];
        tokensInfo[tokenAddress].equilibriumFee = equilibriumFee;
        tokensInfo[tokenAddress].maxFee = maxFee;
    }

    function removeSupportedToken(address tokenAddress) external tokenChecks(tokenAddress) onlyOwner {
        tokensInfo[tokenAddress].supportedToken = false;
    }

    function updateTokenCap(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit
    ) external tokenChecks(tokenAddress) onlyOwner {
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
    }

    function getTokensInfo(address tokenAddress) public view override returns (TokenInfo memory) {
        TokenInfo memory tokenInfo = TokenInfo(
            tokensInfo[tokenAddress].transferOverhead,
            tokensInfo[tokenAddress].supportedToken,
            tokensInfo[tokenAddress].equilibriumFee,
            tokensInfo[tokenAddress].maxFee,
            transferConfig[tokenAddress]
        );
        return tokenInfo;
    }

    function getDepositConfig(uint256 toChainId, address tokenAddress)
        public
        view
        override
        returns (TokenConfig memory)
    {
        return depositConfig[toChainId][tokenAddress];
    }

    function getTransferConfig(address tokenAddress) public view override returns (TokenConfig memory) {
        return transferConfig[tokenAddress];
    }

    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address sender) {
        return ERC2771Context._msgSender();
    }

    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {
        return ERC2771Context._msgData();
    }
}",1066,0,1,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only the contract owner can call functions protected by the `onlyOwner` modifier."",
        ""Confirm that the `Ownable` contract is initialized correctly and the owner is properly set upon deployment."",
        ""Evaluate if the current access control scheme is sufficient for the intended use case. Consider whether additional roles or more granular permissions are needed."",
        ""Check for any instances where sensitive state variables can be modified without proper access control.""
      ]
    },
    {
      ""Area"": ""Pausable Functionality"",
      ""Tasks"": [
        ""Assess the impact of only `changeFee` being pausable. Determine if other sensitive functions (e.g., `addSupportedToken`, `removeSupportedToken`, `updateTokenCap`, `setDepositConfig`, `setTokenTransferOverhead`) should also be pausable for broader emergency control."",
        ""Verify that the `whenNotPaused` modifier functions correctly and prevents execution of `changeFee` when the contract is paused."",
        ""Check the implementation of the `pause()` and `unpause()` functions (inherited from OpenZeppelin) to ensure they are secure and function as expected.""
      ]
    },
    {
      ""Area"": ""Token Configuration Consistency"",
      ""Tasks"": [
        ""Investigate the potential inconsistency between `tokensInfo[tokenAddress].tokenConfig` and `transferConfig[tokenAddress]`. Determine if `tokensInfo.tokenConfig` is redundant or if `updateTokenCap` is missing an update step to `tokensInfo[tokenAddress].tokenConfig`."",
        ""Confirm which storage location (`tokensInfo[tokenAddress].tokenConfig` or `transferConfig[tokenAddress]`) is the source of truth for transfer limits used in the larger system and ensure consistency."",
        ""Analyze the data flow to confirm that `getTokensInfo` consistently returns the expected combined configuration values from both storage locations."",
        ""Write unit tests to specifically verify the values returned by `getTokensInfo` after calling `addSupportedToken` and `updateTokenCap` to ensure proper data synchronization.""
      ]
    },
    {
      ""Area"": ""Input Validation and Sanitization"",
      ""Tasks"": [
        ""Verify that `addSupportedToken` and `updateTokenCap` correctly enforce the `maxCapLimit > minCapLimit` requirement."",
        ""Ensure that the `tokenAddress != address(0)` check in `addSupportedToken` and the `tokenChecks` modifier prevent operations on the zero address."",
        ""Confirm that the array length check in `setDepositConfig` correctly prevents out-of-bounds access or other errors due to mismatched array sizes."",
         ""Analyze if there are any missing input validations that could lead to unexpected behavior or vulnerabilities (e.g. ensuring `equilibriumFee <= maxFee`)."",
        ""Review the error messages for clarity and informational content.""
      ]
    },
    {
      ""Area"": ""Meta-Transaction Security (ERC2771Context)"",
      ""Tasks"": [
        ""Confirm that the `trustedForwarder` address is properly validated and managed."",
        ""Review the `_msgSender()` and `_msgData()` overrides in `ERC2771Context` to ensure they correctly identify the original sender in meta-transactions."",
        ""Analyze the potential for replay attacks in meta-transactions and ensure appropriate mitigation strategies are in place (e.g., nonces)."",
        ""Verify that the contract's interaction with the `trustedForwarder` is secure and does not introduce any vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the gas costs of frequently used functions and identify potential areas for optimization."",
        ""Consider using more efficient data structures or algorithms to reduce gas consumption."",
        ""Evaluate the use of caching or other techniques to minimize redundant calculations."",
        ""Review the order of operations within functions to minimize gas costs."",
        ""Check if immutable variables can be used to reduce gas costs.""
      ]
    },
    {
      ""Area"": ""External Dependencies and Interfaces"",
      ""Tasks"": [
        ""Obtain and review the source code for the `ITokenManager` interface, `TokenInfo` struct, and `TokenConfig` struct to understand their functionality and ensure compatibility."",
        ""Confirm that the contract correctly implements the `ITokenManager` interface."",
        ""Verify that the OpenZeppelin contracts (`Ownable`, `Pausable`) are up-to-date and do not contain any known vulnerabilities."",
        ""Examine the implementation of the `ERC2771Context` contract to assess its security and functionality.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `TokenManager` serves as a configuration hub for managing supported tokens within a larger system, likely related to cross-chain operations or token transfers. It leverages OpenZeppelin's Ownable and Pausable contracts for access control and emergency stops (though Pausable is only used on one function). It also incorporates ERC2771 context for meta-transaction support. The contract allows the owner to add/remove supported tokens, set transfer limits, set deposit limits based on destination chains, configure fees (equilibrium and max), and set gas overhead values. Public view functions are provided to retrieve this configuration data."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""TokenManager"",
    ""Purpose"": ""To manage configuration settings (fees, limits, support status, gas overhead) for various tokens, potentially used in a cross-chain bridge or token transfer system. Provides administrative controls and public getters for configuration data. Supports meta-transactions via ERC2771."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""ITokenManager"",
        ""ERC2771Context"",
        ""Ownable"",
        ""Pausable""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/security/Pausable.sol"",
        ""../metatx/ERC2771Context.sol"",
        ""../interfaces/ITokenManager.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""tokensInfo"",
        ""Type"": ""mapping(address => TokenInfo)"",
        ""Purpose"": ""Stores core configuration details for each token address, including fees, support status, transfer overhead, and potentially transfer limits (via TokenInfo.tokenConfig).""
      },
      {
        ""Name"": ""depositConfig"",
        ""Type"": ""mapping(uint256 => mapping(address => TokenConfig))"",
        ""Purpose"": ""Stores token deposit configurations (min/max limits) indexed by destination chain ID and token address.""
      },
      {
        ""Name"": ""transferConfig"",
        ""Type"": ""mapping(address => TokenConfig)"",
        ""Purpose"": ""Stores token transfer configurations (min/max limits) indexed by token address. Seems to be the primary source for transfer limits used in `getTokensInfo`.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract, setting the trusted forwarder address for ERC2771 meta-transactions."",
        ""Parameters"": [
          ""address trustedForwarder""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""tokenChecks"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Modifier to ensure that operations are performed on a valid (non-zero) and supported token address."",
        ""Parameters"": [
          ""address tokenAddress""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""getEquilibriumFee"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the configured equilibrium fee for a given token."",
        ""Parameters"": [
          ""address tokenAddress""
        ],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""getMaxFee"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the configured maximum fee for a given token."",
        ""Parameters"": [
          ""address tokenAddress""
        ],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""changeFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to change the equilibrium and maximum fees for a token. Can be paused."",
        ""Parameters"": [
          ""address tokenAddress"",
          ""uint256 _equilibriumFee"",
          ""uint256 _maxFee""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setTokenTransferOverhead"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to set a gas overhead value for transfers of a specific supported token."",
        ""Parameters"": [
          ""address tokenAddress"",
          ""uint256 gasOverhead""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setDepositConfig"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to set deposit min/max limits for multiple tokens across multiple destination chains in batch."",
        ""Parameters"": [
          ""uint256[] memory toChainId"",
          ""address[] memory tokenAddresses"",
          ""TokenConfig[] memory tokenConfig""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""addSupportedToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to add a new token to the supported list, setting its initial transfer limits and fees."",
        ""Parameters"": [
          ""address tokenAddress"",
          ""uint256 minCapLimit"",
          ""uint256 maxCapLimit"",
          ""uint256 equilibriumFee"",
          ""uint256 maxFee""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""removeSupportedToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to remove a token from the supported list."",
        ""Parameters"": [
          ""address tokenAddress""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""updateTokenCap"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to update the transfer min/max limits for an already supported token."",
        ""Parameters"": [
          ""address tokenAddress"",
          ""uint256 minCapLimit"",
          ""uint256 maxCapLimit""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""getTokensInfo"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the combined configuration information (overhead, support status, fees, transfer limits) for a given token."",
        ""Parameters"": [
          ""address tokenAddress""
        ],
        ""Returns"": [
          ""TokenInfo memory""
        ]
      },
      {
        ""Name"": ""getDepositConfig"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the deposit configuration (min/max limits) for a specific token and destination chain."",
        ""Parameters"": [
          ""uint256 toChainId"",
          ""address tokenAddress""
        ],
        ""Returns"": [
          ""TokenConfig memory""
        ]
      },
      {
        ""Name"": ""getTransferConfig"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the transfer configuration (min/max limits) for a specific token."",
        ""Parameters"": [
          ""address tokenAddress""
        ],
        ""Returns"": [
          ""TokenConfig memory""
        ]
      },
      {
        ""Name"": ""_msgSender"",
        ""Visibility"": ""internal view virtual"",
        ""Purpose"": ""Overrides the default `_msgSender` to support meta-transactions via ERC2771Context."",
        ""Parameters"": [],
        ""Returns"": [
          ""address sender""
        ]
      },
      {
        ""Name"": ""_msgData"",
        ""Visibility"": ""internal view virtual"",
        ""Purpose"": ""Overrides the default `_msgData` to support meta-transactions via ERC2771Context."",
        ""Parameters"": [],
        ""Returns"": [
          ""bytes calldata""
        ]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Relies on the `ITokenManager` interface definition (not provided in the snippet)."",
    ""Relies on `TokenInfo` and `TokenConfig` struct definitions (likely within `ITokenManager` or another imported file)."",
    ""Inherits from and utilizes OpenZeppelin's `Ownable` and `Pausable` contracts."",
    ""Inherits from and utilizes the local `ERC2771Context` contract, which interacts with a `trustedForwarder` address provided during deployment.""
  ],
  ""SpecialMechanisms"": [
    ""**Meta-transactions:** Implemented using `ERC2771Context` to allow transactions to be relayed, where the gas fee is paid by a third party (the forwarder) but the `_msgSender()` appears as the original intended user."",
    ""**Access Control:** Uses `Ownable` pattern, restricting administrative functions (`addSupportedToken`, `removeSupportedToken`, `changeFee`, etc.) to the contract owner."",
    ""**Pausable:** Uses `Pausable` pattern (`whenNotPaused` modifier), but currently *only* applied to the `changeFee` function, allowing the owner to halt fee updates."",
    ""**Configuration Storage:** Uses mappings (`tokensInfo`, `depositConfig`, `transferConfig`) to store and manage configuration data for different tokens and scenarios.""
  ],
  ""Questions"": [
    ""What are the specific struct definitions for `TokenInfo` and `TokenConfig`? Their fields are implied by usage but not explicitly shown."",
    ""Is the `Pausable` functionality intentionally limited only to `changeFee`? Should other administrative functions (`addSupportedToken`, `removeSupportedToken`, `updateTokenCap`, `setDepositConfig`, `setTokenTransferOverhead`) also be pausable for broader emergency control?"",
    ""There's a potential inconsistency: `addSupportedToken` sets `tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress]`, but `updateTokenCap` *only* updates `transferConfig[tokenAddress]` and not `tokensInfo[tokenAddress].tokenConfig`. The `getTokensInfo` function reads the config from `transferConfig[tokenAddress]`. Is `tokensInfo.tokenConfig` redundant or is `updateTokenCap` missing an update step?"",
    ""Should the `tokenChecks` modifier be applied to the `changeFee` function to prevent setting fees for unsupported or potentially invalid token addresses?"",
    ""What specific calculation or purpose does the `transferOverhead` value serve?"",
    ""Is the error string `ERR_ARRAY_LENGTH_MISMATCH` part of a project-wide standardized error code system?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy risk when interacting with tokens"",
      ""Severity"": ""High"",
      ""Description"": ""The contract lacks explicit reentrancy protection mechanisms when interacting with external tokens (e.g., by calling `transfer` or `transferFrom`). A malicious token contract could potentially drain funds or disrupt the contract's state by re-entering functions during token transfers."",
      ""Impact"": ""A malicious token contract could potentially drain funds from this contract or disrupt its state by re-entering functions during token transfers."",
      ""Location"": ""TokenManager.sol: N/A - This is a general concern if this contract interacts with tokens.""
    },
    {
      ""Issue"": ""Inconsistent Token Configuration Update"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `addSupportedToken` function assigns `transferConfig[tokenAddress]` to `tokensInfo[tokenAddress].tokenConfig`, creating a copy. Subsequent modifications to `transferConfig[tokenAddress]` via `updateTokenCap` will *not* be reflected in `tokensInfo[tokenAddress].tokenConfig`, leading to inconsistent data and potential issues in functions that rely on this data. The `getTokensInfo` function also returns the `transferConfig` directly, making the `tokenConfig` field within `TokenInfo` redundant."",
      ""Impact"": ""Inconsistent data regarding the minimum and maximum token cap limits, leading to unexpected behavior in other parts of the system that rely on this data. Potential for incorrect cap limits being enforced and confusion due to duplicated data. The function `getTokensInfo` returns the `transferConfig` from its local variable, this makes the state variable of `tokenConfig` within `TokenInfo` redundant."",
      ""Location"": ""TokenManager.sol: Function `addSupportedToken` and `updateTokenCap`, TokenManager.sol: `addSupportedToken` function and `getTokensInfo`, TokenManager.sol:73-77, TokenManager.sol:75, TokenManager.sol:87""
    },
    {
      ""Issue"": ""Missing Input Validation and Access Control in Configuration Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Multiple functions lack sufficient input validation and access control. `setTokenTransferOverhead` lacks a zero-address check and `whenNotPaused` modifier. `setDepositConfig` lacks validation for supported tokens, chain IDs, zero-address tokens within the array and has an unbounded array length leading to potential gas exhaustion. `updateTokenCap` lacks validation on cap limits, allowing zero or excessively large values. `addSupportedToken` lacks validation for `equilibriumFee` and `maxFee`, re-adding the same token and no `whenNotPaused` for `setTokenTransferOverhead`."",
      ""Impact"": ""Potential for unintended state changes, denial-of-service, incorrect deposit configurations, logical errors due to illogical values, increased gas costs, configuration errors and abuse by setting configurations for unexpected chain IDs."",
      ""Location"": ""TokenManager.sol: Function `setTokenTransferOverhead`, TokenManager.sol:57-66, TokenManager.sol: Function `updateTokenCap`, TokenManager.sol: Function `addSupportedToken`, TokenManager.sol: `setTokenTransferOverhead` function, TokenManager.sol:55-62, TokenManager.sol:57, TokenManager.sol:87, TokenManager.sol: Lines 82-91,TokenManager.sol:49""
    },
    {
      ""Issue"": ""Missing Pause Functionality for Key Configuration Changes"",
      ""Severity"": ""Medium"",
      ""Description"": ""Critical configuration functions such as `setTokenTransferOverhead`, `setDepositConfig`, `addSupportedToken`, `removeSupportedToken`, and `updateTokenCap` can be executed only by the owner and are not protected by the `whenNotPaused` modifier. This means the owner can modify vital parameters of the system even when the contract is paused, potentially disrupting operations that depend on these settings."",
      ""Impact"": ""During a pause event (e.g., security incident or upgrade), the owner might unintentionally or maliciously alter configurations, leading to system instability or vulnerabilities. Pausing is meant to freeze the system’s state, but these configuration settings undermine this functionality."",
      ""Location"": ""TokenManager.sol: All mentioned functions""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `setDepositConfig`"",
      ""Severity"": ""Low"",
      ""Description"": ""An attacker monitoring the mempool could front-run a transaction to set deposit configurations with malicious values before the intended owner's transaction is mined."",
      ""Impact"": ""Incorrect or malicious deposit configurations could be set by an attacker, potentially causing users to lose funds or experience unexpected behavior during deposit operations."",
      ""Location"": ""TokenManager.sol: Lines 73-81""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Fee Calculations"",
      ""Severity"": ""Low"",
      ""Description"": ""While Solidity 0.8.0 and later versions have built-in overflow/underflow protection, calculations on `equilibriumFee` and `maxFee` should be carefully reviewed for potential vulnerabilities if extremely large or small values were used, especially when interacting with other contracts or libraries. The contract relies on external contracts, and the input of the fee amount is from external user so there is still risk."",
      ""Impact"": ""Unexpected behavior in fee calculations, potentially resulting in incorrect fee amounts or denial-of-service if the calculations cause contract errors. Incorrect fee calculations, leading to financial losses or unexpected behavior. Incorrect fee calculations if these values are used in calculations with token amounts. Could lead to unexpected behavior or denial of service, especially when combined with the ERC20 tokens."",
      ""Location"": ""TokenManager.sol: Potentially throughout the contract where fees are calculated, not explicitly shown but implied by its purpose, TokenManager.sol: Calculations in `changeFee`, `addSupportedToken`, `updateTokenCap` functions,TokenManager.sol: Lines 60-65, 82-91, TokenManager.sol:39, TokenManager.sol:44, TokenManager.sol:59""
    },
    {
      ""Issue"": ""Missing Input Validation in `changeFee` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `changeFee` function checks that `_equilibriumFee` and `_maxFee` are not zero, but it doesn't validate that `_maxFee` is greater than or equal to `_equilibriumFee`.  This can lead to a situation where the `equilibriumFee` is higher than the `maxFee`, potentially causing unexpected behavior."",
      ""Impact"": ""Unexpected fee behavior; potential for economic exploits. Having an equilibrium fee greater than the max fee could lead to unexpected behavior or errors in other parts of the system that rely on these fee values."",
      ""Location"": ""TokenManager.sol:43-50, changeFee""
    },
    {
      ""Issue"": ""Lack of Reentrancy Protection"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract lacks reentrancy protection. Although the current functions don't seem directly vulnerable to reentrancy, it's a good practice to include reentrancy guards, especially in contracts that manage tokens or interact with external contracts."",
      ""Impact"": ""If future updates introduce functions that interact with external contracts, a reentrancy vulnerability could be exploited to drain funds or manipulate the state of the contract."",
      ""Location"": ""Whole contract""
    },
    {
      ""Issue"": ""Missing event emissions in `setDepositConfig` and `updateTokenCap`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setDepositConfig` and `updateTokenCap` functions modify important state variables (deposit configuration and transfer caps, respectively) but do not emit events to notify external listeners about these changes."",
      ""Impact"": ""Lack of event emissions makes it harder for off-chain applications and indexers to track changes to the deposit configurations and transfer limits. This can make monitoring and auditing the contract more difficult."",
      ""Location"": ""setDepositConfig, updateTokenCap""
    },
    {
      ""Issue"": ""Unused `tokenChecks` Modifier in `removeSupportedToken`"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `removeSupportedToken` uses the `tokenChecks` modifier, which requires that `tokensInfo[tokenAddress].supportedToken` is true. However, the function's logic then sets `tokensInfo[tokenAddress].supportedToken` to false, making it redundant and confusing."",
      ""Impact"": ""Code readability and maintainability. The logic is confusing."",
      ""Location"": ""TokenManager.sol:81""
    },
    {
      ""Issue"": ""Missing Input Validation in `setTokenTransferOverhead` Function."",
      ""Severity"": ""Low"",
      ""Description"": ""The `setTokenTransferOverhead` function does not perform any explicit range validation on the `gasOverhead` parameter. Although it checks if the token is supported, it doesn't ensure that the `gasOverhead` value is within acceptable limits .This could potentially allow the owner to set an extremely high `gasOverhead` value, potentially affecting transaction costs."",
      ""Impact"": ""Setting an unreasonably high gas overhead can artificially inflate transaction costs for users interacting with the token, potentially leading to unexpected fees or denial of service."",
      ""Location"": ""TokenManager.sol: Lines 67-71""
    },
     {
      ""Issue"": ""Lack of Access Control for Token Support Status"",
      ""Severity"": ""Low"",
      ""Description"": ""The `tokensInfo` mapping, specifically the `supportedToken` field, is publicly accessible. While only the owner can modify the `supportedToken` status through `addSupportedToken` and `removeSupportedToken`, anyone can query whether a token is supported or not."",
      ""Impact"": ""Information exposure. Not a security risk, but an aspect to be documented clearly."",
      ""Location"": ""TokenManager.sol:9""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow Vulnerabilities (Mitigated by Solidity 0.8.0)"",
      ""Severity"": ""Informational"",
      ""Description"": ""Solidity version 0.8.0 and later includes built-in overflow/underflow checks. Therefore, the arithmetic operations in this contract are safe from overflow/underflow errors."",
      ""Impact"": ""N/A - already mitigated by Solidity version"",
      ""Location"": ""Throughout the contract""
    }
  ],
  ""IssueNumber"": 36,
  ""OutputList"": 13
}",182.80628108978271,3276.0,29.0,"---

**[M-09] Improper Upper Bound Definition on the Fee**

**Report Description**:
The `changeFee` function in `TokenManager.sol` does not define any upper or lower bounds for the `equilibriumFee` and `maxFee` values. This oversight can lead to reversions in critical functions or cause liquidity providers (LPs) to lose all their funds when paying the fee. The lack of bounds allows the owner to set excessively high fees, which could disrupt the contract's functionality and harm users.

**Match in Response List**:
Matches with the issue titled **""Missing Input Validation in `changeFee` Function""**.

**Validation**:
**Partially Correct**. The response correctly identifies the issue of missing input validation in the `changeFee` function, specifically noting that `_maxFee` is not validated to be greater than or equal to `_equilibriumFee`. However, the response does not fully address the broader risk of excessively high fees leading to reversions or fund losses, which is a critical aspect of the reported issue. While the response highlights a specific validation gap, it misses the larger impact of unbounded fee values on the contract's stability and user funds.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-09] Improper Upper Bound Definition on the Fee**

**Missed Issues from Issue Report**:
- *None*

---","```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at any rank is zero, and thus the average precision is also zero."
